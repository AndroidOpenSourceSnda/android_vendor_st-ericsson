/* **************************************************************************
 *
 * config_file_reader.c
 *
 * Copyright (C) 2009 ST-Ericsson SA
 *
 * This software is released either under the terms of the BSD-style
 * license accompanying CSPSA or a proprietary license obtained from
 * ST-Ericsson SA.
 *
 * Author: 2010, Martin Lundholm <martin.xa.lundholm@stericsson.com>
 *
 * DESCRIPTION:
 *
 * CFR = Configuration File Reader
 * Helps reading parameters from a configuratoin file generated by kconfig/menuconfig.
 *
 **************************************************************************** */

// =============================================================================
//  Configurations
// =============================================================================

// - CFG_TEMPLATE_XXX: Brief.
//#ifndef CFG_TEMPLATE_XX_YY
//#define CFG_TEMPLATE_XX_YY                    	(1)
//#endif

// =============================================================================
//  Include Header Files
// =============================================================================

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "config_file_reader.h"

// =============================================================================
//  Defines
// =============================================================================

// - D_TEMPLATE_XX_YY: Xyz.
//#define D_TEMPLATE_XX_YY                   			(1)

// =============================================================================
//  Macros
// =============================================================================

// =============================================================================
//  Local Types
// =============================================================================

// =============================================================================
//  Local Constants
// =============================================================================

// =============================================================================
//  Local Variables
// =============================================================================

// - V_TEMPLATE_XxYy_p: Xyz.
//static TEMPLATE_XxYy_t* V_TEMPLATE_XxYy_p;

// =============================================================================
//  Global External Variables
// =============================================================================

// =============================================================================
//  Local Function Declarations
// =============================================================================

//static TEMPLATE_Result_t F_TEMPLATE_XxYy(void);
//static TEMPLATE_Result_t F_TEMPLATE_XxZz(void);

// =============================================================================
//  External Declarations
// =============================================================================

//extern ExternalFunction(void);

// =============================================================================
//  Local Function Definitions
// =============================================================================

// - F_TEMPLATE_XxYy: Xyz.

//static TEMPLATE_Result_t F_TEMPLATE_XxYy(void)
//{
//	TEMPLATE_Result_t Result = 0;
//
//ErrorExit:
//
//  return Result;
//}

// -----------------------------------------------------------------------------

// =============================================================================
//   Global Function Definitions
// =============================================================================

int CFR_Open(const char* const FileName_p, CFR_Handle_t* const Handle_p)
{
  int Result = 1;
  int FileHandle = -1;
  struct stat StatData;
  char* ConfigText_p = NULL;

  Result = stat(FileName_p, &StatData);
  if (Result == -1) goto ErrorExit;

  FileHandle = open(FileName_p, O_RDONLY, 0);
  if (FileHandle == -1) goto ErrorExit;

  Result = lseek(FileHandle, 0, SEEK_SET);
  if (Result == -1) goto ErrorExit;

  ConfigText_p = (char*) malloc(StatData.st_size + 1);
  if (ConfigText_p == NULL)
  {
    Result = -1;
    goto ErrorExit;
  }

  Result = read(FileHandle, ConfigText_p, StatData.st_size);
  if (Result == -1) goto ErrorExit;

  ConfigText_p[StatData.st_size] = '\0';


  // - Remove all comments (starts with # to end of line). Turn them into blank spaces.
  {
    char* TempChar_p;

    TempChar_p = ConfigText_p;
    while (*TempChar_p != '\0')
    {
      if (*TempChar_p == '#')
      {
        char* StartComment_p = TempChar_p;
        char* EndComment_p = strchr(StartComment_p, (char)0xA);

        if (EndComment_p == NULL)
        {
          EndComment_p = strchr(StartComment_p, (char)0);
        }
        memset(StartComment_p, ' ', (ptrdiff_t)EndComment_p - (ptrdiff_t)StartComment_p);
      }
      TempChar_p++;
    }
  }

  // - Remove all blanks.
  {
    char* Write_p = ConfigText_p;
    char* Read_p = ConfigText_p;

    while (1)
    {
      while (*Read_p == ' ')
      {
        Read_p++;
      }
      *Write_p = *Read_p;
      if (*Read_p == '\0')
      {
        break;
      }
      Write_p++;
      Read_p++;
    }
  }

  // - Remove empty rows.
  {
    char* TempChar_p = ConfigText_p;

    // - Remove all heading new lines.
    while (*TempChar_p == '\n')
    {
      *TempChar_p++ = ' ';
    }
    // - Remove all double new lines.
    while (1)
    {
      TempChar_p = strstr(TempChar_p, "\n\n");
      if (TempChar_p == NULL)
      {
        break;
      }
      *TempChar_p = ' ';
    }
  }

  // - Remove all blanks again.
  {
    char* Write_p = ConfigText_p;
    char* Read_p = ConfigText_p;

    while (1)
    {
      while (*Read_p == ' ')
      {
        Read_p++;
      }
      *Write_p = *Read_p;
      if (*Read_p == '\0')
      {
        break;
      }
      Write_p++;
      Read_p++;
    }
  }

  *Handle_p = (void*) ConfigText_p;
  Result = 0;

ErrorExit:

  if (FileHandle != -1)
  {
    Result = close(FileHandle);
  }

  return Result;
}

// -----------------------------------------------------------------------------

void CFR_Close(CFR_Handle_t* Handle_p)
{
  char* ConfigText_p = (char*) *Handle_p;

  M_CFR_FREE(ConfigText_p);
  *Handle_p = 0;
}

// -----------------------------------------------------------------------------

int CFR_ReadString(const CFR_Handle_t Handle,
                   const char* const Name_p,
                   char* Value_p,
                   const uint32_t MaxLength
)
{
  int Result = -1;
  char* ConfigText_p = (char*) Handle;
  char* Start_p = strstr(ConfigText_p, Name_p);
  char* End_p = NULL;
  uint32_t Length;

  if (Start_p == NULL) goto ErrorExit;

  Start_p = strchr(Start_p, '=');
  if (Start_p == NULL) goto ErrorExit;

  if (*(Start_p+1) == '"')
  {
    Start_p++;
  }

  Start_p++;

  End_p = strchr(Start_p, '\n');
  if (End_p == NULL)
  {
    End_p = strchr(Start_p, '\0');
    if (End_p == NULL) goto ErrorExit;
  }
  if (*(End_p - 1) == '"')
  {
    End_p = End_p - 1;
  }

  if (End_p <= Start_p)
  {
    goto ErrorExit;
  }
  Length = (ptrdiff_t)End_p - (ptrdiff_t)Start_p;
  if (Length > MaxLength)
  {
    goto ErrorExit;
  }

  Value_p = strncpy(Value_p, Start_p, Length);
  Value_p[Length] = '\0';

  Result = 0;

ErrorExit:

  if (Result != 0)
  {
    *Value_p = '\0';
  }

  return Result;
}

// -----------------------------------------------------------------------------

int CFR_ReadUint32(
  const CFR_Handle_t Handle,
  const char* const Name_p,
  uint32_t* const Value_p
)
{
  int Result = -1;
  char ConfigValueString_p[32];
  char* Suffix_p;

  Result = CFR_ReadString(Handle, Name_p, ConfigValueString_p, sizeof(ConfigValueString_p));
  if (Result != 0) goto ErrorExit;

  if (ConfigValueString_p[0] == '0' && ConfigValueString_p[1] == 'x')
  {
    *Value_p = strtoul(&ConfigValueString_p[2], NULL, 16);
  }
  else
  {
    *Value_p = strtoul(ConfigValueString_p, &Suffix_p, 10);
    switch (*Suffix_p)
    {
      case 'k':
      case 'K': *Value_p *= 1024; break;
      case 'm':
      case 'M': *Value_p *= 1024*1024; break;
      case 'g':
      case 'G': *Value_p *= 1024*1024*1024; break;
      //case 't':
      //case 'T': *Value_p *= 1024*1024*1024*1024; break;
      default: break;
    }
  }

  Result = 0;

ErrorExit:

  return Result;
}

// -----------------------------------------------------------------------------

int CFR_ReadUint64(
  const CFR_Handle_t Handle,
  const char* const Name_p,
  uint64_t* const Value_p
)
{
  int Result = -1;
  char ConfigValueString_p[32];
  char* Suffix_p;

  Result = CFR_ReadString(Handle, Name_p, ConfigValueString_p, sizeof(ConfigValueString_p));
  if (Result != 0) goto ErrorExit;

  if (ConfigValueString_p[0] == '0' && ConfigValueString_p[1] == 'x')
  {
    *Value_p = strtoull(&ConfigValueString_p[2], NULL, 16);
  }
  else
  {
    *Value_p = strtoull(ConfigValueString_p, &Suffix_p, 10);
    switch (*Suffix_p)
    {
      case 'k':
      case 'K': *Value_p *= 1024; break;
      case 'm':
      case 'M': *Value_p *= 1024*1024; break;
      case 'g':
      case 'G': *Value_p *= 1024*1024*1024; break;
      case 't':
      case 'T': *Value_p *= 1024ULL*1024*1024*1024; break;
      default: break;
    }
  }

  Result = 0;

ErrorExit:

  return Result;
}

// -----------------------------------------------------------------------------

int CFR_ReadBool(
  const CFR_Handle_t Handle,
  const char* const Name_p,
  uint32_t* Value_p
)
{
  int Result = -1;
  char ConfigValueString_p[32];

  Result = CFR_ReadString(Handle, Name_p, ConfigValueString_p, sizeof(ConfigValueString_p));
  if (Result != 0) goto ErrorExit;

  if ((ConfigValueString_p[0] == 'y') || (ConfigValueString_p[0] == 'Y'))
  {
    *Value_p = 1;
  }
  else
  {
    *Value_p = 0;
  }

  Result = 0;

ErrorExit:

  return Result;
}

// =============================================================================
//   Processes()
// =============================================================================

// =============================================================================
//   main()
// =============================================================================

// =============================================================================
//   End of file
// =============================================================================
