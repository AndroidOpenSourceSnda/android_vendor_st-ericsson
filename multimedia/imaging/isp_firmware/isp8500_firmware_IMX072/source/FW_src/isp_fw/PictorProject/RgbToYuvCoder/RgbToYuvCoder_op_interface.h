/*
 * Copyright (C) ST-Ericsson SA 2010. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 */

/**
 \defgroup RgbToYuvCoder RGB to YUV Coder Module
 \brief RgbToYuvCoder module calculate 3x3 YUV matrix and 3x1 YUV offset matrix to be programmed in
        YUV coder block of Colour engine in ISP. YUV coder can output Standard YUV, custom YUV, Standard RGB and custom
        RGB data. The module also take contast and saturation values from user and apply them to calculate the matrix.
*/

/**
 \file RgbToYuvCoder_op_interface.h
 \brief  This file is a part of the YUV coder module release code and provide an
         interface to the module. All functionalities offered by the module are
         available through this file. The file also declare the page elements
         to be used in virtual register list.

 \ingroup RgbToYuvCoder
*/
#ifndef _RGB_TO_YUV_CODER_OP_INTERFACE_H_
#   define _RGB_TO_YUV_CODER_OP_INTERFACE_H_

#   include "Platform.h"

/**
 \struct RgbToYuvControl_ts
 \brief  Control pages for RgbToYuv Coder. User should prgram the Transform type
         contrast and saturation values in the page elements.
 \ingroup RgbToYuvCoder
*/
typedef struct
{
    /// Output generated by YUV coder
    /// YUV Coder can give both RGB and YUV output
    uint8_t e_Transform_Type;

    /// Contrast Control in %. For example 100% will
    /// have value 100. 120% will apply have value 120 and will apply
    /// gain of 1.2
    /// The value can not be less than 0 \n
    /// [DEFAULT]:  100% i.e. 100
    uint8_t u8_Contrast;

    /// Final contrast applied is clipped against u8_MaxContrast.
    /// e.g. final contrast will have values from u8_Contrast, Contrast from FadeToBlack\n
    /// [DEFAULT]:  200%
    uint8_t u8_MaxContrast;

    /// Colour Saturation Control in %. For example 100% will
    /// have value 100. 120% will apply have value 120 and will apply
    /// gain of 1.2
    /// The value can not be less than 0 \n
    /// [DEFAULT]:  100% i.e. 100
    uint8_t u8_ColourSaturation;

    /// Final saturation applied is clipped against u8_MaxColourSaturation.
    /// e.g. final saturation will have values from u8_ColourSaturation only\n
    /// [DEFAULT]:  200%
    uint8_t u8_MaxColourSaturation;
} RgbToYuvControl_ts;

/**
 \struct RgbToYuvOutputSignalRange_ts
 \brief  The control page element will be used only for custom YUV or custom RGB trasform
         in e_Transform_Type.It is responsiblity of the host to program the Luma and chroma
         excursion as well as the midpoint*2 of the histogram in g_CE_CustomTransformOutputSignalRange[0/1]
 \ingroup RgbToYuvCoder
*/
typedef struct
{
    /// Difference between Maximum code and minimum Luma values \n
    /// YUV format can give maximum 255 as output, so difference between Max and min
    /// Luma or Y should be 255 \n
    /// RGB format can give maximum 1023 as output (ISP is 10 bit pipe), so difference between Max and min
    /// Luma or Y should be maximum 1023 \n
    /// [DEFAULT]:  255
    uint16_t    u16_LumaExcursion;

    /// Midpoint multiplied by 2 for Luma \n
    /// e.g. MaxY = 220, MinY = 20, So midpoint will be = (20 + 220) = 240 \n
    /// [DEFAULT]:  255
    uint16_t    u16_LumaMidpointTimes2;

    /// Difference between Maximum code and minimum Chroma values \n
    /// YUV format can give maximum 255 as output, so difference between Max and min
    /// chroma or Cb/Cr will be 255 \n
    /// RGB format can give maximum 1023 as output (ISP is 10 bit pipe), so difference between Max and min
    /// should be maximum 1023 \n
    /// [DEFAULT]:  255
    uint16_t    u16_ChromaExcursion;

    /// Midpoint multiplied by 2 for Chroma \n
    /// e.g. Max = 220, Min = 20, So midpoint will be = (20 + 220) = 240 \n
    /// [DEFAULT]:  255
    uint16_t    u16_ChromaMidpointTimes2;
} RgbToYuvOutputSignalRange_ts;

/**
 \struct FadeToBlack_ts
 \brief  In a very dark scene the gains applied to the image data will
         increase to maintain the correct exposure. If the scene is too
         dark this will not be possible and a dark image with noise
         artefacts will be the output. The fade to black system ensures that
         in this situation a noise free black image is output by the system.
 \ingroup RgbToYuvCoder
*/
typedef struct
{
    /// Minimum possible damper output.  0.0 fades to absolute black.
    /// 1.0 effectively disables fade to black
    float_t f_BlackValue;

    /// Low Threshold (in Exposure compiler's gained mSecs) for calculating damper slope.
    float_t f_DamperLowThreshold;

    /// High Threshold (in Exposure compiler's gained mSecs) for calculating scythe damper slope.
    float_t f_DamperHighThreshold;

    /// Status Page element to allow tracking of damper
    /// [NOTE]: Host should not modify this page element\n
    float_t f_DamperOutput;

    /// Fade to black control
    /// e_FALSE: Enable the Fade to Black feature
    /// e_TRUE:  Disable the Fade to Black feature \n
    /// [DEFAULT]: e_TRUE (Fade to Black feature is disabled)
    uint8_t e_Flag_Disable;
} FadeToBlack_ts;

/**
 \struct RgbToYuvMatrix_ts
 \brief  The status pages has 3x3 matrix elements to be applied on
         the rgb2yuv coder (in colour engine) on corresponding Pipe.
         The matrix is dependant on the selected transform type, contrast and
         colour saturation values of the histogram.
 \ingroup RgbToYuvCoder
*/
typedef struct
{
    /// YUVCODER_Y_COF00: Conversion matrix coefficient 00
    int16_t s16_w0_0;

    /// YUVCODER_Y_COF01: Conversion matrix coefficient 01
    int16_t s16_w0_1;

    /// YUVCODER_Y_COF02: Conversion matrix coefficient 02
    int16_t s16_w0_2;

    /// YUVCODER_CB_COF10 Conversion matrix coefficient 10
    int16_t s16_w1_0;

    /// YUVCODER_CB_COF11 Conversion matrix coefficient 11
    int16_t s16_w1_1;

    /// YUVCODER_CB_COF12 Conversion matrix coefficient 12
    int16_t s16_w1_2;

    /// YUVCODER_CR_COF20 Conversion matrix coefficient 20
    int16_t s16_w2_0;

    /// YUVCODER_CR_COF21 Conversion matrix coefficient 21
    int16_t s16_w2_1;

    /// YUVCODER_CR_COF22 Conversion matrix coefficient 22
    int16_t s16_w2_2;
} RgbToYuvMatrix_ts;

/**
 \struct RgbToYuvOffsetVector_ts
 \brief  The status pages has 3x1 offset matrix elements to be applied on
        the rgb2yuv coder (in colour engine) on corresponding Pipe.
 \ingroup RgbToYuvCoder
*/
typedef struct
{
    /// YUVCODER_YFLOOR Y data floor
    int16_t s16_i0;

    /// YUVCODER_CBFLOOR Cb data floor
    int16_t s16_i1;

    /// YUVCODER_CRFLOOR Cr data floor
    int16_t s16_i2;
} RgbToYuvOffsetVector_ts;

/**
 \struct YUVCoderStatus_ts
 \brief  Status page element for applied contrast and saturation in PIPE
 \ingroup RgbToYuvCoder
*/
typedef struct
{
    /// Final contrast applied, the value will be clipped against maximum contrast
    float_t f_Contrast;

    /// Final saturation applied, the value will be clipped against maximum saturation
    float_t f_Saturation;
} YUVCoderStatus_ts;

/**
 \struct LumaOffset_ts
 \brief  This page has Luma Offset which Host wants to apply for Brightness.
  \ingroup RgbToYuvCoder
*/
typedef struct
{
    /// Luma Offset
    int16_t s16_LumaOffset;
    /// Flag to tell whether Y_Floor has saturated or not after applying this Luma Offset
    /// When we use RGB format in pipe CBFloor and CRFloor are Flags to tell if they are sturated or not 
    uint8_t  u8_YFloor_Saturated;
    uint8_t  u8_CBFloor_Saturated;
    uint8_t  u8_CRFloor_Saturated;
} LumaOffset_ts;

/**
 \struct CustomStockMatrixControl_ts
 \brief  This page contains custom stock matrix to be used in mode Transform_e_YCbCr_Custom
  \ingroup RgbToYuvCoder
*/
typedef struct
{
    /// custom stock matrix
    /// To be used when Transform_e_YCbCr_Custom mode is selected by HOST
    /// DEFAULT : values corresponding to BT REC601
    float_t f_StockMatrix[9];
} CustomStockMatrixControl_ts;

/********************    API's to be called From Interrupt  ************************************/
extern void                         RgbToYuvCoder_Update (uint8_t u8_PipeNo)TO_EXT_DDR_PRGM_MEM;
extern void                         RGBtoYUVCoder_Commit (uint8_t u8_PipeNo)TO_EXT_DDR_PRGM_MEM;

/************************ Exported Page elements *********************/

/// Pipe0: g_CE_YUVCoderControls[0/1]
extern volatile RgbToYuvControl_ts           g_CE_YUVCoderControls[];

/// Pipe0: g_CE_CustomTransformOutputSignalRange[0/1]
extern volatile RgbToYuvOutputSignalRange_ts g_CE_CustomTransformOutputSignalRange[];

/// Pipe0: g_CE_FadeToBlack[0/1]
extern volatile FadeToBlack_ts               g_CE_FadeToBlack[];

/// Pipe0: g_CE_OutputCoderMatrix[0/1]
extern volatile RgbToYuvMatrix_ts            g_CE_OutputCoderMatrix[];

/// Pipe0: g_CE_OutputCoderOffsetVector[0/1]
extern volatile RgbToYuvOffsetVector_ts      g_CE_OutputCoderOffsetVector[];

/// Pipe0: g_YUVCoderStatus[0/1]
extern volatile YUVCoderStatus_ts            g_YUVCoderStatus[];

// Pipe0: g_LumaOffset[0/1]
extern volatile LumaOffset_ts				g_CE_LumaOffset[];

// page for custom stock matrix to be used 
extern volatile CustomStockMatrixControl_ts g_CustomStockMatrix[];
#endif // _RGB_TO_YUV_CODER_OP_INTERFACE_H_

