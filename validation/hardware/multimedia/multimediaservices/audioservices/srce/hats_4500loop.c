/*****************************************************************************/
/**
*  Â© ST-Ericsson, 2009 - All rights reserved
*  Reproduction and Communication of this document is strictly prohibited
*  unless specifically authorized in writing by ST-Ericsson
*
* \brief   This module provides routines to perform audio loop in STW4500
* \author  ST-Ericsson
*/
/*****************************************************************************/
#define HATS_4500LOOP_C

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "stdint.h"
#include "hats_audio.h"
#include "hats_audio.hi"


/************************************************************************************************/
/* constante definitions */
/************************************************************************************************/
#define PASS  HATS_AUDIO_NO_ERROR
#define FAIL HATS_AUDIO_NOT_AVAILABLE

#define BLOC_4500_AUDIO 0xD
#define bloc_4500_System_Control_1 	  0x01
#define bloc_4500_System_Control_2 	  0x02
#define bloc_4500_Supply_Control_1 	  0x03
#define bloc_4500_Supply_Control_2 	  0x04

#define NB_OF_OUTPUT 0x3
#define NB_OF_INPUT  0x7

/************************************************************************************************/
/* typedef  definitions */
/************************************************************************************************/

typedef struct{
    uint16_t bloc_addr;
    uint16_t reg_addr;
    uint8_t data[AB8500_NB_VERSION];
} Serial_Write_t;

/************************************************************************************************/
/* constante data definitions */
/************************************************************************************************/
const Serial_Write_t  DL_mic1b2headset[] =
{
/* power down audio alim */
 {0x0D,0x00,{0x00,00  ,00  }} /* Power up */
,{0x0D,0x0C,{0x80,0x80,0x80}} /*  Power up for headset /Anaconf5*/
,{0x0D,0x02,{0x20,0x20,0x20}} /*  Digital AD channels enable*/
,{0x0D,0x03,{0xC0,0xC0,0xC0}} /*  Digital DA channels enable*/
,{0x0D,0x04,{0x00,0x02,0x02}} /*  Analog and DMIC*/
,{0x0D,0x05,{0x87,0x87,0x87}} /*  Line In Conf*/
,{0x0D,0x07,{0xB4,0xB4,0xB4}} /*  Analog to Digital Converters enabled */
,{0x0D,0x08,{0x30,0x30,0x30}} /*  Analog output enabled */
,{0x0D,0x09,{0x30,0x30,0x30}} /*  Digital output selection*/
,{0x0D,0x0A,{0x00,0x00,0x00}} /*  Mute enabled*/
,{0x0D,0x0C,{0xFF,0x81,0x81}} /*  Power up for headset /Anaconf5*/
,{0x0D,0x0F,{0xFF,0xFF,0xFF}} /*  Class D configuration*/
,{0x0D,0x10,{0x28,0x28,0x3C}} /*  PWM VBINL*/
,{0x0D,0x11,{0x3C,0x3C,0x28}} /*  PWM VBIPL*/
,{0x0D,0x12,{0x28,0x28,0x3C}} /*  PWM VBINR*/
,{0x0D,0x13,{0x3C,0x3C,0x28}} /*  PWM VBIPR*/
,{0x0D,0x1A,{0x0F,0x0F,0x0F}} /*   AD channel Filters configuration*/
,{0x0D,0x1B,{0xE7,0xE7,0xE7}} /*  TDM configuration*/
,{0x0D,0x1C,{0x26,0x26,0x26}} /*  TDM configuration*/
,{0x0D,0x1D,{0x02,0x02,0x02}} /*  TDM loopback control*/
,{0x0D,0x1E,{0x02,0x02,0x02}} /*  TDM 0/1 */
,{0x0D,0x1F,{0xF2,0xF2,0xF2}} /*  TDM audio Interface Slot assignement*/
,{0x0D,0x33,{0x80,0x80,0x80}} /*  slot selection for DA path1*/
,{0x0D,0x34,{0x00,0x00,0x00}} /*  slot selection for DA path 2*/
,{0x0D,0x35,{0x88,0x88,0x88}} /*  slot selection for DA path 3*/
,{0x0D,0x36,{0x08,0x08,0x08}} /*  slot selection for DA path 4*/
,{0x0D,0x37,{0x88,0x88,0x88}} /*  slot selection for DA path 5*/
,{0x0D,0x38,{0x08,0x08,0x08}} /*  slot selection for DA path 6*/
,{0x0D,0x3F,{0xC0,0xC0,0xC0}} /*  Multiplexers  lsb register*/
,{0x0D,0x40,{0xc4,0xc4,0xc4}} /*  multiplexeur msb*/
,{0x03,0x83,{0x2A,0x2A,0x2A}} /*  Vaudio supply */
,{0x0D,0x00,{0x88,0x88,0x88}} /*  Power up */
,{0xFFFF,0 ,{0   ,0   ,0   }}     /* no more Action needed */
};

const Serial_Write_t  DL_mic2headset[] =
{
/* power down audio alim */
 {0x0D,0x00,{0x00,00  ,00  }} /* Power up */
,{0x0D,0x0C,{0x80,0x80,0x80}} /*  Power up for headset /Anaconf5*/
,{0x0D,0x02,{0x40,0x40,0x40}} /*  Digital AD channels enable*/
,{0x0D,0x03,{0xC0,0xC0,0xC0}} /*  Digital DA channels enable*/
,{0x0D,0x04,{0x00,0x02,0x02}} /*  Analog and DMIC*/
,{0x0D,0x05,{0x4B,0x4B,0x4B}} /*  Line In Conf*/
,{0x0D,0x07,{0x31,0x31,0x31}} /*  Analog to Digital Converters enabled */
,{0x0D,0x08,{0x30,0x30,0x30}} /*  Analog output enabled */
,{0x0D,0x09,{0x30,0x30,0x30}} /*  Digital output selection*/
,{0x0D,0x0A,{0x00,0x00,0x00}} /*  Mute enabled*/
,{0x0D,0x0C,{0xFF,0x81,0x81}} /*  Power up for headset /Anaconf5*/
,{0x0D,0x0F,{0xFF,0xFF,0xFF}} /*  Class D configuration*/
,{0x0D,0x10,{0x28,0x28,0x3C}} /*  PWM VBINL*/
,{0x0D,0x11,{0x3C,0x3C,0x28}} /*  PWM VBIPL*/
,{0x0D,0x12,{0x28,0x28,0x3C}} /*  PWM VBINR*/
,{0x0D,0x13,{0x3C,0x3C,0x28}} /*  PWM VBIPR*/
,{0x0D,0x1A,{0x0F,0x0F,0x0F}} /*   AD channel Filters configuration*/
,{0x0D,0x1B,{0xE7,0xE7,0xE7}} /*  TDM configuration*/
,{0x0D,0x1C,{0x26,0x26,0x26}} /*  TDM configuration*/
,{0x0D,0x1D,{0x02,0x02,0x02}} /*  TDM loopback control*/
,{0x0D,0x1E,{0x02,0x02,0x02}} /*  TDM 0/1 */
,{0x0D,0x1F,{0xF1,0xF1,0xF1}} /*  TDM audio Interface Slot assignement*/
,{0x0D,0x33,{0x80,0x80,0x80}} /*  slot selection for DA path1*/
,{0x0D,0x34,{0x00,0x00,0x00}} /*  slot selection for DA path 2*/
,{0x0D,0x35,{0x88,0x88,0x88}} /*  slot selection for DA path 3*/
,{0x0D,0x36,{0x08,0x08,0x08}} /*  slot selection for DA path 4*/
,{0x0D,0x37,{0x88,0x88,0x88}} /*  slot selection for DA path 5*/
,{0x0D,0x38,{0x08,0x08,0x08}} /*  slot selection for DA path 6*/
,{0x0D,0x3F,{0xC0,0xC0,0xC0}} /*  Multiplexers  lsb register*/
,{0x0D,0x40,{0xc4,0xc4,0xc4}} /*  multiplexeur msb*/
,{0x03,0x83,{0x1e,0x1e,0x1e}} /*  Vaudio supply */
,{0x0D,0x00,{0x88,0x88,0x88}} /*  Power up */
,{0xFFFF,0 ,{0   ,0   ,0   }}     /* no more Action needed */
};

const Serial_Write_t  DL_LinLRheadset[] =
{
/* power down audio alim */
 {0x0D,0x00,{0x00,0x00,0x00}}/* Power up */
,{0x0D,0x0C,{0x80,0x80,0x80}}/*  Power up for headset /Anaconf5*/
,{0x0D,0x02,{0xC0,0xC0,0xC0}}/*  Digital AD channels enable*/
,{0x0D,0x03,{0xC0,0xC0,0xC0}}/*  Digital DA channels enable*/
,{0x0D,0x04,{0x00,0x02,0x02}}/*  Analog and DMIC*/
,{0x0D,0x05,{0x3C,0x3C,0x3C}}/*  Line In Conf*/
,{0x0D,0x07,{0xF3,0xF3,0xF3}}/*  Analog to Digital Converters enabled */
,{0x0D,0x08,{0x30,0x30,0x30}}/*  Analog output enabled */
,{0x0D,0x09,{0x30,0x30,0x30}}/*  Digital output selection*/
,{0x0D,0x0A,{0x00,0x00,0x00}}/*  Mute enabled*/
,{0x0D,0x0C,{0xFF,0x81,0x81}}/*  Power up for headset /Anaconf5*/
,{0x0D,0x0F,{0xFF,0xFF,0xFF}}/*  Class D configuration*/
,{0x0D,0x10,{0x28,0x28,0x3C}} /*  PWM VBINL*/
,{0x0D,0x11,{0x3C,0x3C,0x28}} /*  PWM VBIPL*/
,{0x0D,0x12,{0x28,0x28,0x3C}} /*  PWM VBINR*/
,{0x0D,0x13,{0x3C,0x3C,0x28}} /*  PWM VBIPR*/
,{0x0D,0x1A,{0x0F,0x0F,0x0F}}/*   AD channel Filters configuration*/
,{0x0D,0x1B,{0xE7,0x87,0x87}}/*  TDM configuration*/
,{0x0D,0x1C,{0x26,0x15,0x15}}/*  TDM configuration*/
,{0x0D,0x1D,{0x02,0x02,0x02}}/*  TDM loopback control*/
,{0x0D,0x1E,{0x02,0x02,0x02}}/*  TDM 0/1 */
,{0x0D,0x1F,{0x10,0x10,0x10}}/*  TDM audio Interface Slot assignement*/
,{0x0D,0x33,{0x80,0x80,0x80}}/*  slot selection for DA path1*/
,{0x0D,0x34,{0x01,0x01,0x01}}/*  slot selection for DA path 2*/
,{0x0D,0x35,{0x88,0x88,0x88}}/*  slot selection for DA path 3*/
,{0x0D,0x36,{0x08,0x08,0x08}}/*  slot selection for DA path 4*/
,{0x0D,0x37,{0x88,0x88,0x88}}/*  slot selection for DA path 5*/
,{0x0D,0x38,{0x08,0x08,0x08}}/*  slot selection for DA path 6*/
,{0x0D,0x3F,{0xC0,0xC0,0xC0}}/*  Multiplexers  lsb register*/
,{0x0D,0x40,{0xc4,0xc4,0xc4}}/*  multiplexeur msb*/
,{0x03,0x83,{0x2A,0x2A,0x2A}} /*  Vaudio supply */
,{0x0D,0x00,{0x88,0x88,0x88}} /*  Power up */
,{0xFFFF,0 ,{0   ,0   ,0   }}     /* no more Action needed */
};

const Serial_Write_t  DL_Dmic12headset[] =
{
  /*  Power up */
 {0x0D,0x00,{0x00,0x00,0x00}} /*  Power up */
,{0x0D,0x0C,{0x80,0x80,0x80}} /*  Power up for headset /Anaconf5*/
,{0x0D,0x02,{0xC0,0x80,0x80}} /*  Digital AD channels enable*/
,{0x0D,0x03,{0xC0,0xC0,0xC0}} /*  Digital DA channels enable*/
,{0x0D,0x04,{0x20,0x02,0x02}} /*  Analog and DMIC*/
,{0x0D,0x05,{0x3C,0x3C,0x3C}} /*  Line In Conf*/
,{0x0D,0x06,{0xC0,0xC0,0xC0}} /*  DMIC12 selected*/
,{0x0D,0x07,{0xF3,0xF3,0xF3}} /*  Analog to Digital Converters enabled */
,{0x0D,0x08,{0x30,0x30,0x30}} /*  Analog output enabled */
,{0x0D,0x09,{0x30,0x30,0x30}} /*  Digital output selection*/
,{0x0D,0x0A,{0x00,0x00,0x00}} /*  Mute enabled*/
,{0x0D,0x0C,{0xFF,0x81,0x81}} /*  Power up for headset /Anaconf5*/
,{0x0D,0x0F,{0xFF,0xFF,0xFF}} /*  Class D configuration*/
,{0x0D,0x10,{0x28,0x28,0x3C}} /*  PWM VBINL*/
,{0x0D,0x11,{0x3C,0x3C,0x28}} /*  PWM VBIPL*/
,{0x0D,0x12,{0x28,0x28,0x3C}} /*  PWM VBINR*/
,{0x0D,0x13,{0x3C,0x3C,0x28}} /*  PWM VBIPR*/
,{0x0D,0x1A,{0x0F,0x0F,0x0F}} /*   AD channel Filters configuration*/
,{0x0D,0x1B,{0x87,0x87,0x87}} /*  TDM configuration*/
,{0x0D,0x1C,{0x15,0x15,0x15}} /*  TDM configuration*/
,{0x0D,0x1D,{0x02,0x02,0x02}} /*  TDM loopback control*/
,{0x0D,0x1E,{0x02,0x02,0x02}} /*  TDM 0/1 */
,{0x0D,0x1F,{0x10,0x10,0x10}} /*  TDM audio Interface Slot assignement*/
,{0x0D,0x33,{0x80,0x80,0x80}} /*  slot selection for DA path1*/
,{0x0D,0x34,{0x01,0x01,0x01}} /*  slot selection for DA path 2*/
,{0x0D,0x35,{0x88,0x88,0x88}} /*  slot selection for DA path 3*/
,{0x0D,0x36,{0x08,0x08,0x08}} /*  slot selection for DA path 4*/
,{0x0D,0x37,{0x88,0x88,0x88}} /*  slot selection for DA path 5*/
,{0x0D,0x38,{0x08,0x08,0x08}} /*  slot selection for DA path 6*/
,{0x0D,0x3F,{0xFE,0xFE,0xFE}} /*  Multiplexers  lsb register*/
,{0x0D,0x40,{0xc4,0xc4,0xc4}} /*  multiplexeur msb*/
,{0x03,0x83,{0x26,0x26,0x26}}   /*  Vaudio supply */
,{0x0D,0x00,{0x88,0x88,0x88}}   /*  Power up */
,{0xFFFF,0 ,{0   ,0   ,0   }}    /* no more Action needed */

}; 

const Serial_Write_t  DL_Dmic34headset[] =
{
/* power down audio alim */
 {0x0D,0x00,{0x00,0x00,0x00}} /*  Power up */
,{0x0D,0x0C,{0x80,0x80,0x80}} /*  Power up for headset /Anaconf5*/
,{0x0D,0x02,{0x30,0x30,0x30}} /*  Digital AD channels enable*/
,{0x0D,0x03,{0xC0,0xC0,0xC0}} /*  Digital DA channels enable*/
,{0x0D,0x04,{0x00,0x02,0x02}} /*  Analog and DMIC*/
,{0x0D,0x05,{0x3C,0x3C,0x3C}} /*  Line In Conf*/
,{0x0D,0x06,{0x30,0x30,0x30}} /*  DMIC34 selected*/
,{0x0D,0x07,{0xF3,0xF3,0xF3}} /*  Analog to Digital Converters enabled */
,{0x0D,0x08,{0x30,0x30,0x30}} /*  Analog output enabled */
,{0x0D,0x09,{0x30,0x30,0x30}} /*  Digital output selection*/
,{0x0D,0x0A,{0x00,0x00,0x00}} /*  Mute enabled*/
,{0x0D,0x0C,{0xFF,0x81,0x81}} /*  Power up for headset /Anaconf5*/
,{0x0D,0x0F,{0xFF,0xFF,0xFF}} /*  Class D configuration*/
,{0x0D,0x10,{0x28,0x28,0x3C}} /*  PWM VBINL*/
,{0x0D,0x11,{0x3C,0x3C,0x28}} /*  PWM VBIPL*/
,{0x0D,0x12,{0x28,0x28,0x3C}} /*  PWM VBINR*/
,{0x0D,0x13,{0x3C,0x3C,0x28}} /*  PWM VBIPR*/
,{0x0D,0x1A,{0x0F,0x0F,0x0F}} /*   AD channel Filters configuration*/
,{0x0D,0x1B,{0xE7,0xE7,0xE7}} /*  TDM configuration*/
,{0x0D,0x1C,{0x26,0x26,0x26}} /*  TDM configuration*/
,{0x0D,0x1D,{0x02,0x02,0x02}} /*  TDM loopback control*/
,{0x0D,0x1E,{0x02,0x02,0x02}} /*  TDM 0/1 */
,{0x0D,0x1F,{0x32,0x32,0x32}} /*  TDM audio Interface Slot assignement*/
,{0x0D,0x33,{0x80,0x80,0x80}} /*  slot selection for DA path1*/
,{0x0D,0x34,{0x01,0x01,0x01}} /*  slot selection for DA path 2*/
,{0x0D,0x35,{0x88,0x88,0x88}} /*  slot selection for DA path 3*/
,{0x0D,0x36,{0x08,0x08,0x08}} /*  slot selection for DA path 4*/
,{0x0D,0x37,{0x88,0x88,0x88}} /*  slot selection for DA path 5*/
,{0x0D,0x38,{0x08,0x08,0x08}} /*  slot selection for DA path 6*/
,{0x0D,0x3F,{0xFE,0xFE,0xFE}} /*  Multiplexers  lsb register*/
,{0x0D,0x40,{0xc4,0xc4,0xc4}} /*  multiplexeur msb*/
,{0x03,0x83,{0x26,0x26,0x26}}   /*  Vaudio supply */
,{0x0D,0x00,{0x88,0x88,0x88}}   /*  Power up */
,{0xFFFF,0 ,{0   ,0   ,0   }}       /* no more Action needed */
};

const Serial_Write_t  DL_Dmic56headset[] =
{
/* power down audio alim */
 {0x0D,0x00,{0x00,0x00,0x00}} /*  Power up */
,{0x0D,0x0C,{0x80,0x80,0x80}} /*  Power up for headset /Anaconf5*/
,{0x0D,0x02,{0x0C,0x0C,0x0C}} /*  Digital AD channels enable*/
,{0x0D,0x03,{0xC0,0xC0,0xC0}} /*  Digital DA channels enable*/
,{0x0D,0x04,{0x00,0x02,0x02}} /*  Analog and DMIC*/
,{0x0D,0x05,{0x3C,0x3C,0x3C}} /*  Line In Conf*/
,{0x0D,0x06,{0x0C,0x0C,0x0C}} /*  DMIC56 selected*/
,{0x0D,0x07,{0xF3,0xF3,0xF3}} /*  Analog to Digital Converters enabled */
,{0x0D,0x08,{0x30,0x30,0x30}} /*  Analog output enabled */
,{0x0D,0x09,{0x30,0x30,0x30}} /*  Digital output selection*/
,{0x0D,0x0A,{0x00,0x00,0x00}} /*  Mute enabled*/
,{0x0D,0x0C,{0xFF,0x81,0x81}} /*  Power up for headset /Anaconf5*/
,{0x0D,0x0F,{0xFF,0xFF,0xFF}} /*  Class D configuration*/
,{0x0D,0x10,{0x28,0x28,0x3C}} /*  PWM VBINL*/
,{0x0D,0x11,{0x3C,0x3C,0x28}} /*  PWM VBIPL*/
,{0x0D,0x12,{0x28,0x28,0x3C}} /*  PWM VBINR*/
,{0x0D,0x13,{0x3C,0x3C,0x28}} /*  PWM VBIPR*/
,{0x0D,0x1A,{0x0F,0x0F,0x0F}} /*   AD channel Filters configuration*/
,{0x0D,0x1B,{0xE7,0x87,0x87}} /*  TDM configuration*/
,{0x0D,0x1C,{0x26,0x15,0x15}} /*  TDM configuration*/
,{0x0D,0x1D,{0x02,0x02,0x02}} /*  TDM loopback control*/
,{0x0D,0x1E,{0x02,0x02,0x02}} /*  TDM 0/1 */
,{0x0D,0x1F,{0x54,0x54,0x54}} /*  TDM audio Interface Slot assignement*/
,{0x0D,0x33,{0x80,0x80,0x80}} /*  slot selection for DA path1*/
,{0x0D,0x34,{0x01,0x01,0x01}} /*  slot selection for DA path 2*/
,{0x0D,0x35,{0x88,0x88,0x88}} /*  slot selection for DA path 3*/
,{0x0D,0x36,{0x08,0x08,0x08}} /*  slot selection for DA path 4*/
,{0x0D,0x37,{0x88,0x88,0x88}} /*  slot selection for DA path 5*/
,{0x0D,0x38,{0x08,0x08,0x08}} /*  slot selection for DA path 6*/
,{0x0D,0x3F,{0xFE,0xFE,0xFE}} /*  Multiplexers  lsb register*/
,{0x0D,0x40,{0xc4,0xc4,0xc4}} /*  multiplexeur msb*/
,{0x03,0x83,{0x26,0x26,0x26}}   /*  Vaudio supply */
,{0x0D,0x00,{0x88,0x88,0x88}}   /*  Power up */
,{0xFFFF,0 ,{0   ,0   ,0   }}       /* no more Action needed */
}; 


const Serial_Write_t  DL_mic1b2earpiece[] =
{
/* power down audio alim */
 {0x0D,0x00,{0x00,0x00,0x00}} /*  Power up */
,{0x0D,0x0C,{0x80,0x80,0x80}} /*  Power up for headset /Anaconf5*/
,{0x0D,0x02,{0x20,0x20,0x20}} /*  Digital AD channels enable*/
,{0x0D,0x03,{0xC0,0xC0,0xC0}} /*  Digital DA channels enable*/
,{0x0D,0x04,{0x00,0x00,0x00}} /*  Analog and DMIC*/
,{0x0D,0x05,{0x87,0x87,0x87}} /*  Line In Conf*/
,{0x0D,0x07,{0x84,0x84,0x84}} /*  Analog to Digital Converters enabled */
,{0x0D,0x08,{0x40,0x40,0x40}} /*  Analog output enabled */
,{0x0D,0x09,{0x40,0x40,0x40}} /*  Digital output selection*/
,{0x0D,0x0A,{0x00,0x00,0x00}} /*  Mute enabled*/
,{0x0D,0x0F,{0xFF,0xFF,0xFF}} /*  Class D configuration*/
,{0x0D,0x10,{0x28,0x28,0x3C}} /*  PWM VBINL*/
,{0x0D,0x11,{0x3C,0x3C,0x28}} /*  PWM VBIPL*/
,{0x0D,0x12,{0x28,0x28,0x3C}} /*  PWM VBINR*/
,{0x0D,0x13,{0x3C,0x3C,0x28}} /*  PWM VBIPR*/
,{0x0D,0x1A,{0x0F,0x0F,0x0F}} /*   AD channel Filters configuration*/
,{0x0D,0x1B,{0xE7,0xE7,0xE7}} /*  TDM configuration*/
,{0x0D,0x1C,{0x26,0x26,0x26}} /*  TDM configuration*/
,{0x0D,0x1D,{0x02,0x02,0x02}} /*  TDM loopback control*/
,{0x0D,0x1E,{0x02,0x02,0x02}} /*  TDM 0/1 */
,{0x0D,0x1F,{0xF2,0xF2,0xF2}} /*  TDM audio Interface Slot assignement*/
,{0x0D,0x33,{0x80,0x80,0x80}} /*  slot selection for DA path1*/
,{0x0D,0x34,{0x00,0x00,0x00}} /*  slot selection for DA path 2*/
,{0x0D,0x35,{0x88,0x88,0x88}} /*  slot selection for DA path 3*/
,{0x0D,0x36,{0x08,0x08,0x08}} /*  slot selection for DA path 4*/
,{0x0D,0x37,{0x88,0x88,0x88}} /*  slot selection for DA path 5*/
,{0x0D,0x38,{0x08,0x08,0x08}} /*  slot selection for DA path 6*/
,{0x0D,0x3F,{0xC0,0xC0,0xC0}} /*  Multiplexers  lsb register*/
,{0x0D,0x40,{0xc4,0xc4,0xc4}} /*  multiplexeur msb*/
,{0x03,0x83,{0x2A,0x2A,0x2A}} /*  Vaudio supply */
,{0x0D,0x00,{0x88,0x88,0x88}} /*  Power up */
,{0xFFFF,0 ,{0   ,0   ,0   }}     /* no more Action needed */
};

const Serial_Write_t  DL_mic1a2earpiece[] =
{
/* power down audio alim */
 {0x0D,0x00,{0x00,0x00,0x00}} /*  Power up */
,{0x0D,0x0C,{0x80,0x80,0x80}} /*  Power up for headset /Anaconf5*/
,{0x0D,0x02,{0x20,0x20,0x20}} /*  Digital AD channels enable*/
,{0x0D,0x03,{0xC0,0xC0,0xC0}} /*  Digital DA channels enable*/
,{0x0D,0x04,{0x00,0x00,0x00}} /*  Analog and DMIC*/
,{0x0D,0x05,{0x87,0x87,0x87}} /*  Line In Conf*/
,{0x0D,0x07,{0x04,0x04,0x04}} /*  Analog to Digital Converters enabled */
,{0x0D,0x08,{0x40,0x40,0x40}} /*  Analog output enabled */
,{0x0D,0x09,{0x40,0x40,0x40}} /*  Digital output selection*/
,{0x0D,0x0A,{0x00,0x00,0x00}} /*  Mute enabled*/
,{0x0D,0x0F,{0xFF,0xFF,0xFF}} /*  Class D configuration*/
,{0x0D,0x10,{0x28,0x28,0x3C}} /*  PWM VBINL*/
,{0x0D,0x11,{0x3C,0x3C,0x28}} /*  PWM VBIPL*/
,{0x0D,0x12,{0x28,0x28,0x3C}} /*  PWM VBINR*/
,{0x0D,0x13,{0x3C,0x3C,0x28}} /*  PWM VBIPR*/
,{0x0D,0x1A,{0x0F,0x0F,0x0F}} /*   AD channel Filters configuration*/
,{0x0D,0x1B,{0xE7,0xE7,0xE7}} /*  TDM configuration*/
,{0x0D,0x1C,{0x26,0x26,0x26}} /*  TDM configuration*/
,{0x0D,0x1D,{0x02,0x02,0x02}} /*  TDM loopback control*/
,{0x0D,0x1E,{0x02,0x02,0x02}} /*  TDM 0/1 */
,{0x0D,0x1F,{0xF2,0xF2,0xF2}} /*  TDM audio Interface Slot assignement*/
,{0x0D,0x33,{0x80,0x80,0x80}} /*  slot selection for DA path1*/
,{0x0D,0x34,{0x00,0x00,0x00}} /*  slot selection for DA path 2*/
,{0x0D,0x35,{0x88,0x88,0x88}} /*  slot selection for DA path 3*/
,{0x0D,0x36,{0x08,0x08,0x08}} /*  slot selection for DA path 4*/
,{0x0D,0x37,{0x88,0x88,0x88}} /*  slot selection for DA path 5*/
,{0x0D,0x38,{0x08,0x08,0x08}} /*  slot selection for DA path 6*/
,{0x0D,0x3F,{0xC0,0xC0,0xC0}} /*  Multiplexers  lsb register*/
,{0x0D,0x40,{0xc4,0xc4,0xc4}} /*  multiplexeur msb*/
,{0x03,0x83,{0x2A,0x2A,0x2A}} /*  Vaudio supply */
,{0x0D,0x00,{0x88,0x88,0x88}} /*  Power up */
,{0xFFFF,0 ,{0   ,0   ,0   }}     /* no more Action needed */
};


const Serial_Write_t  DL_mic1a2handsfree[] =
{
/* power down audio alim */
 {0x0D,0x00,{0x00,0x00,0x00}} /*  Power up */
,{0x0D,0x0C,{0x80,0x80,0x80}} /*  Power up for headset /Anaconf5*/
,{0x0D,0x02,{0x20,0x20,0x20}} /*  Digital AD channels enable*/
,{0x0D,0x03,{0x30,0x30,0x30}} /*  Digital DA channels enable*/
,{0x0D,0x04,{0x00,0x00,0x00}} /*  Analog and DMIC*/
,{0x0D,0x05,{0x87,0x87,0x87}} /*  Line In Conf*/
,{0x0D,0x07,{0x04,0x04,0x04}} /*  Analog to Digital Converters enabled */
,{0x0D,0x08,{0x0C,0x0C,0x0C}} /*  Analog output enabled */
,{0x0D,0x09,{0x0C,0x0C,0x0C}} /*  Digital output selection*/
,{0x0D,0x0A,{0x00,0x00,0x00}} /*  Mute enabled*/
,{0x0D,0x0F,{0xFF,0xFF,0xFF}} /*  Class D configuration*/
,{0x0D,0x10,{0x28,0x28,0x3C}} /*  PWM VBINL*/
,{0x0D,0x11,{0x3C,0x3C,0x28}} /*  PWM VBIPL*/
,{0x0D,0x12,{0x28,0x28,0x3C}} /*  PWM VBINR*/
,{0x0D,0x13,{0x3C,0x3C,0x28}} /*  PWM VBIPR*/
,{0x0D,0x1A,{0x0F,0x0F,0x0F}} /*   AD channel Filters configuration*/
,{0x0D,0x1B,{0xE7,0xE7,0xE7}} /*  TDM configuration*/
,{0x0D,0x1C,{0x26,0x26,0x26}} /*  TDM configuration*/
,{0x0D,0x1D,{0x02,0x02,0x02}} /*  TDM loopback control*/
,{0x0D,0x1E,{0x02,0x02,0x02}} /*  TDM 0/1 */
,{0x0D,0x1F,{0xF2,0xF2,0xF2}} /*  TDM audio Interface Slot assignement*/
,{0x0D,0x33,{0x88,0x88,0x88}} /*  slot selection for DA path1*/
,{0x0D,0x34,{0x09,0x09,0x09}} /*  slot selection for DA path 2*/
,{0x0D,0x35,{0x80,0x80,0x80}} /*  slot selection for DA path 3*/
,{0x0D,0x36,{0x00,0x00,0x00}} /*  slot selection for DA path 4*/
,{0x0D,0x37,{0x88,0x88,0x88}} /*  slot selection for DA path 5*/
,{0x0D,0x38,{0x08,0x08,0x08}} /*  slot selection for DA path 6*/
,{0x0D,0x3F,{0xC0,0xC0,0xC0}} /*  Multiplexers  lsb register*/
,{0x0D,0x40,{0xc4,0xc4,0xc4}} /*  multiplexeur msb*/
,{0x03,0x83,{0x2A,0x2A,0x2A}} /*  Vaudio supply */
,{0x0D,0x00,{0x88,0x88,0x88}} /*  Power up */
,{0xFFFF,0 ,{0   ,0   ,0   }}       /* no more Action needed */
};
const Serial_Write_t  DL_mic1b2handsfree[] =
{
/* power down audio alim */
 {0x0D,0x00,{0x00,0x00,0x00}} /*  Power up */
,{0x0D,0x0C,{0x80,0x80,0x80}} /*  Power up for headset /Anaconf5*/
,{0x0D,0x02,{0x20,0x20,0x20}} /*  Digital AD channels enable*/
,{0x0D,0x03,{0x30,0x30,0x30}} /*  Digital DA channels enable*/
,{0x0D,0x04,{0x00,0x00,0x00}} /*  Analog and DMIC*/
,{0x0D,0x05,{0x87,0x87,0x87}} /*  Line In Conf*/
,{0x0D,0x07,{0x84,0x84,0x84}} /*  Analog to Digital Converters enabled */
,{0x0D,0x08,{0x0C,0x0C,0x0C}} /*  Analog output enabled */
,{0x0D,0x09,{0x0C,0x0C,0x0C}} /*  Digital output selection*/
,{0x0D,0x0A,{0x00,0x00,0x00}} /*  Mute enabled*/
,{0x0D,0x0F,{0xFF,0xFF,0xFF}} /*  Class D configuration*/
,{0x0D,0x10,{0x28,0x28,0x3C}} /*  PWM VBINL*/
,{0x0D,0x11,{0x3C,0x3C,0x28}} /*  PWM VBIPL*/
,{0x0D,0x12,{0x28,0x28,0x3C}} /*  PWM VBINR*/
,{0x0D,0x13,{0x3C,0x3C,0x28}} /*  PWM VBIPR*/
,{0x0D,0x1A,{0x0F,0x0F,0x0F}} /*   AD channel Filters configuration*/
,{0x0D,0x1B,{0xE7,0xE7,0xE7}} /*  TDM configuration*/
,{0x0D,0x1C,{0x26,0x26,0x26}} /*  TDM configuration*/
,{0x0D,0x1D,{0x02,0x02,0x02}} /*  TDM loopback control*/
,{0x0D,0x1E,{0x02,0x02,0x02}} /*  TDM 0/1 */
,{0x0D,0x1F,{0xF2,0xF2,0xF2}} /*  TDM audio Interface Slot assignement*/
,{0x0D,0x33,{0x88,0x88,0x88}} /*  slot selection for DA path1*/
,{0x0D,0x34,{0x09,0x09,0x09}} /*  slot selection for DA path 2*/
,{0x0D,0x35,{0x80,0x80,0x80}} /*  slot selection for DA path 3*/
,{0x0D,0x36,{0x00,0x00,0x00}} /*  slot selection for DA path 4*/
,{0x0D,0x37,{0x88,0x88,0x88}} /*  slot selection for DA path 5*/
,{0x0D,0x38,{0x08,0x08,0x08}} /*  slot selection for DA path 6*/
,{0x0D,0x3F,{0xC0,0xC0,0xC0}} /*  Multiplexers  lsb register*/
,{0x0D,0x40,{0xc4,0xc4,0xc4}} /*  multiplexeur msb*/
,{0x03,0x83,{0x2A,0x2A,0x2A}} /*  Vaudio supply */
,{0x0D,0x00,{0x88,0x88,0x88}} /*  Power up */
,{0xFFFF,0 ,{0   ,0   ,0   }}       /* no more Action needed */
};

const Serial_Write_t  DL_Stop[] =
{
/* dflt values*/
{0x0D,0x1D,{0x00,0x00,0x00}} /*  TDM loopback control*/
,{0xFFFF,0 ,{0   ,0   ,0   }}       /* no more Action needed */
};


const Serial_Write_t  Analog_loop[] =
{

/* power down audio alim */
 {0x0D,0x00,{0x00,0x00,0x00}} /*  Power up */
,{0x0D,0x0C,{0x80,0x80,0x80}} /*  Power up for headset /Anaconf5*/
,{0x0D,0x05,{0x30,0x30,0x30}} /*  Line In Conf*/
,{0x0D,0x07,{0x70,0x70,0x70}} /*  Analog to Digital Converters enabled */
,{0x0D,0x08,{0x30,0x30,0x30}} /*  Analog output enabled */
,{0x0D,0x09,{0x00,0x00,0x00}} /*  Digital output selection*/
,{0x0D,0x0A,{0x00,0x00,0x00}} /*  Mute enabled*/
,{0x0D,0x16,{0x40,0xdd,0x22}} /*  Left-Lin-ln plus Left analog gain */
,{0x0D,0x17,{0x40,0x55,0x55}} /*  Right-Lin-ln plus Right  analog gain */
,{0x0D,0x18,{0x00,0x00,0x00}} /*  Li-in L to headset loop gain*/
,{0x0D,0x19,{0x00,0x00,0x00}} /*  Li-in R to headset loop gain*/
,{0x0D,0x4F,{0x18,0x18,0x18}} /*  Output drivers digital gains HSL*/
,{0x0D,0x50,{0x18,0x18,0x18}} /*  Output drivers digital gains HSR*/
,{0x03,0x83,{0x2A,0x2A,0x2A}} /*  Vaudio supply */
,{0x0D,0x00,{0x88,0x88,0x88}} /*  Power up */
,{0xFFFF,0 ,{0   ,0   ,0   }} /* no more Action needed */
};

const Serial_Write_t  AL_Stop[] =
{
/* dflt values*/
{0x0D,0x07,{0x00,0x00,0x00}} 		/*  Analog to Digital Converters enabled*/
,{0xFFFF,0 ,{0   ,0   ,0   }}       /* no more Action needed */
};
/* -CAP_352_001 */
const Serial_Write_t*  Digital_loop_configs[NB_OF_OUTPUT][NB_OF_INPUT] =
{
  /* HEADSET */
  {
    DL_LinLRheadset/* LINLR */
    ,DL_mic1b2headset /* MIC1B */
    ,DL_mic2headset /* MIC2 */
    ,DL_Dmic12headset/* DMIC12*/
    ,DL_Dmic34headset/* DMIC34*/
    ,DL_Dmic56headset/* DMIC56*/
    ,NULL 					/* MIC1A */
  }
  /* HANDSET*/
  ,{
    NULL /* LINLR */
    ,DL_mic1b2earpiece /* MIC1B */
    ,NULL /* MIC2 */
    ,NULL /* DMIC12*/
    ,NULL /* DMIC34*/
    ,NULL /* DMIC56*/
    ,DL_mic1a2earpiece/* MIC1A */
  }
  /* HANDSFREE*/
  ,{
   NULL /* LINLR */
   ,DL_mic1b2handsfree /* MIC1B */
   ,NULL /* MIC2 */
   ,NULL /* DMIC12*/
   ,NULL /* DMIC34*/
   ,NULL /* DMIC56*/
   ,DL_mic1a2handsfree/* MIC1A */
  }
};

extern unsigned char SPIRead( unsigned short  register_address);
extern void SPIWrite( unsigned short register_address, unsigned char data );
/************************************************************************************************/
/* static data definitions */
/************************************************************************************************/
hats_audio_4500_loop Cur_Loop = HATS_STW4500_LOOP_OFF;
e_HatsAudioInput_t Cur_In_Organ = CODEC_SRC_D_MICROPHONE_12;
e_HatsAudioOutput_t Cur_Out_Organ = CODEC_DEST_HEADSET;

/************************************************************************************************/
/* Write4500reg function*/
/************************************************************************************************/
uint8_t Write4500reg(uint8_t bank,uint8_t address,uint8_t data)
{
  SPIWrite( ((bank<<8)|(address& 0xFF)), data );
  return HATS_AUDIO_NO_ERROR;
}
/************************************************************************************************/
/* Read4500reg function*/
/************************************************************************************************/
uint8_t Read4500reg(uint8_t bank,uint8_t address,uint8_t* p_data)
{
  
  *p_data = SPIRead((bank<<8)|(address& 0xFF));
  
  return HATS_AUDIO_NO_ERROR;
}

/************************************************************************************************/
/* run_config function*/
/************************************************************************************************/
void run_config (const Serial_Write_t* p_config)
{
uint8_t data = 0;
AB8500_version version;
   /* detect 4500V1 version*/
   version = Get_AB8500_Version();
   if(version == AB8500_VER_UNDEFINED)
   {
     	printf("ERROR:Unknown AB8500 version!!!!\n");
			return;
   }
/* 
   else if (version == AB8500_VER_V1)
   {
     printf("4500 V1 detected\n");
   }
   else
   {
     printf("4500 ED detected\n");
   }
*/
  if(p_config)
  {
      /* Run config scenario */
      while(p_config->bloc_addr != 0xFFFF)
      {
        Write4500reg (p_config->bloc_addr, p_config->reg_addr, p_config->data[version]);
        Read4500reg (p_config->bloc_addr, p_config->reg_addr,&data);
        if (data !=p_config->data[version])
        {
           printf("Data write: bank 0x%x register 0x%x value 0x%x\n", p_config->bloc_addr, p_config->reg_addr, p_config->data[version]);
           printf("Data Read: value 0x%x\n", data);
        }
        p_config++;
      }
  }
}

/************************************************************************************************/
/* audioloop function*/
/************************************************************************************************/
int stw400audioloop (hats_audio_4500_loop action)
{
  int result = PASS;
	uint8_t data,data0;
	uint8_t error1,error2;
   AB8500_version version;
 
  /*********************************************************************/
  /* no loop => reset audio registers */
  /*********************************************************************/
  if(action == HATS_STW4500_LOOP_OFF)
  {
  	// Reset audio part
  	/*error1 = Read4500reg(BLOC_4500_AUDIO, 0x01, &data0);
  	data = (data0 | 0x80);
  	error2 = Write4500reg(BLOC_4500_AUDIO, 0x01, data);

  	error1 = Read4500reg(0x02, 0x00, &data0);
    data = (data0 & 0xFE);
  	error2 = Write4500reg(0x02, 0x00, data);*/
	
	if(action == HATS_STW4500_ANALOGLOOP)
	{
		run_config(AL_Stop);
	}
	else
	{
		run_config(DL_Stop);
	}
	Cur_Loop =  HATS_STW4500_LOOP_OFF; 	
	}
  else
  {
  	// ResetAudn
  	/*error1 = Read4500reg(0x02, 0x00, &data0);
  	
    data = (data0 & 0xFE);
  	error2 = Write4500reg(0x02, 0x00, data);
  	
    data = (data0 | 0x02);
  	error2 = Write4500reg(0x02, 0x00, data);
	*/
  	// Reset audio part
  	/*rror1 = Read4500reg(BLOC_4500_AUDIO, 0x01, &data0);
  	data = (data0 | 0x80);
  	error2 = Write4500reg(BLOC_4500_AUDIO, 0x01, data);
	*/
  	// AudioClk Enable
  	error1 = Read4500reg   (bloc_4500_System_Control_2, 0x0B, &data0);
  	data = (data0 | 0x18);
  	error2 = Write4500reg   (bloc_4500_System_Control_2, 0x0B, data);

  	// Dmics Clk GPIO in output 
   version = Get_AB8500_Version();
 
   if (version == AB8500_VER_V1)
   {
  	error1 = Read4500reg   (0x10, 0x13, &data0);
  	data = (data0 | 0x54);
  	error2 = Write4500reg   (0x10, 0x13, data);
 	 }
  	// Vintcore12
  	error1 = Read4500reg   (0x03, 0x80, &data0);
  	data = (data0 | 0x04);
  	error2 = Write4500reg   (0x03, 0x80, data);
 
  	// Vaudio Enable
  	error1 = Read4500reg   (bloc_4500_Supply_Control_1, 0x83, &data0);
  	data = (data0 | 0x42);
  	error2 = Write4500reg   (bloc_4500_Supply_Control_1, 0x83, data);
    /*********************************************************************/
    /* 4500 digital loop */
    /*********************************************************************/
    if(action == HATS_STW4500_ANALOGLOOP)
    {
      run_config(Analog_loop);
      Cur_Loop =  HATS_STW4500_ANALOGLOOP; 
    }
    /*********************************************************************/
    /* digital loop */
    /*********************************************************************/
    else if(action == HATS_STW4500_DIGITALLOOP)
    {

      if(  (Cur_Out_Organ <NB_OF_OUTPUT) && (Cur_In_Organ <NB_OF_INPUT)
         &&(Digital_loop_configs[Cur_Out_Organ][Cur_In_Organ] != NULL))
      {
		run_config(Digital_loop_configs[Cur_Out_Organ][Cur_In_Organ] );
 
        printf(" run config IN: %x/OUT: %x\n",Cur_In_Organ,Cur_Out_Organ);
      }
      else
      {
        /* error */
        printf(" config IN: %x/OUT: %x not supported => select another IN or/and OUT\n",Cur_In_Organ,Cur_Out_Organ);
        result = FAIL;
      }
      Cur_Loop =  HATS_STW4500_DIGITALLOOP; 
    }
    else
    {
      /* error */
      result = HATS_AUDIO_INVALID_PARAMETER;
      printf(" BAD VERSION\n");
  
    }
  }
  
  return result;

}
/************************************************************************************************/
/* audioloop function*/
/************************************************************************************************/
int stw400audioloop_setSource (e_HatsAudioInput_t In_Organ)
{
  int result = PASS;
 
  Cur_In_Organ = In_Organ;
  if(Cur_Loop != HATS_STW4500_LOOP_OFF)
  {
   printf(" change organ\n");
   result =  stw400audioloop(Cur_Loop);
  }
  return result;
  
}
int stw400audioloop_setSink (e_HatsAudioOutput_t Out_Organ)
{
  int result = PASS;

  Cur_Out_Organ = Out_Organ;
  if(Cur_Loop != HATS_STW4500_LOOP_OFF)
  {
    result = stw400audioloop(Cur_Loop);
  }
  return result;
}
/* CAP_1596_001 */
/************************************************************************************************/
/* audioloop function*/
/************************************************************************************************/
AB8500_version Get_AB8500_Version(void)
{
   AB8500_version version = AB8500_VER_UNDEFINED;
  uint8_t data;
	
  Read4500reg (0x10, 0x80,&data);
  switch(data & 0xF0)
  {
      case 0x00:
        version = AB8500_VER_ED;
        break;
        
      case 0x10:
        version = AB8500_VER_V1;
        break;
      case 0x20:
      default:
        version = AB8500_VER_V2;
        break;
  }
	return version;
}
/* end CAP_1596_001 */

