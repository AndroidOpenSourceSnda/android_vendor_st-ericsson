/*
 * Copyright (C) ST-Ericsson SA 2010. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 */
 
/*!
 * \brief C++ component abstract definition
 */

#ifndef NMF_CPP_H_
#define NMF_CPP_H_

#include <inc/typedef.h>
#include <inc/nmf_type.idt>

/*
 * \internal
 */
namespace NMF {

/*!
 * \brief C++ Primitive component abstract class
 *
 * This class is extended by each primitive template class generated by NMF tools according your ADL description.
 */
class Primitive {
public:
    /*!
     * \brief This mutex allow to prevent parallel scheduling on multiple core.
     *
     * \warning This variable is used internally, you must not use it.
     */
    t_uint32 mutexHandle;

    /*!
     * \brief ADL declaration name
     *
     * Debug information containing the ADL declaration name of the component.
     */
    const char * name;


    /*!
     * \brief ADL template name
     *
     * Debug information containing the ADL template name of the component.
     */
    const char* templateName;

    /*!
     * \brief Component state
     *
     * State of the component, for proper lifecycle management (see stop_flush()).
     */
    enum {STATE_DEFAULT = 1, STATE_STOPPED_WAIT_FLUSH = 2} nmfState;

public:
    Primitive(const char* _templateName): name("unknown"), templateName(_templateName)
    {
        mutexHandle = 0;
        nmfState = STATE_DEFAULT;
    }

    virtual ~Primitive()
    {
        // Nothing To do, just to keep GCC happy that trig warning while its not necessary
    }
};

/*!
 * \brief C++ Interface descriptor abstract class
 *
 * This class is extended by each C++ interface class generated by NMF tools according your IDL description.
 */
class InterfaceDescriptor {
public:
    virtual ~InterfaceDescriptor()
    {
        // Nothing To do, just to keep GCC happy that trig warning while its not necessary
    }
};

/*!
 * \brief C++ Interface reference abstract class
 *
 * This class is extended by each C++ interface reference class generated by NMF tools according your IDL description.
 */
class InterfaceReference {
protected:
    /*!
     * \brief Target reference
     *
     * \warning This method is used internally, you must not use it.
     */
    NMF::InterfaceDescriptor* reference;

public:
  InterfaceReference(NMF::InterfaceDescriptor* _reference):
      reference(_reference) {}

public:
    /*!
     * \brief Get targeted interface
     *
     * \warning This method is used internally, you must not use it.
     */
    NMF::InterfaceDescriptor* getReference() {
      return reference;
    }

    /*!
     * \brief Test if a interface reference is really bind.
     */
    bool IsNullInterface() {
      return reference == 0x0;
    }
};

/*!
 * \brief C++ composite abstract class
 */
class Composite {
protected:
    /*!
     * \brief Internal method for comparing two null terminated string.
     */
    virtual int compositeStrcmp(const char* str1, const char* str2)
    {
        signed char res;

        while (1) {if ((res = *str1 - *str2++) != 0 || !*str1++) break;}
        return res;
    }
    /*!
     * \brief Internal method for copying null terminated string.
     */
    virtual void compositeCpycmp(char* dest, const char *src, int count)
    {
        while (count-- && (*dest++ = *src++) != '\0')
          /* nothing */;
    }

    virtual ~Composite()
    {
        // Nothing To do, just to keep GCC happy that trig warning while its not necessary
    }

public:
    /*!
     * \brief Construct a composite network
     *
     * Instantiate a new composite network.
     */
    virtual t_nmf_error construct(void) = 0;

    /*!
     * \brief Start a composite network
     *
     * Start a component which has been fully configured and which has all required
     * interfaces binded.
     *
     * \note Start/stop is recursive, thus you can start multiple time same component, but you
     * have to stop same number of time.
     */
    virtual void start(void) = 0;

    /*!
     * \brief Stop a composite network
     *
     * Stop a component previously started using \ref start.
     *
     * \note Start/stop is recursive, thus you can start multiple time same component, but you
     * have to stop same number of time.
     */
    virtual void stop(void) = 0;

    /*!
     * \brief Stop a composite network and flush all pending messages.
     *
     * Stop a component previously started using \ref start and flush all pending messages.
     *
     * \note Start/stop is recursive, thus you can start multiple time same component, but you
     * have to stop same number of time.
     */
    virtual void stop_flush(void) = 0;

    /*!
     * \brief Destroy a composite network
     *
     * Destroy a previously instanciated component with \ref construct
     * by freeing memories allocated for component instance. This component must been
     * previously stopped using \ref stop.
     */
    virtual t_nmf_error destroy(void) = 0;

public:
    /*!
     * \brief Bind synchronously the Host to the component
     *
     * Create a synchronous binding between the User and the server component.
     *
     * \note Either synchronous (with at least one method returning parameter) or asynchronous interface could be return by such method.
     *
     * \warning Using the interface descriptor reference returned by this method break the execution model
     *          by making synchronous call which could be reentrant. Thus use this method with many precaution
     *          for example only with state-less library.
     *
     * \exception   NMF_NO_SUCH_PROVIDED_INTERFACE
     */
    virtual t_nmf_error getInterface(
            const char              *name,          //!< [in] The server provided interface name (either collection or not collection name allowed).
            NMF::InterfaceReference *reference      //!< [out] The interface descriptor reference
            ) = 0;


public:
    /*!
     * \brief Bind asynchronously the User to the component
     *
     * Create a asynchronous binding between the User and the server component.
     *
     * \exception   NMF_NO_SUCH_PROVIDED_INTERFACE
     * \exception   NMF_NO_MORE_MEMORY
     */
    virtual t_nmf_error bindFromUser(
            const char              *name,          //!< [in] The server provided interface name (either collection or not collection name allowed).
            unsigned int            size,           //!< [in] The number of element in the event fifo (number of simultaneously waiting request)
            NMF::InterfaceReference *reference,     //!< [out] The interface descriptor reference
            unsigned int            subpriority = 0 //!< [in] The sub-priority belonging the priority of the target component
            ) = 0;

    /*!
     * \brief Unbind asynchronously the User to the component
     *
     * Destroy a asynchronous binding between the User and the server component.
     *
     * \exception   NMF_NO_SUCH_PROVIDED_INTERFACE
     * \exception   NMF_INTERFACE_NOT_BINDED
     */
    virtual t_nmf_error unbindFromUser(
            const char              *name           //!< [in] The server provided interface name (either collection or not collection name allowed).
            ) = 0;

    /*!
     * \brief Bind asynchronously the component to the User
     *
     * Create a asynchronous binding between client component and the User.
     *
     * \exception   NMF_NO_SUCH_REQUIRED_INTERFACE
     * \exception   NMF_NO_MORE_MEMORY
     * \exception   NMF_INTERFACE_ALREADY_BINDED
     */
    virtual t_nmf_error bindToUser(
            t_nmf_channel           channel,            //!< [in] The channel where the user will retrieve callback to execute.
            const char              *compositeitfname,  //!< [in] The client required interface name (either collection or not collection name allowed).
            void                    *clientContext,     //!< [in] The client context that will be given back to user when calling EE_GetMessage()
            unsigned int            size                //!< [in] The number of element in the event fifo (number of simultaneously waiting request)
            ) = 0;

    /*!
     * \brief Unbind asynchronously the component to the User
     *
     * Destroy a asynchronous binding between client component and the User.
     *
     * \exception   NMF_NO_SUCH_REQUIRED_INTERFACE
     * \exception   NMF_INTERFACE_NOT_BINDED
     */
    virtual t_nmf_error unbindToUser(
            t_nmf_channel           channel,            //!< [in] The channel where the user will retrieve callback to execute.
            const char              *compositeitfname,  //!< [in] The client required interface name (either collection or not collection name allowed).
            void                    **pClientContext    //!< [in] A reference where returning the client context gived during bind
            ) = 0;

    /*!
     * \brief Bind asynchronously two components together
     *
     * Bind a required interface of a client component with a provided interface
     * of a server component via a asynchronous binding.
     *
     * \warning In order to save memory, we are not embedding description about interface type, thus we are not able to detect
     *          mismatch of interface types during binding.
     *
     * \exception   NMF_NO_SUCH_REQUIRED_INTERFACE
     * \exception   NMF_NO_SUCH_PROVIDED_INTERFACE
     * \exception   NMF_NO_MORE_MEMORY
     * \exception   NMF_INTERFACE_ALREADY_BINDED
     */
    virtual t_nmf_error bindAsynchronous(
            const char              * name,         //!< [in] The client required interface name (either collection or not collection name allowed).
            unsigned int            size,           //!< [in] The number of element in the event fifo (number of simultaneously waiting request).
            NMF::Composite          *target,        //!< [in] The server component instance handle.
            const char              *targetname,    //!< [in] The server provided interface name (either collection or not collection name allowed).
            unsigned int            subpriority = 0 //!< [in] The sub-priority belonging the priority of the target component
            ) = 0;

    /*!
     * \brief Unbind asynchronously two components together
     *
     * Unbind a required interface of a client component with a provided interface
     * of a server component via a asynchronous binding.
     *
     * \exception   NMF_NO_SUCH_REQUIRED_INTERFACE
     * \exception   NMF_NO_SUCH_PROVIDED_INTERFACE
     * \exception   NMF_INTERFACE_NOT_BINDED
     */
    virtual t_nmf_error unbindAsynchronous(
            const char              *name,          //!< [in] The client required interface name (either collection or not collection name allowed).
            NMF::Composite          *target,        //!< [in] The server component instance handle.
            const char              *targetname     //!< [in] The server provided interface name (either collection or not collection name allowed).
            ) = 0;

    /*!
     * \brief Bind synchronously two components together
     *
     * Bind a required interface of this client component with a provided interface
     * of a server component.
     *
     * \note Either synchronous (with at least one method returning parameter) or asynchronous interface could be bind by such method.
     *
     * \warning Creating such binding break the execution model by making synchronous call which could be reentrant.
     *          Thus use this method with many precaution for example only with state-less server library.
     *
     * \warning In order to save memory, we are not embedding description about interface type, thus we are not able to detect
     *          mismatch of interface types during binding.
     *
     * \exception   NMF_NO_SUCH_REQUIRED_INTERFACE
     * \exception   NMF_NO_SUCH_PROVIDED_INTERFACE
     * \exception   NMF_INTERFACE_ALREADY_BINDED
     */
    virtual t_nmf_error bindComponent(
            const char              *name,          //!< [in] The client required interface name (either collection or not collection name allowed).
            NMF::Composite          *target,        //!< [in] The server component instance handle.
            const char              *targetname     //!< [in] The server provided interface name (either collection or not collection name allowed).
            ) = 0;

    /*!
     * \brief Unbind synchronously two components together
     *
     * Unbind a required interface of this client component with a provided interface
     * of a server component.
     *
     * \exception   NMF_NO_SUCH_REQUIRED_INTERFACE
     * \exception   NMF_NO_SUCH_PROVIDED_INTERFACE
     * \exception   NMF_INTERFACE_NOT_BINDED
     */
    virtual t_nmf_error unbindComponent(
            const char              *name,          //!< [in] The client required interface name (either collection or not collection name allowed).
            NMF::Composite          *target,        //!< [in] The server component instance handle.
            const char              *targetname     //!< [in] The server provided interface name (either collection or not collection name allowed).
            ) = 0;

    /*!
     * \brief Read a value on an attribute exported by a component instance.
     *
     * This attribute must have been declared as an attribute in the component configuration
     * file.
     *
     * \exception NMF_NO_SUCH_ATTRIBUTE
     */
    virtual t_nmf_error readAttribute(
            const char              *name,          //!< [in] The component attribute path-name (sub-component's/attribute)
            t_uint32                *value          //!< [out] Read value
            )  = 0;

    /*!
     * \brief Get a component property declared in ADL.
     *
     * \exception NMF_NO_SUCH_PROPERTY
     */
    virtual t_nmf_error getProperty(
            const char              *name,          //!< [in] The component property path-name (sub-component's/attribute)
            char                    *value,         //!< [out] Address where putting property value
            t_uint32                valuelen        //!< [in] value length
            )  = 0;

    /*!
     * \brief Get a component instance of a component instantiate on MPC.
     *
     * This method allow you to get a component instance of a component instantiate automatically by
     * this composite. This reference could be used to create sub-binding (like tunneling) with other MPC
     * components (either obtain by this method on other composite or directly instantiate using
     * Component Manager.
     *
     * \note Potential created sub-binding must be unbound before destroying the composite.
     *
     * \return NULL if component not exist or if not instantiate, elsewhere return the component handle
     */
    virtual t_nmf_component_handle getMPCComponentHandle(
            const char *nameinowner                 //!< [in] MMDSP component name inside this composite component.
            ) = 0;

    virtual t_nmf_component_handle getComponentInterface(
            const char *compositeitfname,                 //!< [in] MMDSP component name inside this composite component.
            char       *realitfname
            ) = 0;

    /*!
     * \brief Bind a composite sub-component (ARM or MPC) from a MPC component deployed through CM API.
     */
    virtual t_nmf_error bindFromMPC(
            t_nmf_component_handle  client,             //!< [in] Client MPC component handle
            const char*             clientitfname,      //!< [in] Client MPC component require interface name
            const char              *compositeitfname,  //!< [in] The server provided interface name (either collection or not collection name allowed).
            unsigned int            size                //!< [in] The number of element in the event fifo (number of simultaneously waiting request).
            ) = 0;

    /*!
     * \brief Unbind a composite sub-component (ARM or MPC) from a MPC component deployed through CM API.
     */
    virtual t_nmf_error unbindFromMPC(
            t_nmf_component_handle  client,             //!< [in] Client MPC component handle
            const char*             clientitfname,      //!< [in] Client MPC component require interface name
            const char              *compositeitfname   //!< [in] The server provided interface name (either collection or not collection name allowed).
            ) = 0;

    /*!
     * \brief Bind a composite sub-component (ARM or MPC) to a MPC component deployed through CM API.
     */
    virtual t_nmf_error bindToMPC(
            const char              *compositeitfname,  //!< [in] The client required interface name (either collection or not collection name allowed).
            t_nmf_component_handle  server,             //!< [in] Server MPC component handle
            const char*             serveritfname,      //!< [in] Server MPC component provided interface name
            unsigned int            size                //!< [in] The number of element in the event fifo (number of simultaneously waiting request).
            ) = 0;

    /*!
     * \brief Bind a composite sub-component (ARM or MPC) to a MPC component deployed through CM API.
     */
    virtual t_nmf_error unbindToMPC(
            const char              *compositeitfname,  //!< [in] The client required interface name (either collection or not collection name allowed).
            t_nmf_component_handle  server,             //!< [in] Server MPC component handle
            const char*             serveritfname       //!< [in] Server MPC component provided interface name
            ) = 0;

};

/*!
 * \brief C++ composite abstract class
 */
class Component {
protected:
    /*!
     * \brief Internal method for comparing two null terminated string.
     */
    virtual int compositeStrcmp(const char* str1, const char* str2)
    {
        signed char res;

        while (1) {if ((res = *str1 - *str2++) != 0 || !*str1++) break;}
        return res;
    }

    virtual ~Component()
    {
        // Nothing To do, just to keep GCC happy that trig warning while its not necessary
    }

public:
    /*!
     * \brief Construct a composite network
     */
    virtual t_nmf_error construct(void) = 0;

    /*!
     * \brief Start a composite network
     */
    virtual void start(void) = 0;

    /*!
     * \brief Stop a composite network
     */
    virtual void stop(void) = 0;

    /*!
     * \brief Destroy a composite network
     */
    virtual t_nmf_error destroy(void) = 0;

public:
    /*!
     * \brief Get interface reference
     * \exception   NMF_NO_SUCH_PROVIDED_INTERFACE
     */
    virtual t_nmf_error getInterface(
            const char              *name,          //!< [in] The server provided interface name (either collection or not collection name allowed).
            NMF::InterfaceReference *reference      //!< [out] The interface descriptor reference
            ) = 0;

   /*!
     * \brief Bind synchronously two components together
     * \exception   NMF_NO_SUCH_REQUIRED_INTERFACE
     */
    virtual t_nmf_error bindComponent(
            const char              *name,          //!< [in] The client required interface name (either collection or not collection name allowed)
            NMF::Component          *target,        //!< [in] The server component instance handle
            const char              *targetname     //!< [in] The server provided interface name (either collection or not collection name allowed)
            ) = 0;

    /*!
     * \brief Unbind synchronously two components together
     * \exception   NMF_NO_SUCH_REQUIRED_INTERFACE
     */
    virtual t_nmf_error unbindComponent(
            const char              *name           //!< [in] The client required interface name (either collection or not collection name allowed).
            ) = 0;
};

}

/*!
 * \brief C++ macro for testing if a optional required interface is bound.
 */
#define IS_NULL_INTERFACE(itf, meth) (itf.IsNullInterface())

#endif /* NMF_CPP_H_ */
