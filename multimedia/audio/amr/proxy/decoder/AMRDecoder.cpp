/*****************************************************************************/
/**
*  © ST-Ericsson, 2009 - All rights reserved

*  Reproduction and Communication of this document is strictly prohibited
*  unless specifically authorized in writing by ST-Ericsson
*
* \brief   AMR Decoder proxy
* \author  ST-Ericsson
*/
/*****************************************************************************/
#include "AMRDecoder.h"
#include "AMRDec_BitstreamPort.h"
#ifndef HOST_ONLY
#include "AMRNmfMpc_Decoder.h"
#endif
#include "AMRNmfHost_Decoder.h"
#include "AMRDec_PcmPort.h"

// UID top dictionnary (generated by trace compiler)
#include "AMR_DEC_top.h"
#include "AMR_HOST_DEC_top.h"

#include "OMX_Symbian_ExtensionNames_Ste.h"
#include "audio_chipset_api_index.h"
#include "audio_codecs_chipset_api.h"

// TODO FIXME: manage buffers that are not 32-bit multiple  (for Host proxy only)
#define SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES 4 

AMRDecoder_RDB::AMRDecoder_RDB(OMX_U32 nbOfDomains) 
	: ENS_ResourcesDB(nbOfDomains)
{
    setNbOfMemoryPresets(5);
    setMemoryPreset(1); // ALL_DDR
    for (unsigned int i=0;i<nbOfDomains;i++) {
        setDefaultNMFDomainType(RM_NMFD_PROCSIA,i);
    }
}


OMX_ERRORTYPE AMRDecoder::createResourcesDB() {
    mRMP = new AMRDecoder_RDB(getPortCount());
    if (mRMP == 0) {
        return OMX_ErrorInsufficientResources;
    } 
    else {
        return OMX_ErrorNone;
    }
}

OMX_ERRORTYPE amrhostdecFactoryMethod(ENS_Component_p * ppENSComponent) {
    OMX_ERRORTYPE error  = OMX_ErrorNone;

    AMRDecoder *amrdec = new AMRDecoder(true);
    if (amrdec == 0) {
        return OMX_ErrorInsufficientResources;
    }

    error = amrdec->construct();

    if (error != OMX_ErrorNone) {
        delete amrdec;
        *ppENSComponent = 0;
        return OMX_ErrorInsufficientResources;
    } else {
        *ppENSComponent = amrdec;
    }

    AMRNmfHost_Decoder *amrdec_ProcessingComp = new AMRNmfHost_Decoder(*amrdec);

    if (amrdec_ProcessingComp == 0) {
        delete amrdec;
        return OMX_ErrorInsufficientResources;
    }

    amrdec->setProcessingComponent(amrdec_ProcessingComp);

    return error;
}

#ifndef HOST_ONLY
OMX_ERRORTYPE amrdecFactoryMethod(ENS_Component_p * ppENSComponent) {
    OMX_ERRORTYPE error  = OMX_ErrorNone;

    AMRDecoder *amrdec = new AMRDecoder(false);
    if (amrdec == 0) {
        return OMX_ErrorInsufficientResources;
    }

    error = amrdec->construct();

    if (error != OMX_ErrorNone) {
        delete amrdec;
        *ppENSComponent = 0;
        return OMX_ErrorInsufficientResources;
    } else {
        *ppENSComponent = amrdec;
    }

    AMRNmfMpc_Decoder *amrdec_ProcessingComp = new AMRNmfMpc_Decoder(*amrdec);

    if (amrdec_ProcessingComp == 0) {
        delete amrdec;
        return OMX_ErrorInsufficientResources;
    }

    amrdec->setProcessingComponent(amrdec_ProcessingComp);

    return error;
}
#endif /* HOST_ONLY */

OMX_ERRORTYPE AMRDecoder::createAMRDecBitstreamPort(const OMX_AUDIO_PARAM_AMRTYPE &defaultAmrSettings)
{
    OMX_U32 supported_length =	getMaxFrameSize()/8;

    if (mIsHost) {
        supported_length += (SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES - 1);
        supported_length &= ~(SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES - 1);
    }

    AMRDec_BitstreamPort *amrPort = 
        new AMRDec_BitstreamPort(0, OMX_DirInput, supported_length, defaultAmrSettings, mIsHost, *this); 

    if (amrPort == 0) {
        return OMX_ErrorInsufficientResources;
    }

    addPort(amrPort);

    return OMX_ErrorNone;
}

OMX_ERRORTYPE  AMRDecoder::construct()
{
    OMX_ERRORTYPE error;
    OMX_AUDIO_PARAM_PCMMODETYPE defaultPcmSettings;
    OMX_AUDIO_PARAM_AMRTYPE defaultAmrSettings;

    defaultPcmSettings.nPortIndex     = 1;
    defaultPcmSettings.eNumData       = OMX_NumericalDataSigned;
    defaultPcmSettings.eEndian        = OMX_EndianLittle;
    defaultPcmSettings.bInterleaved   = OMX_TRUE;
    defaultPcmSettings.ePCMMode       = OMX_AUDIO_PCMModeLinear;
    defaultPcmSettings.nBitPerSample  = 16;

    defaultPcmSettings.nChannels      = 1;
    defaultPcmSettings.nSamplingRate  = 8000;

    defaultPcmSettings.eChannelMapping[0] = OMX_AUDIO_ChannelCF;

    defaultAmrSettings.nSize           = sizeof(OMX_AUDIO_PARAM_AMRTYPE);
    getOmxIlSpecVersion(&defaultAmrSettings.nVersion);
    defaultAmrSettings.nPortIndex      = 0;
    defaultAmrSettings.nChannels       = 1;
    defaultAmrSettings.nBitRate        = 0;
    defaultAmrSettings.eAMRBandMode    = OMX_AUDIO_AMRBandModeNB0;
    defaultAmrSettings.eAMRDTXMode     = OMX_AUDIO_AMRDTXModeOnVAD1;
#ifdef FORCE_RTP_WHEN_FSF
    defaultAmrSettings.eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatRTPPayload;
#else
    defaultAmrSettings.eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;
#endif

    error = AFM_Decoder::construct(
            OMX_AUDIO_CodingAMR, getSampleFrameSize(), defaultPcmSettings);
    if (error != OMX_ErrorNone) return error;

    ENS_String<20> role = "audio_decoder.amrnb";
    role.put((OMX_STRING)mRoles[0]);
    setActiveRole(mRoles[0]);

    error = createAMRDecBitstreamPort(defaultAmrSettings);
    if (error != OMX_ErrorNone) return error;

    return OMX_ErrorNone;
}

OMX_ERRORTYPE AMRDecoder::getExtensionIndex(OMX_STRING cParameterName,
						     OMX_INDEXTYPE* pIndexType) const
{
    if (ENS_String<ENS_COMPONENT_NAME_MAX_LENGTH>(cParameterName) 
            == OMX_SYMBIAN_INDEX_CONFIG_AUDIO_AMRMODE_NAME) {
        *pIndexType = (OMX_INDEXTYPE)OMX_IndexConfigAudioAmrMode;
        return OMX_ErrorNone;
    }

    return AFM_Component::getExtensionIndex(cParameterName, pIndexType);
}

OMX_ERRORTYPE AMRDecoder::createPcmPort(
        OMX_U32 nIndex,
        OMX_DIRTYPE eDir,
        OMX_U32 nBufferSizeMin,
        const OMX_AUDIO_PARAM_PCMMODETYPE &defaultPcmSettings)
{
    ENS_Port * port = new AMRDec_PcmPort(
                nIndex, eDir, nBufferSizeMin, defaultPcmSettings, mIsHost, *this);
    if (port == 0) {
        return OMX_ErrorInsufficientResources;
    }

    addPort(port);

    return OMX_ErrorNone;
}


OMX_U32 AMRDecoder::getUidTopDictionnary(void)
{
    if (mIsHost){
        return KOstAMR_HOST_DEC_top_ID;
    }
    else{
        return KOstAMR_DEC_top_ID;
    }
}

OMX_ERRORTYPE AMRDecoder::setConfig(
        OMX_INDEXTYPE nConfigIndex,
        OMX_PTR pComponentConfigStructure)
{
    switch (nConfigIndex) {
        case OMX_IndexConfigAudioAmrMode:
            {
                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_AUDIO_CONFIG_AMRMODETYPE);
                OMX_AUDIO_CONFIG_AMRMODETYPE *amrConfig =
                    (OMX_AUDIO_CONFIG_AMRMODETYPE *)pComponentConfigStructure;
                AMRDec_BitstreamPort * BSPort;

                if (amrConfig->nPortIndex != 1){
                    return OMX_ErrorBadParameter;
                }

                BSPort = static_cast<AMRDec_BitstreamPort *>(getPort(0));
                return BSPort->setBitRate(amrConfig->eAMRBandMode);
            }

        default:
            return AFM_Decoder::setConfig(
                    nConfigIndex, pComponentConfigStructure);
    }
}


OMX_ERRORTYPE AMRDecoder::getConfig(
        OMX_INDEXTYPE nConfigIndex,
        OMX_PTR pComponentConfigStructure) const
{
    OMX_ERRORTYPE error;
    switch (nConfigIndex) {
        case OMX_IndexConfigAudioAmrMode:
            {
                const AMRDec_BitstreamPort * BSPort = static_cast<const AMRDec_BitstreamPort *>(getPort(1));
                OMX_AUDIO_PARAM_AMRTYPE amrOmxParams;
                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_AUDIO_CONFIG_AMRMODETYPE);
                OMX_AUDIO_CONFIG_AMRMODETYPE *amrConfig =
                    (OMX_AUDIO_CONFIG_AMRMODETYPE *)pComponentConfigStructure;

                if (amrConfig->nPortIndex != 1){
                    return OMX_ErrorBadParameter;
                }

                amrOmxParams.nSize           = sizeof(OMX_AUDIO_PARAM_AMRTYPE);
                getOmxIlSpecVersion(&amrOmxParams.nVersion);

                error = BSPort->getParameter(OMX_IndexParamAudioAmr, &amrOmxParams);
                if (error != OMX_ErrorNone) return error;

                amrConfig->eAMRBandMode = amrOmxParams.eAMRBandMode;

                return OMX_ErrorNone;
            }

        default:
            return AFM_Decoder::getConfig(
                    nConfigIndex, pComponentConfigStructure);
    }
}

