/*
 * Copyright (C) ST-Ericsson SA 2010. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 */

#include "GSMFRDecoder.h"
#include "GSMFRDec_BitStreamPort.h"
#include "GSMFRNmfHost_Decoder.h"
#include "GSMFRDec_PcmPort.h"

// UID top dictionnary (generated by trace compiler)
#include "GSMFR_HOST_DEC_top.h"

// TODO FIXME: manage buffers that are not 32-bit multiple  (for Host proxy only)
#define SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES 4 


OMX_ERRORTYPE gsmfrhostdecFactoryMethod(ENS_Component_p * ppENSComponent) {
	OMX_ERRORTYPE error  = OMX_ErrorNone;

	GSMFRDecoder *gsmfrdec = new GSMFRDecoder(true);
	if (gsmfrdec == 0) {
		return OMX_ErrorInsufficientResources;
	}
	error = gsmfrdec->construct();
	if(error != OMX_ErrorNone){
		delete gsmfrdec;
		*ppENSComponent = 0;
        return OMX_ErrorInsufficientResources;
	}else{    
		*ppENSComponent = gsmfrdec;
	}

    GSMFRNmfHost_Decoder *gsmfrdec_ProcessingComp = new GSMFRNmfHost_Decoder(*gsmfrdec);

    if (gsmfrdec_ProcessingComp == 0) {
        delete gsmfrdec;
        return OMX_ErrorInsufficientResources;
    }

    gsmfrdec->setProcessingComponent(gsmfrdec_ProcessingComp);
	return error;
}



OMX_ERRORTYPE GSMFRDecoder::createGSMFRBitstreamPort(const OMX_AUDIO_PARAM_GSMFRTYPE &defaultGsmfrSettings) 
{
  OMX_U32 supported_length = getMaxFrameSize()/8;
  if (mIsHost) {
    supported_length += (SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES - 1);
    supported_length &= ~(SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES - 1);
  }
        GSMFRDec_BitstreamPort *gsmfrPort = 
            new GSMFRDec_BitstreamPort(0, OMX_DirInput, supported_length, defaultGsmfrSettings, *this);
                    
        if (gsmfrPort == 0) {
            return OMX_ErrorInsufficientResources;
        }
        
    addPort(gsmfrPort);
   if (mIsHost) {
       //gsmfrPort->forceStandardTunneling();
	   gsmfrPort->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);
   }
        return OMX_ErrorNone;
}

OMX_ERRORTYPE  GSMFRDecoder::construct()
{
	OMX_ERRORTYPE error;
	OMX_AUDIO_PARAM_PCMMODETYPE defaultPcmSettings;
    OMX_AUDIO_PARAM_GSMFRTYPE defaultGsmfrSettings;

	defaultPcmSettings.nPortIndex     = 1;
	defaultPcmSettings.eNumData       = OMX_NumericalDataSigned;
	defaultPcmSettings.eEndian        = OMX_EndianBig;
	defaultPcmSettings.bInterleaved   = OMX_TRUE;
	defaultPcmSettings.ePCMMode       = OMX_AUDIO_PCMModeLinear;
	defaultPcmSettings.nBitPerSample  = 16;

	defaultPcmSettings.nChannels      = 1;
	defaultPcmSettings.nSamplingRate  = 8000;

	defaultPcmSettings.eChannelMapping[0] = OMX_AUDIO_ChannelCF;

    defaultGsmfrSettings.nSize         = sizeof(OMX_AUDIO_PARAM_GSMFRTYPE);
    getOmxIlSpecVersion(&defaultGsmfrSettings.nVersion);
    defaultGsmfrSettings.nPortIndex      = 0;
    defaultGsmfrSettings.bDTX            = OMX_FALSE;
    defaultGsmfrSettings.bHiPassFilter   = OMX_TRUE;
    
	error = AFM_Decoder::construct(
			OMX_AUDIO_CodingGSMFR, getSampleFrameSize()*getMaxChannels(), defaultPcmSettings, 1);
	if (error != OMX_ErrorNone) return error;
	
	ENS_String<16> role = "audio_decoder.gsmfr";
  role.put((OMX_STRING)mRoles[0]);
  setActiveRole(mRoles[0]);

	error = createGSMFRBitstreamPort(defaultGsmfrSettings);
    if (error != OMX_ErrorNone) return error;

    if (mIsHost) {
        AFM_PcmPort *pcmPort = static_cast<AFM_PcmPort *>(getPort(1));
        //pcmPort->forceStandardTunneling();
	    pcmPort->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);

    }

	return OMX_ErrorNone;
}

OMX_ERRORTYPE GSMFRDecoder::getExtensionIndex(OMX_STRING cParameterName,
						     OMX_INDEXTYPE* pIndexType) const
{
    if (mIsHost) {
        if (ENS_String<ENS_COMPONENT_NAME_MAX_LENGTH>(cParameterName) 
                == "OMX.ST.AFM.proprietary_communication") {
            return OMX_ErrorNotImplemented;
        }
    }

    return AFM_Component::getExtensionIndex(cParameterName, pIndexType);
}

OMX_ERRORTYPE GSMFRDecoder::createPcmPort(
        OMX_U32 nIndex,
        OMX_DIRTYPE eDir,
        OMX_U32 nBufferSizeMin,
        const OMX_AUDIO_PARAM_PCMMODETYPE &defaultPcmSettings)
{
    ENS_Port * port = new GSMFRDec_PcmPort(
                nIndex, eDir, nBufferSizeMin, defaultPcmSettings, *this);
    if (port == 0) {
        return OMX_ErrorInsufficientResources;
    }

    addPort(port);

    return OMX_ErrorNone;
}
OMX_U32 GSMFRDecoder::getUidTopDictionnary(void)
{
    return KOstGSMFR_HOST_DEC_top_ID;
}
