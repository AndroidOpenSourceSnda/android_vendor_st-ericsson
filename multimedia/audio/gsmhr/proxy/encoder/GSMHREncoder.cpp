/*
 * Copyright (C) ST-Ericsson SA 2010. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 */


#include "GSMHREncoder.h"
#include "GSMHRNmfHost_Encoder.h"
#include "GSMHREnc_BitstreamPort.h"
#include "GSMHREnc_PcmPort.h"
// UID top dictionnary (generated by trace compiler)
#include "GSMHR_HOST_ENC_top.h"
// TODO FIXME: manage buffers that are not 32-bit multiple (for Host proxy only)
#define SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES 4


OMX_ERRORTYPE gsmhrhostencFactoryMethod(ENS_Component_p * ppENSComponent) {
    OMX_ERRORTYPE error  = OMX_ErrorNone;

    GSMHREncoder *gsmhrenc = new GSMHREncoder(true);
    if (gsmhrenc == 0) {
        return OMX_ErrorInsufficientResources;
    }

    error = gsmhrenc->construct();

    if (error != OMX_ErrorNone) {
        delete gsmhrenc;
        *ppENSComponent = 0;
        return OMX_ErrorInsufficientResources;
    } else {
        *ppENSComponent = gsmhrenc;
    }

    GSMHRNmfHost_Encoder *gsmhrenc_ProcessingComp = new GSMHRNmfHost_Encoder(*gsmhrenc);

    if (gsmhrenc_ProcessingComp == 0) {
        delete gsmhrenc;
        return OMX_ErrorInsufficientResources;
    }

    gsmhrenc->setProcessingComponent(gsmhrenc_ProcessingComp);

    return error;
}


OMX_ERRORTYPE GSMHREncoder::createGSMHRBitstreamPort(const OMX_AUDIO_PARAM_GSMHRTYPE &defaultGsmhrSettings)
{
  OMX_U32 supported_length = getMaxFrameSize()/8;

  if (mIsHost) {
    supported_length += (SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES - 1);
    supported_length &= ~(SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES - 1);
  }

    GSMHREnc_BitstreamPort *gsmhrPort = 
      new GSMHREnc_BitstreamPort(1, OMX_DirOutput, supported_length, defaultGsmhrSettings, *this); 

    if (gsmhrPort == 0) {
        return OMX_ErrorInsufficientResources;
    }

    addPort(gsmhrPort);

    gsmhrPort->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);
    return OMX_ErrorNone;
}

OMX_ERRORTYPE  GSMHREncoder::construct()
{
    OMX_ERRORTYPE error;
    OMX_AUDIO_PARAM_PCMMODETYPE defaultPcmSettings;
    OMX_AUDIO_PARAM_GSMHRTYPE defaultGsmhrSettings;

    defaultPcmSettings.nPortIndex     = 0;
    defaultPcmSettings.eNumData       = OMX_NumericalDataSigned;
    defaultPcmSettings.eEndian        = OMX_EndianBig;
    defaultPcmSettings.bInterleaved   = OMX_TRUE;
    defaultPcmSettings.ePCMMode       = OMX_AUDIO_PCMModeLinear;
    defaultPcmSettings.nBitPerSample  = 16;

    defaultPcmSettings.nChannels      = 1;
    defaultPcmSettings.nSamplingRate  = 8000;

    defaultPcmSettings.eChannelMapping[0] = OMX_AUDIO_ChannelCF;

    defaultGsmhrSettings.nSize           = sizeof(OMX_AUDIO_PARAM_GSMHRTYPE);
    getOmxIlSpecVersion(&defaultGsmhrSettings.nVersion);

	defaultGsmhrSettings.nSize         = sizeof(OMX_AUDIO_PARAM_GSMFRTYPE);
    getOmxIlSpecVersion(&defaultGsmhrSettings.nVersion);
    defaultGsmhrSettings.nPortIndex      = 0;
    defaultGsmhrSettings.bDTX            = OMX_FALSE;
    defaultGsmhrSettings.bHiPassFilter   = OMX_TRUE;

    error = AFM_Encoder::construct(
            OMX_AUDIO_CodingGSMHR, getSampleFrameSize(), defaultPcmSettings, 1);
    if (error != OMX_ErrorNone) return error;
    
    ENS_String<16> role = "audio_encoder.gsmhr";
    role.put((OMX_STRING)mRoles[0]);
    setActiveRole(mRoles[0]);

    error = createGSMHRBitstreamPort(defaultGsmhrSettings);
    if (error != OMX_ErrorNone) return error;

    AFM_PcmPort *pcmPort = static_cast<AFM_PcmPort *>(getPort(0));
    pcmPort->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);
    return OMX_ErrorNone;
}

OMX_ERRORTYPE GSMHREncoder::getExtensionIndex(OMX_STRING cParameterName,
						     OMX_INDEXTYPE* pIndexType) const
{
        if (ENS_String<ENS_COMPONENT_NAME_MAX_LENGTH>(cParameterName) 
                == "OMX.ST.AFM.proprietary_communication") {
            return OMX_ErrorNotImplemented;
        }

    return AFM_Component::getExtensionIndex(cParameterName, pIndexType);
}
OMX_ERRORTYPE GSMHREncoder::createPcmPort(
        OMX_U32 nIndex,
        OMX_DIRTYPE eDir,
        OMX_U32 nBufferSizeMin,
        const OMX_AUDIO_PARAM_PCMMODETYPE &defaultPcmSettings)
{
    ENS_Port * port = new GSMHREnc_PcmPort(
                nIndex, eDir, nBufferSizeMin, defaultPcmSettings, *this);
    if (port == 0) {
        return OMX_ErrorInsufficientResources;
    }

    addPort(port);

    return OMX_ErrorNone;
}
OMX_U32 GSMHREncoder::getUidTopDictionnary(void)
{

        return KOstGSMHR_HOST_ENC_top_ID;

}
