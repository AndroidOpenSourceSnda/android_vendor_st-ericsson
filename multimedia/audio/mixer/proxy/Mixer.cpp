/*****************************************************************************/
/*
 * Copyright (C) ST-Ericsson SA 2009,2010. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 *
 */

/**
 * \file   Mixer.cpp
 * \brief
 * \author ST-Ericsson
 */
/*****************************************************************************/

#include "MixerInputPort.h"
#include "MixerOutputPort.h"
#include "audio_chipset_api_index.h"
#include "audio_av_sync_chipset_api.h"
#include "ENS_Component_Fsm.h"

#include "OMX_STE_AudioEffectsExt.h"
#include "MixerEffectsRegister.h"

#ifndef  MPC_ONLY
#include "MixerNmfHost.h"
#endif // MPC_ONLY

#ifndef HOST_ONLY
#include "MixerNmfMpc.h"
#endif //HOST_ONLY

#include "Mixer.h"
// UID top dictionary (generated by trace compiler)
#include "mixer_top.h"
#include "mixer_host_top.h"

#ifndef HOST_ONLY

OMX_ERRORTYPE mixerFactoryMethod(ENS_Component_p * ppENSComponent) {
    OMX_ERRORTYPE error  = OMX_ErrorNone;

    Mixer *mixer = new Mixer(OMX_FALSE);
    if (mixer == 0) {
        return OMX_ErrorInsufficientResources;
    }

    MixerEffects_Init(); //Register Audio effects

    error = mixer->construct();
    if(error != OMX_ErrorNone){
        delete mixer;
        *ppENSComponent = 0;
        return OMX_ErrorInsufficientResources;
    }
    else{
        *ppENSComponent = mixer;
    }

    MixerNmfMpc *mixer_ProcessingComp = new MixerNmfMpc(*mixer);
    if (mixer_ProcessingComp == 0) {
        delete mixer;
        *ppENSComponent = 0;
        return OMX_ErrorInsufficientResources;
    }

    mixer->setProcessingComponent(mixer_ProcessingComp);

    return error;
}
#endif /* HOST_ONLY */

#ifndef MPC_ONLY
OMX_ERRORTYPE mixerhostFactoryMethod(ENS_Component_p * ppENSComponent) {
    OMX_ERRORTYPE error  = OMX_ErrorNone;

    Mixer *mixer = new Mixer(OMX_TRUE);
    if (mixer == 0) {
        return OMX_ErrorInsufficientResources;
    }

    error = mixer->construct();
    if(error != OMX_ErrorNone){
        delete mixer;
        *ppENSComponent = 0;
        return OMX_ErrorInsufficientResources;
    }
    else{
        *ppENSComponent = mixer;
    }

    MixerNmfHost *mixer_ProcessingComp = new MixerNmfHost(*mixer);
    if (mixer_ProcessingComp == 0) {
        delete mixer;
        return OMX_ErrorInsufficientResources;
    }

    mixer->setProcessingComponent(mixer_ProcessingComp);

    return error;
}
#endif /* MPC_ONLY */
OMX_ERRORTYPE Mixer::construct(void)
{
    OMX_ERRORTYPE error;
    OMX_U32 idx;
    ENS_String<25> role;

    error = AFM_Component::construct(NB_INPUT_PORTS + 1, 1 ,mIsHost);
    if (error != OMX_ErrorNone) return error;

    if (mIsHost == OMX_TRUE) {
        role.copy("audio_mixer.pcm.multichannel");
    }
    else {
        role.copy("audio_mixer.pcm.stereo");
    }
    role.put((OMX_STRING)mRoles[0]);
    setActiveRole(mRoles[0]);

    MixerOutputPort *outputPort = new MixerOutputPort(*this, mIsHost);
    if (outputPort == 0) return OMX_ErrorInsufficientResources;
    addPort(outputPort);

    if (mIsHost == OMX_TRUE) {
        AFM_PcmPort *port = static_cast<AFM_PcmPort*>(getPort(0));
        port->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);
    }
    else{
        AFM_PcmPort *port = static_cast<AFM_PcmPort*>(getPort(0));
        port->setSupportedProprietaryComm(AFM_MPC_PROPRIETARY_COMMUNICATION);
    }

    //Create Mixer Input Ports
    for(idx = 1; idx < getPortCount(); idx++) {
        MixerInputPort *inputPort = new MixerInputPort(idx, *this);
        if (inputPort == 0) return OMX_ErrorInsufficientResources;
        addPort(inputPort);

        if (mIsHost == OMX_TRUE) {
            AFM_PcmPort *port = static_cast<AFM_PcmPort*>(inputPort);
            port->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);
        }
        else{
            AFM_PcmPort *port = static_cast<AFM_PcmPort*>(inputPort);
            port->setSupportedProprietaryComm(AFM_MPC_PROPRIETARY_COMMUNICATION);
        }
    }

    return OMX_ErrorNone;
}

Mixer::~Mixer(void) {
    if (mIsHost == OMX_FALSE) {
        MixerEffects_DeInit(); //UnRegister Audio effects when destroying DSP mixer
    }
}


OMX_ERRORTYPE Mixer::getParameter(
	OMX_INDEXTYPE nParamIndex,
	OMX_PTR pComponentParameterStructure) const
{
	switch (nParamIndex) {
        case AFM_IndexParamPcmLayout:
        {
            AFM_PARAM_PCMLAYOUTTYPE *pcmlayout
                = (AFM_PARAM_PCMLAYOUTTYPE *) pComponentParameterStructure;
            OMX_AUDIO_PARAM_PCMMODETYPE &pcmSettingsOut =
                ((AFM_PcmPort *) getPort(OUTPUT_PORT_IDX))->getPcmSettings();
            OMX_AUDIO_PARAM_PCMMODETYPE &pcmSettings =
                ((AFM_PcmPort *) getPort(pcmlayout->nPortIndex))->getPcmSettings();


            OMX_BOOL lowLatencyMode=OMX_FALSE;
            int blockSize;
            int granularityInMs;

            granularityInMs = (mIsHost == OMX_TRUE) ? MS_HOST_GRANULARITY : MS_GRANULARITY;


            if(pcmlayout->nPortIndex == OUTPUT_PORT_IDX){
                    blockSize = granularityInMs * (pcmSettingsOut.nSamplingRate/1000);
            }
            else
            {
                lowLatencyMode = OMX_TRUE;
                if((pcmSettingsOut.nSamplingRate != 8000) && (pcmSettingsOut.nSamplingRate != 16000) && (pcmSettingsOut.nSamplingRate != 48000)){
                    lowLatencyMode=OMX_FALSE;
                }
                if((pcmSettings.nSamplingRate != 8000) && (pcmSettings.nSamplingRate != 16000) && (pcmSettings.nSamplingRate != 48000)){
                    lowLatencyMode=OMX_FALSE;
                }

                if(lowLatencyMode == OMX_FALSE){
                    blockSize = granularityInMs * (pcmSettingsOut.nSamplingRate/1000);
                }
                else{
                    blockSize = granularityInMs * (pcmSettings.nSamplingRate/1000);
                }
            }

            if (mIsHost == OMX_TRUE) {
                // Host is different because it can handle multichannel
                pcmlayout->nChannels = pcmSettings.nChannels;
                pcmlayout->nMaxChannels = MAX_NB_CHANNELS;
                // The nBitsPerSample is aligned with the OMX SetParameter OMX_IndexParamAudioPcm
                pcmlayout->nBitsPerSample = pcmSettingsOut.nBitPerSample;
            }
            else {
                pcmlayout->nChannels = pcmSettings.nChannels;
                pcmlayout->nMaxChannels = 2;
                // The MPC  word size is 24 bits .....
                pcmlayout->nBitsPerSample = 24;
            }
            pcmlayout->nBlockSize = blockSize;
            pcmlayout->nNbBuffers = 1;

            return OMX_ErrorNone;
        }
        default:
            return AFM_Component::getParameter(
                       nParamIndex, pComponentParameterStructure);
	}
}


OMX_ERRORTYPE Mixer::setConfig(
        OMX_INDEXTYPE nConfigIndex,
        OMX_PTR pComponentConfigStructure)
{
    switch (nConfigIndex) {

        case OMX_IndexConfigAudioPortpause:
            {
                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_SYMBIAN_AUDIO_CONFIG_PORTPAUSETYPE);
                OMX_SYMBIAN_AUDIO_CONFIG_PORTPAUSETYPE * pConfig =
                    (OMX_SYMBIAN_AUDIO_CONFIG_PORTPAUSETYPE *) pComponentConfigStructure;

                if( pConfig->nPortIndex == OUTPUT_PORT_IDX ||
                        pConfig->nPortIndex > getPortCount() ) {
                    return OMX_ErrorBadPortIndex;
                }

                MixerInputPort * inport =  static_cast<MixerInputPort *>(getPort(pConfig->nPortIndex));
                inport->setPause(pConfig->bIsPaused);

                return OMX_ErrorNone;
            }

        case OMX_IndexConfigAudioVolume:
        case OMX_IndexConfigAudioMute:
        case OMX_IndexConfigAudioBalance:
        case OMX_IndexConfigAudioVolumeRamp:
            {
                MIXER_CONFIG_PORTBASETYPE * pConfig = (MIXER_CONFIG_PORTBASETYPE *) pComponentConfigStructure;

                if( pConfig->nPortIndex == OUTPUT_PORT_IDX ||
                        pConfig->nPortIndex > getPortCount() ) {
                    //Volume settings not supported by output port : could be supported later if needed by one client!
                    return OMX_ErrorBadPortIndex;
                }

                MixerInputPort * inport =  static_cast<MixerInputPort *>(getPort(pConfig->nPortIndex));
                return inport->setConfig(nConfigIndex, pComponentConfigStructure);
            }

        case OMX_IndexConfigAudioProcessedDataAmount:
            {
                OMX_SYMBIAN_AUDIO_CONFIG_PROCESSEDDATAAMOUNTTYPE * pConfig = (OMX_SYMBIAN_AUDIO_CONFIG_PROCESSEDDATAAMOUNTTYPE *)pComponentConfigStructure;

                if( pConfig->nPortIndex > getPortCount() ) {
                    return OMX_ErrorBadPortIndex;
                }

                return OMX_ErrorNone;
            }

        case OMX_IndexConfigAudioEffectRemovePosition:
        case OMX_IndexConfigAudioEffectCommit:
            {
                MIXER_CONFIG_PORTBASETYPE * pConfig = (MIXER_CONFIG_PORTBASETYPE *) pComponentConfigStructure;

                if(pConfig->nPortIndex == OMX_ALL) {
                    for(OMX_U32 i = 0; i < getPortCount(); i++) {
                        MixerPort * port =  static_cast<MixerPort *>(getPort(i));
                        OMX_ERRORTYPE err = port->setConfig(nConfigIndex, pComponentConfigStructure);
                        if(err != OMX_ErrorNone) {
                            eventHandlerCB(OMX_EventError, err, i, 0);
                        }
                    }
                } else {
                    if( pConfig->nPortIndex > getPortCount() ) return OMX_ErrorBadPortIndex;

                    MixerPort * port =  static_cast<MixerPort *>(getPort(pConfig->nPortIndex));
                    return port->setConfig(nConfigIndex, pComponentConfigStructure);
                }

                return OMX_ErrorNone;
            }

        case OMX_IndexConfigAudioEffectAddPosition:
            {
                MIXER_CONFIG_PORTBASETYPE * pConfig = (MIXER_CONFIG_PORTBASETYPE *) pComponentConfigStructure;

                if( pConfig->nPortIndex > getPortCount() ) {
                    return OMX_ErrorBadPortIndex;
                }

                MixerPort * port =  static_cast<MixerPort *>(getPort(pConfig->nPortIndex));
                return port->setConfig(nConfigIndex, pComponentConfigStructure);
            }

        case OMX_IndexConfigAudioEffectConfigure:
            {
                OMX_AUDIO_CONFIG_EFFECTCONFIGURETYPE *pEffectConfig =
                    static_cast<OMX_AUDIO_CONFIG_EFFECTCONFIGURETYPE *>(pComponentConfigStructure);
                OMX_AUDIO_CONFIG_EFFECTPOSITIONTYPE *pEffectPos = &pEffectConfig->base;

                if( pEffectPos->nPortIndex > getPortCount() ) {
                    return OMX_ErrorBadPortIndex;
                }

                MixerPort * port =  static_cast<MixerPort *>(getPort(pEffectPos->nPortIndex));
                return port->setEffectConfig(pEffectPos->nPositionIndex, pEffectPos->nEffectSpecificIndex, &pEffectConfig->sConfig);
            }

        default:
            {
                return AFM_Component::setConfig(nConfigIndex, pComponentConfigStructure);
            }
    }
}


OMX_ERRORTYPE Mixer::getConfig(
        OMX_INDEXTYPE nConfigIndex,
        OMX_PTR pComponentConfigStructure) const
{
	switch (nConfigIndex) {

        case OMX_IndexConfigAudioPortpause:
        {
            CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_SYMBIAN_AUDIO_CONFIG_PORTPAUSETYPE);
            OMX_SYMBIAN_AUDIO_CONFIG_PORTPAUSETYPE* pConfig =
                    (OMX_SYMBIAN_AUDIO_CONFIG_PORTPAUSETYPE*) pComponentConfigStructure;

            if( pConfig->nPortIndex == OUTPUT_PORT_IDX ||
                pConfig->nPortIndex > getPortCount() ) {
                return OMX_ErrorBadPortIndex;
            }

            pConfig->bIsPaused = ((MixerInputPort *)getPort(pConfig->nPortIndex))->isPaused();

            return OMX_ErrorNone;
        }

        case OMX_IndexConfigAudioVolume:
        case OMX_IndexConfigAudioMute:
        case OMX_IndexConfigAudioBalance:
        case OMX_IndexConfigAudioVolumeRamp:
        {
            MIXER_CONFIG_PORTBASETYPE * pConfig = (MIXER_CONFIG_PORTBASETYPE *) pComponentConfigStructure;

            if( pConfig->nPortIndex == OUTPUT_PORT_IDX ||
                pConfig->nPortIndex > getPortCount() ) {
                //Volume settings not supported by output port : could be supported later if needed by one client!
                return OMX_ErrorBadPortIndex;
            }

            MixerInputPort *inport = (MixerInputPort *)(getPort(pConfig->nPortIndex));

            return inport->getConfig(nConfigIndex, pComponentConfigStructure);
        }

        case OMX_IndexConfigAudioProcessedDataAmount:
        {
            // Reach this case only in loaded state (otherwise retrieveConfig() function is called)
            // then return 0
#ifndef HOST_ONLY
            CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_SYMBIAN_AUDIO_CONFIG_PROCESSEDDATAAMOUNTTYPE);

            if (!runsOnHost()) {
                OMX_SYMBIAN_AUDIO_CONFIG_PROCESSEDDATAAMOUNTTYPE* pConfig = (OMX_SYMBIAN_AUDIO_CONFIG_PROCESSEDDATAAMOUNTTYPE*)pComponentConfigStructure;
                pConfig->nProcessedDataAmount = 0;
                return OMX_ErrorNone;
            }
            else
#endif //HOST_ONLY
            {
                NMF_LOG("Unsupported feature\n");
                return OMX_ErrorNotImplemented;
            }
        }

        case OMX_IndexConfigAudioEffectRemovePosition:
        case OMX_IndexConfigAudioEffectCommit:
            {
                //Should we do something for these indexes?
                return OMX_ErrorNone;
            }

		case OMX_IndexConfigAudioEffectAddPosition:
            {
                MIXER_CONFIG_PORTBASETYPE * pConfig = (MIXER_CONFIG_PORTBASETYPE *) pComponentConfigStructure;

                if( pConfig->nPortIndex > getPortCount() ) {
                    return OMX_ErrorBadPortIndex;
                }

                MixerPort *port = (MixerPort *)(getPort(pConfig->nPortIndex));
                return port->getConfig(nConfigIndex, pComponentConfigStructure);
            }

        case OMX_IndexConfigAudioEffectConfigure:
            {
                OMX_AUDIO_CONFIG_EFFECTCONFIGURETYPE *pEffectConfig =
                    static_cast<OMX_AUDIO_CONFIG_EFFECTCONFIGURETYPE *>(pComponentConfigStructure);
                OMX_AUDIO_CONFIG_EFFECTPOSITIONTYPE *pEffectPos = &pEffectConfig->base;

                if( pEffectPos->nPortIndex > getPortCount() ) {
                    return OMX_ErrorBadPortIndex;
                }

                MixerPort * port =  (MixerPort *)(getPort(pEffectPos->nPortIndex));
                return port->getEffectConfig(pEffectPos->nPositionIndex, pEffectPos->nEffectSpecificIndex, &pEffectConfig->sConfig);
            }

        default:
            {
                return AFM_Component::getConfig(nConfigIndex, pComponentConfigStructure);
            }
    }
}


OMX_U32 Mixer::getUidTopDictionnary(void)
{
    if (mIsHost){
        return KOstmixer_host_top_ID;
    }
    else{
        return KOstmixer_top_ID;
    }
}

OMX_ERRORTYPE Mixer::getExtensionIndex(OMX_STRING extension, OMX_INDEXTYPE* index) const
{
	if (ENS_String<ENS_COMPONENT_NAME_MAX_LENGTH>(extension) == OMX_SYMBIAN_INDEX_CONFIG_AUDIO_VOLUMERAMP_NAME)
	{
		*index = (OMX_INDEXTYPE)OMX_IndexConfigAudioVolumeRamp;
		return OMX_ErrorNone;
	}

    if (ENS_String<ENS_COMPONENT_NAME_MAX_LENGTH>(extension) == OMX_SYMBIAN_INDEX_CONFIG_AUDIO_DATAAMOUNT_NAME)
	{
		*index = (OMX_INDEXTYPE)OMX_IndexConfigAudioProcessedDataAmount;
		return OMX_ErrorNone;
	}

    if (ENS_String<ENS_COMPONENT_NAME_MAX_LENGTH>(extension) == OMX_SYMBIAN_INDEX_CONFIG_AUDIO_PORTPAUSE_NAME)
	{
		*index = (OMX_INDEXTYPE)OMX_IndexConfigAudioPortpause;
		return OMX_ErrorNone;
	}



    return AFM_Component::getExtensionIndex(extension,index);

}

OMX_BOOL Mixer::isPortSpecificParameter(OMX_INDEXTYPE nParamIndex) const
{
    switch(nParamIndex){
        case AFM_IndexParamSrcMode :
             return OMX_TRUE;
        default:
            return AFM_Component::isPortSpecificParameter(nParamIndex);
    }
}
