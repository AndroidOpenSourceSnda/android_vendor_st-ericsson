/*
 * Copyright (C) ST-Ericsson SA 2010. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 */
 
/*!
 * \brief Components Component Manager API.
 *
 * This file contains the Component Manager API for manipulating components.
 */
/*!
 * \defgroup COMPONENT_HOST_CPP CM API for using interface in C++
 * \note The purpose of this dedicated API is mainly for dealing with host C++ core programming model which is not
 * the same as the component base one used on sub-system core.
 * \ingroup CM_USER_API
 */
#ifndef COMMON_COMPONENT_WRAPPER_HPP
#define COMMON_COMPONENT_WRAPPER_HPP

#include <cpp.hpp>

/*!
 * \brief Bind the Host to a component in C++.
 *
 * Create a binding between the Host and a server component running on a MPC in C++.
 *
 * This method and the returned interface can be used like this: \code
 * t_cm_instance_handle server;
 * Iservice T;
 * t_cm_error error;
 *
 * error = CM_BindComponentFromUser(
 *     server,
 *     "input",
 *     8,
 *     &T);
 *
 * T.meth(123);
 * \endcode
 * In this example, we assume that the Iservice type was generated by tools
 * using the "service.itf" interface file description that can look like this:\code
 * void meth(t_uint24 i);
 * \endcode
 *
 * In fact, this method do exactly the same thing as the definition bellow in the
 * architecture file in the static Nomadik Kernel approach:\code
 * binds arm.T to serverName.input
 * \endcode
 *
 * \param[in] server The server component instance handle.
 * \param[in] providedItfServerName The server provided interface name (either collection or not collection name allowed).
 * \param[in] fifosize the number of element in the event fifo (number of simultaneously waiting request)
 * \param[out] itfref The itfref to be filled and called during a Host to MPC
 *   communication.
 *
 * \exception CM_NO_SUCH_PROVIDED_INTERFACE Interface name not provided by the component.
 * \exception CM_BINDING_COMPONENT_NOT_FOUND Binding component require for this binding not found in the
 *    component repository.
 * \exception CM_INVALID_PARAMETER              Invalid parameter (Fifo too bug, ...)
 * \exception CM_NO_MORE_MEMORY
 *
 * \ingroup COMPONENT_HOST_CPP
 */
IMPORT_SHARED t_cm_error CM_BindComponentFromUser(
        const t_cm_instance_handle server,
        const char* providedItfServerName,
        t_uint32 fifosize,
        NMF::InterfaceReference* itfref);

/*!
 * \brief Bind the Host to a component in C.
 *
 * This is the same API as \ref CM_BindComponentFromUser, except that you are able to specify
 * memory where storing event associated with communication channel.
 */
IMPORT_SHARED t_cm_error CM_BindComponentFromUserEx(
        const t_cm_instance_handle server,
        const char* providedItfServerName,
        t_uint32 fifosize,
        t_cm_mpc_memory_type eventMemType,
        NMF::InterfaceReference* itfref);

/*!
 * \brief unBind a component from the Host in C++.
 *
 * Destroy a binding between the Host and a server component running on a MPC in C++.
 *
 * \param[in] itfref Interface handle to be unbound.
 *
 * \exception CM_INVALID_PARAMETER              Invalid parameter (NULL reference)
 * \exception CM_ILLEGAL_UNBINDING              Try to unbind component bind with other binding factories.
 *
 * \ingroup COMPONENT_HOST_CPP
 */
IMPORT_SHARED t_cm_error CM_UnbindComponentFromUser(
        NMF::InterfaceReference* itfref);

/*!
 * \brief Bind a component to the user process.
 *
 * Create a asynchronous binding between client component running on a MPC and the user programm
 * by using the specified channel (the one where all messages concerning this binding will arrive)
 *
 * This method can be used like this in C: \code
 *
 * void mymeth(void *THIS, t_uint24 i) {
 *   // Automatically called by the client MPC component.
 * }
 *
 * Iservice myT = {0, {mymeth}};
 *
 * void main() {
 *   t_cm_instance_handle client;
 *   t_nmf_channel channel;
 *   t_cm_error error;
 *
 *   ...
 *   error = CM_BindComponentToUser(
 *       channel,
 *       client,
 *       "output",
 *       &myT,
 *       8);
 * }
 * \endcode
 *
 * This method can be used like this in C++: \code
 *
 * class mycb: public serviceDescriptor {
 *    void meth(t_uint24) {
 *      // Automatically called by the client MPC component.
 *    }
 * };
 *
 * mycb mycbi;
 *
 * void main() {
 *   t_cm_instance_handle client;
 *   t_cm_error error;
 *
 *   error = CM_BindComponentToUser(
 *       channel,
 *       client,
 *       "output",
 *       &mycbi,
 *       8);
 * }
 * \endcode
 *
 * See \ref CM_BindComponentFromUser for detail about Iservice.
 *
 * In fact, this method do exactly the same thing as the definition bellow in the
 * architecture file in the static Nomadik Kernel approach:\code
 * binds clientName.output to arm.myT
 * \endcode
 *
 * \warning Be careful, since no copy is done of the content of the clientContext.
 *
 * \param[in] channel The channel on which the binding must be done
 * \param[in] client The client component instance handle.
 * \param[in] requiredItfClientName The client required interface name (either collection or not collection name allowed).
 * \param[in] clientContext The user context to be returned when getting incoming message.
 * \param[in] fifosize the number of element in the event fifo (number of simultaneously waiting request)
 *
 * \exception CM_NO_SUCH_REQUIRED_INTERFACE Interface name not required by the component.
 * \exception CM_BINDING_COMPONENT_NOT_FOUND Binding component require for this binding not found in the
 *    component repository.
 * \exception CM_INTERFACE_ALREADY_BINDED       Required interface must be unbinded before rebind.
 * \exception CM_COMPONENT_NOT_STOPPED          Client component must be stopped before reconfigure it
 * \exception CM_INVALID_PARAMETER              Invalid parameter (Fifo too bug, ...)
 * \exception CM_NO_MORE_MEMORY
 *
 * \ingroup COMPONENT_HOST_CPP
 */
IMPORT_SHARED t_cm_error CM_BindComponentToUser(
    const t_nmf_channel channel,
    const t_cm_instance_handle client,
    const char* requiredItfClientName,
    void* clientContext,
    t_uint32 fifosize);

/*!
 * \brief Unbind a component to the User.
 *
 * \param[in] channel The channel on which the binding has been done
 * \param[in] client The client component instance handle.
 * \param[in] requiredItfClientName The client required interface name (either collection or not collection name allowed).
 * \param[out] clientContext return user context, pointer can be NULL.
 *
 * \warning It is up to the caller to garantee that the given channel is the one used for this binding
 *          (ie is the same as the one given to the CM_BindComponentToUser() call)
 *
 * \exception CM_NO_SUCH_REQUIRED_INTERFACE Interface name not required by the component.
 * \exception CM_INTERFACE_NOT_BINDED The required interface is not binded.
 * \exception CM_COMPONENT_NOT_STOPPED          Client component must be stopped before reconfigure it
 * \exception CM_ILLEGAL_UNBINDING              Try to unbind component bind with other binding factories.
 *
 * \ingroup COMPONENT_HOST_CPP
 */
IMPORT_SHARED t_cm_error CM_UnbindComponentToUser(
    const t_nmf_channel channel,
    const t_cm_instance_handle client,
    const char* requiredItfClientName,
    void **clientContext);

#endif
