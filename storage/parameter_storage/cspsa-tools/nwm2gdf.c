/* **************************************************************************
 *
 * nwm2gdf.c
 *
 * Copyright (C) 2012 ST-Ericsson SA
 *
 * This software is released either under the terms of the BSD-style
 * license accompanying CSPSA or a proprietary license obtained from
 * ST-Ericsson SA.
 *
 * Author: 2010, sebastian.rasmussen@stericsson.com
 *
 * DESCRIPTION:
 * Reads a NWM file tree and produces GDF text.
 *
 **************************************************************************** */

#include <dirent.h>
#include <errno.h>
#include <limits.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdbool.h>
#include "nwmcommon.h"

/* ========================================================================== */

#define PROGRAM "nwm2gdf"
#define VERSION 0.0.3

/* ========================================================================== */

static int emit_parameter(FILE *out, int unit, unsigned int size, unsigned char *data)
{
  int result = EXIT_FAILURE;
  int block = 0;
  unsigned int i;
  int j;
  int r;

  r = fprintf(out, "%04x %d %04d\n", unit, size, block);
  if (r < 0)
  {
    fprintf(stderr, ERRORSTR_INTERNAL, __LINE__);
    goto error_exit;
  }

  for (i = 0; i < size; i += 16, data += 16)
  {
    r = fprintf(out, "\t");
    if (r < 0)
    {
      fprintf(stderr, ERRORSTR_INTERNAL, __LINE__);
      goto error_exit;
    }

    for (j = 0; j < 16 && i + j < size; j++)
    {
      r = fprintf(out, "%02x ", data[j]);
      if (r < 0)
      {
        fprintf(stderr, ERRORSTR_INTERNAL, __LINE__);
        goto error_exit;
      }
    }

    r = fprintf(out, "\n");
    if (r < 0)
    {
      fprintf(stderr, ERRORSTR_INTERNAL, __LINE__);
      goto error_exit;
    }
  }

  result = EXIT_SUCCESS;

error_exit:
  return result;
}

/* ========================================================================== */

static int emit_header(FILE *out)
{
  int result = EXIT_FAILURE;
  char paramstr[BUFSIZ];
  int r;

  result = create_id(PROGRAM, STRINGIFY(VERSION), paramstr, BUFSIZ);
  if (result != EXIT_SUCCESS)
  {
    fprintf(stderr, ERRORSTR_INTERNAL, __LINE__);
    goto error_exit;
  }

  fprintf(out, "// Generated by " PROGRAM " " STRINGIFY(VERSION) " Copyright (C) ST-Ericsson AB\n");
  fprintf(out, "// %s\n", paramstr);
  fprintf(out, "//\n");
  fprintf(out, "// Description of the .gdf format:\n");
  fprintf(out, "// Comment lines start with //, while the parameter format is:\n");
  fprintf(out, "// <UNIT>(hex) <DATASIZE>(dec) <BLOCK>(hex)\n");
  fprintf(out, "//      [<DATA>(hex)]\n");
  fprintf(out, "//\n");
  fprintf(out, "// File tree encoding:\n");
  fprintf(out, "// The limit of 0xfff entries is arbitrarily chosen for\n");
  fprintf(out, "// the program generating this file, it is not a limitation\n");
  fprintf(out, "// of the file tree encoding.\n");
  fprintf(out, "//\n");
  fprintf(out, "// Unit id 0x0000 (32bit unsigned little endian) the number of entries.\n");
  fprintf(out, "// Unit ids 0x0001-0x0fff are used for file information.\n");
  fprintf(out, "// Unit id 0x1000 execution date and version of " PROGRAM " used.\n");
  fprintf(out, "// Unit ids 0x1001-0x1fff are used for file contents.\n");
  fprintf(out, "// Unit ids 0x2000- are unused.\n");
  fprintf(out, "//\n");
  fprintf(out, "//     File info is encoded in a 96 byte unit as follows (all entries\n");
  fprintf(out, "//     are 32bit unsigned little endian, except path and entry name which\n");
  fprintf(out, "//     are strings of limited length without trailing null encoded in the\n");
  fprintf(out, "//     targets default locale text encoding, unused bytes in a string are null):\n");
  fprintf(out, "//     Offset  0: entry type (0 == directory, 1 == file)\n");
  fprintf(out, "//     Offset  4: creation time (seconds since epoch)\n");
  fprintf(out, "//     Offset  8: creation time (micro seconds since epoch)\n");
  fprintf(out, "//     Offset 12: mode (same types as returned from stat(2))\n");
  fprintf(out, "//     Offset 16: size in bytes (== 0/ignored for directories)\n");
  fprintf(out, "//     Offset 24: path (string of up to 52 bytes, with trailing slash)\n");
  fprintf(out, "//     Offset 76: entry name (string of up to 12 bytes)\n");
  fprintf(out, "//     Offset 88: data unit (unit containing file contents, == 0xffffffff for directories)\n");
  fprintf(out, "//     Offset 92: unused (should be 0xffffffff)\n");
  fprintf(out, "//\n");
  fprintf(out, "// Paths shall always end with a trailing slash(/) and entry\n");
  fprintf(out, "// names never contain a slash(/), unless it is the information\n");
  fprintf(out, "// of the root directory that is being described in which case\n");
  fprintf(out, "// the path shall be the empty string while the name is a single\n");
  fprintf(out, "// slash(/) character.\n");
  fprintf(out, "//\n");
  fprintf(out, "// The " PROGRAM " is a string of the same contents as line two above.\n");
  r = fprintf(out, "//\n");
  if (r < 0)
  {
    fprintf(stderr, ERRORSTR_INTERNAL, __LINE__);
    goto error_exit;
  }

  result = emit_parameter(out, MAX_FILES + 1, strlen(paramstr) + 1, (unsigned char *) paramstr);
  if (result != EXIT_SUCCESS)
  {
    fprintf(stderr, ERRORSTR_INTERNAL, __LINE__);
    goto error_exit;
  }

error_exit:
  return result;
}

/* ========================================================================== */

static int process(struct cmd_line_options* cmd_line_options)
{
  int result = EXIT_FAILURE;
  FILE *out = NULL;
  uint32_t entries;
  struct state state;
  param_t *par;

  memset(&state, 0, sizeof(state));

  if (cmd_line_options->debug)
    printf(PROGRAM ": Processing %s, generating %s\n", cmd_line_options->inpath, cmd_line_options->outfile);

  /* open output file (can be stdout) */
  if (!strcmp(cmd_line_options->outfile, "-"))
    out = stdout;
  else
    out = fopen(cmd_line_options->outfile, "w");
  if (!out)
  {
    fprintf(stderr, ERRORSTR "Can not open output file '%s'.\n", cmd_line_options->outfile);
    goto error_exit;
  }

  result = emit_header(out);
  if (result != EXIT_SUCCESS)
  {
    fprintf(stderr, ERRORSTR_INTERNAL, __LINE__);
    goto error_exit;
  }

  /* unit id 0 is reserved for the number of entries */
  state.entries = 1;

  /* create entries in a linked list for each file
   * or directory in the input directory tree */
  result = process_dirtree(cmd_line_options, cmd_line_options->inpath, "/", NULL, &state);
  if (result != EXIT_SUCCESS)
    goto error_exit;

  par = state.par;
  while (par != NULL)
  {
    result = emit_parameter(out, par->key, par->size, par->data);
    if (result != EXIT_SUCCESS)
      goto error_exit;
    par = next_param(par);
  }

  /* a unit id 0 output the number of files+dirs */
  entries = state.entries - 1;
  result = emit_parameter(out, 0, sizeof (entries), (unsigned char *) &entries);
  if (result != EXIT_SUCCESS)
    goto error_exit;

error_exit:

  if (state.par)
    free_param(state.par);

  /* close output file */
  if (strcmp(cmd_line_options->outfile, "-") && fclose(out))
  {
    fprintf(stderr, ERRORSTR "Can not close output file");
  }

  return result;
}

/* ========================================================================== */

static void usage(void)
{
  fprintf(stderr, PROGRAM " " STRINGIFY(VERSION) " Copyright (C) 2012 ST-Ericsson AB\n");
  fprintf(stderr, "\n");
  fprintf(stderr, "Usage: " PROGRAM " [options] <directory-path>\n");
  fprintf(stderr, "\nWhere [options] may be:\n");
  fprintf(stderr, "\t-o file\tname of output file, in .gdf format\n");
  fprintf(stderr, "\t-d\tenable debug logs\n");
}

/* ========================================================================== */

int main(int argc, char **argv)
{
  int result = EXIT_FAILURE;
  struct cmd_line_options cmd_line_options;
  int opt;

  memset(&cmd_line_options, 0, sizeof(cmd_line_options));

  cmd_line_options.outfile = strdup("-");
  cmd_line_options.program = PROGRAM;

  /* Parse command line options */
  while ((opt = getopt(argc, argv, "dho:")) != -1)
  {
    switch (opt)
    {
      case '?':
      case 'h':
        usage();
        break;

      case 'd':
        cmd_line_options.debug = 1;
        break;

      case 'o':
        free(cmd_line_options.outfile);
        cmd_line_options.outfile = strdup(optarg);
        break;

      default:
        goto error_exit;
    }
  }

  if (argc - optind != 1)
  {
    fprintf(stderr, "Expected input path argument missing.\n");
    goto error_exit;
  }
  cmd_line_options.inpath = strdup(argv[optind]);

  /* This is the function tree that converts a dirtree to a .gdf */
  result = process(&cmd_line_options);

error_exit:
  free(cmd_line_options.inpath);
  free(cmd_line_options.outfile);
  return result;
}

/* ========================================================================== */
