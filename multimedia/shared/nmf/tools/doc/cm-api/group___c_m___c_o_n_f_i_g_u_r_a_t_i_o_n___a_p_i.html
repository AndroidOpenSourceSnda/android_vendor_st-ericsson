<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>NMF Component Manager Documentation: CM Proxy Configuration API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<small><b>
<a href="http://www.stericsson.com"><img src="logo.jpg" width=220 height=68></a>
 WMM/MCP/MMD <a href="https://codex.cro.st.com/projects/nmf/">Nomadik Multiprocessing Framework</a>
</b></small>
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>CM Proxy Configuration API<br/>
<small>
[<a class="el" href="group___c_m___p_r_o_x_y___m_o_d_u_l_e.html">CM Proxy</a>]</small>
</h1>
<p>Component Manager Configuration API.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for CM Proxy Configuration API:</div>
<div class="dynsection">
<center><table><tr><td><img src="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.png" border="0" alt="" usemap="#group______c__m______c__o__n__f__i__g__u__r__a__t__i__o__n______a__p__i_map"/>
<map name="group______c__m______c__o__n__f__i__g__u__r__a__t__i__o__n______a__p__i_map" id="group______c__m______c__o__n__f__i__g__u__r__a__t__i__o__n______a__p__i">
<area shape="rect" href="group__t__cm__cmd__id.html" title="Configuration Component Manager API type." alt="" coords="369,5,468,35"/><area shape="rect" href="group___c_m___p_r_o_x_y___m_o_d_u_l_e.html" title="CM Proxy" alt="" coords="5,5,85,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__t__cm__cmd__id.html">t_cm_cmd_id</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Configuration Component Manager API type. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga64f778f774abb28194b6c2e5e40d3fb3">CM_REGISTER_STUBS_SKELS</a>(name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro to be used used to register a set of Host stubs and skeletons.  <a href="#ga64f778f774abb28194b6c2e5e40d3fb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#gac64d4573b1a234b0b1060f748a2062dd">CM_UNREGISTER_STUBS_SKELS</a>(name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro to be used used to unregister a set of Host stubs and skeletons.  <a href="#gac64d4573b1a234b0b1060f748a2062dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#gab1cefe8f6376c271b37eac28d0910e91">CM_REGISTER_STUBS</a>(name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro to be used used to register a set of Host stubs.  <a href="#gab1cefe8f6376c271b37eac28d0910e91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga9f2fe5a241890db2ffe9cc8073b9ef20">CM_UNREGISTER_STUBS</a>(name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro to be used used to unregister a set of Host stubs.  <a href="#ga9f2fe5a241890db2ffe9cc8073b9ef20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#gaaa0fc9d28ccba62df048d97486956bda">CM_REGISTER_SKELS</a>(name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro to be used used to register a set of Host skeletons.  <a href="#gaaa0fc9d28ccba62df048d97486956bda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#gad4a288b3b241596bc01b5e1716a14b83">CM_UNREGISTER_SKELS</a>(name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Macro to be used used to unregister a set of Host skeletons.  <a href="#gad4a288b3b241596bc01b5e1716a14b83"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga7a4218590ff148870199bbfb384095ef">CM_CreateChannel</a> (<a class="el" href="group____t__nmf__channel__flag.html#ga673eb84bed6799730e793b5e37439ffc">t_nmf_channel_flag</a> flags, <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga83e5886d66e2e3a546f5be82d58512df">t_nmf_channel</a> *channel)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create/get a channel.  <a href="#ga7a4218590ff148870199bbfb384095ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#gadf3d3823a51d7cd8b4de6928513a953b">CM_FlushChannel</a> (<a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga83e5886d66e2e3a546f5be82d58512df">t_nmf_channel</a> channel, <a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga95bcce01270fd92083b6d269f921e662">t_bool</a> *isFlushMessageGenerated)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush a channel to allow user to safely close it.  <a href="#gadf3d3823a51d7cd8b4de6928513a953b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga02edd0ce2d444394a41282520c3ff69c">CM_CloseChannel</a> (<a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga83e5886d66e2e3a546f5be82d58512df">t_nmf_channel</a> channel)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a channel.  <a href="#ga02edd0ce2d444394a41282520c3ff69c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#gab5434723e1d757fe73145b4e8ce975df">CM_RegisterService</a> (<a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga83e5886d66e2e3a546f5be82d58512df">t_nmf_channel</a> channel, <a class="el" href="group___n_m_f___s_e_r_v_i_c_e.html#ga1005f1a6cd6f2e941dd1144a5e4c31fa">t_nmf_serviceCallback</a> handler, void *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a service callback to this channel.  <a href="#gab5434723e1d757fe73145b4e8ce975df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga19f3c5f18ef2b7523c6b5ce4be613f65">CM_UnregisterService</a> (<a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga83e5886d66e2e3a546f5be82d58512df">t_nmf_channel</a> channel, <a class="el" href="group___n_m_f___s_e_r_v_i_c_e.html#ga1005f1a6cd6f2e941dd1144a5e4c31fa">t_nmf_serviceCallback</a> handler, void *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister a service callback from this channel.  <a href="#ga19f3c5f18ef2b7523c6b5ce4be613f65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED <a class="el" href="group__t__cm__error.html#ga0c6e4897ef6a9f579c3dcac1b697141b">t_cm_error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#gaf85b046d40c5b07485d6da7f7ee5b82b">CM_SetMode</a> (<a class="el" href="group__t__cm__cmd__id.html#ga28c38df65d4df9dbd24bfd722d63ab65">t_cm_cmd_id</a> aCmdID, <a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga879ad29618b485db656730acdaae68fa">t_sint32</a> aParam)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the mode of the Component Manager engine.  <a href="#gaf85b046d40c5b07485d6da7f7ee5b82b"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Component Manager Configuration API. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gaaa0fc9d28ccba62df048d97486956bda"></a><!-- doxytag: member="communication_proxy.h::CM_REGISTER_SKELS" ref="gaaa0fc9d28ccba62df048d97486956bda" args="(name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CM_REGISTER_SKELS</td>
          <td>(</td>
          <td class="paramtype">name&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
    <span class="keyword">extern</span> t_nmf_skel_register name##_skel_register; \
    <a class="code" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga4a862111cb353b5d11c1f7720c140e1a" title="Host skeletons registering facilities.">CM_INTERNAL_RegisterMpc2HostInterfaces</a>(&amp;name##_skel_register); \
}
</pre></div>
<p>Macro to be used used to register a set of Host skeletons. </p>
<p>This macro shall be called to register the generated Host skeletons.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Host skels are generated by: nmfitfc -mpc2host &lt;list of interface names&gt;</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>By example, if the generated Host skels are linked into a dll, then this macro should be called when loading and initializing the given dll. </dd></dl>

</div>
</div>
<a class="anchor" id="gab1cefe8f6376c271b37eac28d0910e91"></a><!-- doxytag: member="communication_proxy.h::CM_REGISTER_STUBS" ref="gab1cefe8f6376c271b37eac28d0910e91" args="(name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CM_REGISTER_STUBS</td>
          <td>(</td>
          <td class="paramtype">name&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
    <span class="keyword">extern</span> t_nmf_stub_register name##_stub_register; \
    <a class="code" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga15cbe35fb6fa823f82f8efb688e2616b" title="Host stubs registering facilities.">CM_INTERNAL_RegisterHost2MpcInterfaces</a>(&amp;name##_stub_register); \
}
</pre></div>
<p>Macro to be used used to register a set of Host stubs. </p>
<p>This macro shall be called to register the generated Host stubs.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Host stubs are generated by: nmfitfc -host2mpc &lt;list of interface names&gt;</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>By example, if the generated Host stubs are linked into a dll, then this macro should be called when loading and initializing the given dll. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64f778f774abb28194b6c2e5e40d3fb3"></a><!-- doxytag: member="communication_proxy.h::CM_REGISTER_STUBS_SKELS" ref="ga64f778f774abb28194b6c2e5e40d3fb3" args="(name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CM_REGISTER_STUBS_SKELS</td>
          <td>(</td>
          <td class="paramtype">name&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
    <span class="keyword">extern</span> t_nmf_stub_register name##_stub_register; \
    <span class="keyword">extern</span> t_nmf_skel_register name##_skel_register; \
    <a class="code" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga15cbe35fb6fa823f82f8efb688e2616b" title="Host stubs registering facilities.">CM_INTERNAL_RegisterHost2MpcInterfaces</a>(&amp;name##_stub_register); \
    <a class="code" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga4a862111cb353b5d11c1f7720c140e1a" title="Host skeletons registering facilities.">CM_INTERNAL_RegisterMpc2HostInterfaces</a>(&amp;name##_skel_register); \
}
</pre></div>
<p>Macro to be used used to register a set of Host stubs and skeletons. </p>
<p>This macro shall be called to register the generated Host stubs and skeletons.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Host stubs are generated by: nmfitfc -host2mpc &lt;list of interface names&gt;. Host skels are generated by: nmfitfc -mpc2host &lt;list of interface names&gt;.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>By example, if the generated Host stubs and skeletons are linked into a dll, then this macro should be called when loading and initializing the given dll. </dd></dl>

</div>
</div>
<a class="anchor" id="gad4a288b3b241596bc01b5e1716a14b83"></a><!-- doxytag: member="communication_proxy.h::CM_UNREGISTER_SKELS" ref="gad4a288b3b241596bc01b5e1716a14b83" args="(name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CM_UNREGISTER_SKELS</td>
          <td>(</td>
          <td class="paramtype">name&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
    <span class="keyword">extern</span> t_nmf_skel_register name##_skel_register; \
    <a class="code" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#gac1906fdfeefff21b8a7f6f052bbf5bd5" title="Host skeletons unregistering facilities.">CM_INTERNAL_UnregisterMpc2HostInterfaces</a>(&amp;name##_skel_register); \
}
</pre></div>
<p>Macro to be used used to unregister a set of Host skeletons. </p>
<p>This macro shall be called to unregister the generated Host skeletons for example before unloading a DLL or at the end of the process.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If you register N times a stubs, you must unregister them N times too. </dd>
<dd>
Don't call this macro if you have call the corresponding register macro before. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f2fe5a241890db2ffe9cc8073b9ef20"></a><!-- doxytag: member="communication_proxy.h::CM_UNREGISTER_STUBS" ref="ga9f2fe5a241890db2ffe9cc8073b9ef20" args="(name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CM_UNREGISTER_STUBS</td>
          <td>(</td>
          <td class="paramtype">name&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
    <span class="keyword">extern</span> t_nmf_stub_register name##_stub_register; \
    <a class="code" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga59d3ead4e35d597cac0a2c11bee0b323" title="Host stubs unregistering facilities.">CM_INTERNAL_UnregisterHost2MpcInterfaces</a>(&amp;name##_stub_register); \
}
</pre></div>
<p>Macro to be used used to unregister a set of Host stubs. </p>
<p>This macro shall be called to unregister the generated Host stubs for example before unloading a DLL or at the end of the process.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If you register N times a stubs, you must unregister them N times too. </dd>
<dd>
Don't call this macro if you have call the corresponding register macro before. </dd></dl>

</div>
</div>
<a class="anchor" id="gac64d4573b1a234b0b1060f748a2062dd"></a><!-- doxytag: member="communication_proxy.h::CM_UNREGISTER_STUBS_SKELS" ref="gac64d4573b1a234b0b1060f748a2062dd" args="(name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CM_UNREGISTER_STUBS_SKELS</td>
          <td>(</td>
          <td class="paramtype">name&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
    <span class="keyword">extern</span> t_nmf_stub_register name##_stub_register; \
    <span class="keyword">extern</span> t_nmf_skel_register name##_skel_register; \
    <a class="code" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga59d3ead4e35d597cac0a2c11bee0b323" title="Host stubs unregistering facilities.">CM_INTERNAL_UnregisterHost2MpcInterfaces</a>(&amp;name##_stub_register); \
    <a class="code" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#gac1906fdfeefff21b8a7f6f052bbf5bd5" title="Host skeletons unregistering facilities.">CM_INTERNAL_UnregisterMpc2HostInterfaces</a>(&amp;name##_skel_register); \
}
</pre></div>
<p>Macro to be used used to unregister a set of Host stubs and skeletons. </p>
<p>This macro shall be called to unregister the generated Host stubs and skeletons for example before unloading a DLL or at the end of the process.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If you register N times an stubs and skeletons, you must unregister them N times too. </dd>
<dd>
Don't call this macro if you have call the corresponding register macro before. </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga02edd0ce2d444394a41282520c3ff69c"></a><!-- doxytag: member="configuration_proxy.h::CM_CloseChannel" ref="ga02edd0ce2d444394a41282520c3ff69c" args="(t_nmf_channel channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a> CM_CloseChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga83e5886d66e2e3a546f5be82d58512df">t_nmf_channel</a>&nbsp;</td>
          <td class="paramname"> <em>channel</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a channel. </p>
<p>The purpose of the function is to destroy a channel from the user to the CM engine.</p>
<p>The user must call <a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga02edd0ce2d444394a41282520c3ff69c" title="Close a channel.">CM_CloseChannel()</a> as many time as <a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga7a4218590ff148870199bbfb384095ef">CM_CreateChannel()</a>. At the last <a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga02edd0ce2d444394a41282520c3ff69c" title="Close a channel.">CM_CloseChannel()</a> call, the channel is closed and definitely destroyed. All service callback must be unregistered first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>Channel number:</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CM_INVALID_PARAMETER</em>&nbsp;</td><td>The specified channel is invalid or some callback are still registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7a4218590ff148870199bbfb384095ef"></a><!-- doxytag: member="configuration_proxy.h::CM_CreateChannel" ref="ga7a4218590ff148870199bbfb384095ef" args="(t_nmf_channel_flag flags, t_nmf_channel *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a> CM_CreateChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group____t__nmf__channel__flag.html#ga673eb84bed6799730e793b5e37439ffc">t_nmf_channel_flag</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga83e5886d66e2e3a546f5be82d58512df">t_nmf_channel</a> *&nbsp;</td>
          <td class="paramname"> <em>channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create/get a channel. </p>
<p>The purpose of the function is to create a channel or get a channel, regarding the flag parameter</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Whether the caller want to create a new channel (NMF_CHANNEL_PRIVATE) or use the shared one (NMF_CHANNEL_SHARED) (it will be created if it does not yet exist) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>Channel number.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CM_NO_MORE_MEMORY</em>&nbsp;</td><td>Not enough memory to create the callback Channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CM_INVALID_PARAMETER</em>&nbsp;</td><td>The specified flags is invalid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CM_INTEGRATION_ERROR</em>&nbsp;</td><td>OS specific error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadf3d3823a51d7cd8b4de6928513a953b"></a><!-- doxytag: member="configuration_proxy.h::CM_FlushChannel" ref="gadf3d3823a51d7cd8b4de6928513a953b" args="(t_nmf_channel channel, t_bool *isFlushMessageGenerated)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a> CM_FlushChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga83e5886d66e2e3a546f5be82d58512df">t_nmf_channel</a>&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga95bcce01270fd92083b6d269f921e662">t_bool</a> *&nbsp;</td>
          <td class="paramname"> <em>isFlushMessageGenerated</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush a channel to allow user to safely close it. </p>
<p>The purpose of the function is to allow safe call of <a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga02edd0ce2d444394a41282520c3ff69c" title="Close a channel.">CM_CloseChannel()</a> later on. Calling <a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#gadf3d3823a51d7cd8b4de6928513a953b" title="Flush a channel to allow user to safely close it.">CM_FlushChannel()</a> will allow a blocking call to <a class="el" href="group___c_m___c_a_l_l_b_a_c_k___a_p_i.html#ga3a22d66689ae843f9c00a35bf64dc6d2" title="Get received message from specified callback channel.">CM_GetMessage()</a> to exit with an error CM_FLUSH_MESSAGE. After <a class="el" href="group___c_m___c_a_l_l_b_a_c_k___a_p_i.html#ga3a22d66689ae843f9c00a35bf64dc6d2" title="Get received message from specified callback channel.">CM_GetMessage()</a> has exit with such a value user must no more call <a class="el" href="group___c_m___c_a_l_l_b_a_c_k___a_p_i.html#ga3a22d66689ae843f9c00a35bf64dc6d2" title="Get received message from specified callback channel.">CM_GetMessage()</a> and can safely call <a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga02edd0ce2d444394a41282520c3ff69c" title="Close a channel.">CM_CloseChannel()</a> that will destroy channel. In case of the share channel <a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#gadf3d3823a51d7cd8b4de6928513a953b" title="Flush a channel to allow user to safely close it.">CM_FlushChannel()</a> will return false for isFlushMessageGenerated if it's internal reference counter is not zero, in that case no CM_FLUSH_MESSAGE error is return by <a class="el" href="group___c_m___c_a_l_l_b_a_c_k___a_p_i.html#ga3a22d66689ae843f9c00a35bf64dc6d2" title="Get received message from specified callback channel.">CM_GetMessage()</a> and user can immediatly call <a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga02edd0ce2d444394a41282520c3ff69c" title="Close a channel.">CM_CloseChannel()</a>. In case user know that no usage of channel is done when he want to destroy channel, call to this api is optionnal and user can safely call <a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga02edd0ce2d444394a41282520c3ff69c" title="Close a channel.">CM_CloseChannel()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>Channel number </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>isFlushMessageGenerated</em>&nbsp;</td><td>Allow user to know if it must wait for CM_FLUSH_MESSAGE return of <a class="el" href="group___c_m___c_a_l_l_b_a_c_k___a_p_i.html#ga3a22d66689ae843f9c00a35bf64dc6d2" title="Get received message from specified callback channel.">CM_GetMessage()</a> before calling <a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga02edd0ce2d444394a41282520c3ff69c" title="Close a channel.">CM_CloseChannel()</a></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NMF_INVALID_PARAMETER</em>&nbsp;</td><td>The specified flags is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab5434723e1d757fe73145b4e8ce975df"></a><!-- doxytag: member="configuration_proxy.h::CM_RegisterService" ref="gab5434723e1d757fe73145b4e8ce975df" args="(t_nmf_channel channel, t_nmf_serviceCallback handler, void *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a> CM_RegisterService </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga83e5886d66e2e3a546f5be82d58512df">t_nmf_channel</a>&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___n_m_f___s_e_r_v_i_c_e.html#ga1005f1a6cd6f2e941dd1144a5e4c31fa">t_nmf_serviceCallback</a>&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ctx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a service callback to this channel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel on which the callback must be registered. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handler</em>&nbsp;</td><td>The given callback. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctx</em>&nbsp;</td><td>The context associated with this callback (the one passed to the handler).</td></tr>
  </table>
  </dd>
</dl>
<p>The handler must be a function with the following declaration </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> service(<span class="keywordtype">void</span> *contextHandler, <a class="code" href="group___n_m_f___s_e_r_v_i_c_e.html#ga171cff322c0c5564600d5960ae78bb79" title="Define t_nmf_service_type type.">t_nmf_service_type</a> serviceType, <a class="code" href="uniont__nmf__service__data.html" title="Define t_nmf_service_data type.">t_nmf_service_data</a> *serviceData)
      {
        <span class="keywordflow">switch</span> (servicetype) {
        <span class="keywordflow">case</span> NMF_SERVICE_PANIC:
                <a class="code" href="structt__nmf__panic__data.html" title="Define t_nmf_panic_data type.">t_nmf_panic_data</a> *panic = &amp;serviceData-&gt;<a class="code" href="uniont__nmf__service__data.html#abf0ad4bdec8510028c282bfa5e2b8822" title="if service_type == NMF_SERVICE_PANIC">panic</a>;
               ...
                <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span>:
                <span class="keywordflow">break</span>;
        }

     }
</pre></div><p>This 'service' function will be called from <a class="el" href="group___c_m___c_a_l_l_b_a_c_k___a_p_i.html#gaa3a9294839a79c3abda01655403cfb57">CM_ExecuteMessage()</a> for each incoming 'service messages'</p>
<ul>
<li>The 'contextHandler' passed is the context given when registering this service callback</li>
<li>'serviceType' specifies the service</li>
</ul>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CM_INVALID_PARAMETER</em>&nbsp;</td><td>The channel doesn't exist or the callback is NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CM_NO_MORE_MEMORY</em>&nbsp;</td><td>Not enough memory to associate service with the Channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf85b046d40c5b07485d6da7f7ee5b82b"></a><!-- doxytag: member="configuration_proxy.h::CM_SetMode" ref="gaf85b046d40c5b07485d6da7f7ee5b82b" args="(t_cm_cmd_id aCmdID, t_sint32 aParam)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED <a class="el" href="group__t__cm__error.html#ga0c6e4897ef6a9f579c3dcac1b697141b">t_cm_error</a> CM_SetMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__t__cm__cmd__id.html#ga28c38df65d4df9dbd24bfd722d63ab65">t_cm_cmd_id</a>&nbsp;</td>
          <td class="paramname"> <em>aCmdID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga879ad29618b485db656730acdaae68fa">t_sint32</a>&nbsp;</td>
          <td class="paramname"> <em>aParam</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the mode of the Component Manager engine. </p>
<p>According the (<a class="el" href="group__t__cm__cmd__id.html">t_cm_cmd_id</a>) value, this routine allows to modify dynamically the behavior of the CM-engine.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aCmdID</em>&nbsp;</td><td>Command ID. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aParam</em>&nbsp;</td><td>Parameter of command ID if required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga19f3c5f18ef2b7523c6b5ce4be613f65"></a><!-- doxytag: member="configuration_proxy.h::CM_UnregisterService" ref="ga19f3c5f18ef2b7523c6b5ce4be613f65" args="(t_nmf_channel channel, t_nmf_serviceCallback handler, void *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a> CM_UnregisterService </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga83e5886d66e2e3a546f5be82d58512df">t_nmf_channel</a>&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___n_m_f___s_e_r_v_i_c_e.html#ga1005f1a6cd6f2e941dd1144a5e4c31fa">t_nmf_serviceCallback</a>&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ctx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregister a service callback from this channel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel on which the callback must be registered. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handler</em>&nbsp;</td><td>The given callback. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctx</em>&nbsp;</td><td>The context associated with this callback.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CM_INVALID_PARAMETER</em>&nbsp;</td><td>The channel or the callback doesn't exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr size="1">
<address style="align: right;"><small> 
<b>NMF Component Manager Documentation</b> generated by <a href="http://www.doxygen.org">doxygen</a> 1.6.3 on 28 Oct 2011
</small></address>
<address style="align: right;"><small>
Copyright 2006-2009 <a href="http://www.stericsson.com"><b>ST-Ericsson</b></a>
 - Confidential document - Unauthorized reproduction and communication strictly prohibited
</small></address>
</body>
</html>
