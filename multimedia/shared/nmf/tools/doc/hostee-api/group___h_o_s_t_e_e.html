<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>NMF Host Execution Engine Documentation: Host Execution Engine API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<small><b>
<a href="http://www.stericsson.com"><img src="logo.jpg" width=220 height=68></a>
 WMM/MCP/MMD <a href="https://codex.cro.st.com/projects/nmf/">Nomadik Multiprocessing Framework</a>
</b></small>
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Host Execution Engine API<br/>
<small>
[<a class="el" href="group___h_o_s_t_e_e___m_o_d_u_l_e.html">Host Execution Engine</a>]</small>
</h1>
<p><div class="dynheader">
Collaboration diagram for Host Execution Engine API:</div>
<div class="dynsection">
<center><table><tr><td><img src="group___h_o_s_t_e_e.png" border="0" alt="" usemap="#group______h__o__s__t__e__e_map"/>
<map name="group______h__o__s__t__e__e_map" id="group______h__o__s__t__e__e">
<area shape="rect" href="group___h_o_s_t_e_e___m_o_d_u_l_e.html" title="Host Execution Engine" alt="" coords="7,5,159,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga58fbb06f5b11435effb8bcd479497161"></a><!-- doxytag: member="HOSTEE::t_nmf_notify" ref="ga58fbb06f5b11435effb8bcd479497161" args=")(void *contextHandler)" -->
typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_s_t_e_e.html#ga58fbb06f5b11435effb8bcd479497161">t_nmf_notify</a> )(void *contextHandler)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify callback method type. <br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_s_t_e_e.html#ga75653620e03cd7cc6cb6dfe29d9d2542">EE_GetVersion</a> (<a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga5543ed798da376a99db035f6ae6aaa1f">t_uint32</a> *version)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the version of the NMF Host EE at runtime.  <a href="#ga75653620e03cd7cc6cb6dfe29d9d2542"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED t_nmf_error&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_s_t_e_e.html#ga8616ff7112c2797b2fd44487c09f601c">EE_SetMode</a> (t_ee_cmd_id aCmdID, <a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga879ad29618b485db656730acdaae68fa">t_sint32</a> aParam)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the mode of the Host EE.  <a href="#ga8616ff7112c2797b2fd44487c09f601c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED t_nmf_error&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_s_t_e_e.html#ga508533a1c5fba03ccdaa7f81ff9f1fba">EE_CreateChannel</a> (<a class="el" href="group____t__nmf__channel__flag.html#ga673eb84bed6799730e793b5e37439ffc">t_nmf_channel_flag</a> flags, t_nmf_channel *channel)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a channel for communication between host ee and user.  <a href="#ga508533a1c5fba03ccdaa7f81ff9f1fba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED t_nmf_error&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_s_t_e_e.html#ga2747a37aa0bad5d6cf254ec1d700ddfc">EE_FlushChannel</a> (t_nmf_channel channel, <a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga95bcce01270fd92083b6d269f921e662">t_bool</a> *isFlushMessageGenerated)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush a channel to allow user to safely close it.  <a href="#ga2747a37aa0bad5d6cf254ec1d700ddfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED t_nmf_error&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_s_t_e_e.html#ga1d9d0316360071c0126a3e2a1b414c32">EE_CloseChannel</a> (t_nmf_channel channel)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister channel.  <a href="#ga1d9d0316360071c0126a3e2a1b414c32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED t_nmf_error&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_s_t_e_e.html#ga3be5ec4278795dc454cc3d318a4bba1f">EE_RegisterService</a> (t_nmf_channel channel, <a class="el" href="group___n_m_f___s_e_r_v_i_c_e.html#ga1005f1a6cd6f2e941dd1144a5e4c31fa">t_nmf_serviceCallback</a> handler, void *contextHandler)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a service callback to this channel.  <a href="#ga3be5ec4278795dc454cc3d318a4bba1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED t_nmf_error&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_s_t_e_e.html#ga6b580a6c586866d95ab02de8ec5b96f7">EE_UnregisterService</a> (t_nmf_channel channel, <a class="el" href="group___n_m_f___s_e_r_v_i_c_e.html#ga1005f1a6cd6f2e941dd1144a5e4c31fa">t_nmf_serviceCallback</a> handler, void *contextHandler)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister a service callback from this channel.  <a href="#ga6b580a6c586866d95ab02de8ec5b96f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED t_nmf_error&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_s_t_e_e.html#ga258b770ddfe7e8309b4ea8665f77af8d">EE_RegisterNotify</a> (t_nmf_channel channel, <a class="el" href="group___h_o_s_t_e_e.html#ga58fbb06f5b11435effb8bcd479497161">t_nmf_notify</a> notify, void *contextHandler)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregister a notify callback for this channel.  <a href="#ga258b770ddfe7e8309b4ea8665f77af8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED t_nmf_error&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_s_t_e_e.html#gafaad9ab867b6a460174f04ca1990045f">EE_GetMessage</a> (t_nmf_channel channel, void **clientContext, char **message, <a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga95bcce01270fd92083b6d269f921e662">t_bool</a> blockable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get received message from specified callback channel.  <a href="#gafaad9ab867b6a460174f04ca1990045f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___h_o_s_t_e_e.html#ga78ab9efe380edc2bd456bacb9770d9a9">EE_ExecuteMessage</a> (void *itfref, char *message)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute a message. User callback will be execute.  <a href="#ga78ab9efe380edc2bd456bacb9770d9a9"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga1d9d0316360071c0126a3e2a1b414c32"></a><!-- doxytag: member="ee.h::EE_CloseChannel" ref="ga1d9d0316360071c0126a3e2a1b414c32" args="(t_nmf_channel channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED t_nmf_error EE_CloseChannel </td>
          <td>(</td>
          <td class="paramtype">t_nmf_channel&nbsp;</td>
          <td class="paramname"> <em>channel</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregister channel. </p>
<p>The purpose of the function is to:</p>
<ul>
<li>destroy a channel from the user to the Host ee.</li>
</ul>
<p>The user must call EE_UserDone() as many time as EE_UserInit(). At the last EE_UserDone() call, the channel is closed and definitely destroyed All service callback must be unregistered first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>Channel number: </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga508533a1c5fba03ccdaa7f81ff9f1fba"></a><!-- doxytag: member="ee.h::EE_CreateChannel" ref="ga508533a1c5fba03ccdaa7f81ff9f1fba" args="(t_nmf_channel_flag flags, t_nmf_channel *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED t_nmf_error EE_CreateChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group____t__nmf__channel__flag.html#ga673eb84bed6799730e793b5e37439ffc">t_nmf_channel_flag</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_nmf_channel *&nbsp;</td>
          <td class="paramname"> <em>channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a channel for communication between host ee and user. </p>
<p>The purpose of the function is to:</p>
<ul>
<li>create a channel or get a channel, regarding the flag parameter</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Whether the caller want to create a new channel (CHANNEL_PRIVATE) or use the shared one (CHANNEL_PRIVATE) (it will be created if it does not yet exist) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>Channel number.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NMF_NO_MORE_MEMORY</em>&nbsp;</td><td>Not enough memory to create the callback Channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NMF_INVALID_PARAMETER</em>&nbsp;</td><td>The specified flags is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga78ab9efe380edc2bd456bacb9770d9a9"></a><!-- doxytag: member="ee.h::EE_ExecuteMessage" ref="ga78ab9efe380edc2bd456bacb9770d9a9" args="(void *itfref, char *message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED void EE_ExecuteMessage </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>itfref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute a message. User callback will be execute. </p>
<p>This method allow the message retrieved through EE_GetMessage to the right user callback.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>itfref</em>&nbsp;</td><td>Interface reference. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>message</em>&nbsp;</td><td>Reference on buffer to be unmarshalled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2747a37aa0bad5d6cf254ec1d700ddfc"></a><!-- doxytag: member="ee.h::EE_FlushChannel" ref="ga2747a37aa0bad5d6cf254ec1d700ddfc" args="(t_nmf_channel channel, t_bool *isFlushMessageGenerated)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED t_nmf_error EE_FlushChannel </td>
          <td>(</td>
          <td class="paramtype">t_nmf_channel&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga95bcce01270fd92083b6d269f921e662">t_bool</a> *&nbsp;</td>
          <td class="paramname"> <em>isFlushMessageGenerated</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush a channel to allow user to safely close it. </p>
<p>The purpose of the function is to allow safe call of <a class="el" href="group___h_o_s_t_e_e.html#ga1d9d0316360071c0126a3e2a1b414c32" title="Unregister channel.">EE_CloseChannel()</a> later on. Calling <a class="el" href="group___h_o_s_t_e_e.html#ga2747a37aa0bad5d6cf254ec1d700ddfc" title="Flush a channel to allow user to safely close it.">EE_FlushChannel()</a> will allow a blocking call to <a class="el" href="group___h_o_s_t_e_e.html#gafaad9ab867b6a460174f04ca1990045f" title="Get received message from specified callback channel.">EE_GetMessage()</a> to exit with an error NMF_FLUSH_MESSAGE. After <a class="el" href="group___h_o_s_t_e_e.html#gafaad9ab867b6a460174f04ca1990045f" title="Get received message from specified callback channel.">EE_GetMessage()</a> has exit with such a value user must no more call <a class="el" href="group___h_o_s_t_e_e.html#gafaad9ab867b6a460174f04ca1990045f" title="Get received message from specified callback channel.">EE_GetMessage()</a> and can safely call <a class="el" href="group___h_o_s_t_e_e.html#ga1d9d0316360071c0126a3e2a1b414c32" title="Unregister channel.">EE_CloseChannel()</a> that will destroy channel. In case of the share channel <a class="el" href="group___h_o_s_t_e_e.html#ga2747a37aa0bad5d6cf254ec1d700ddfc" title="Flush a channel to allow user to safely close it.">EE_FlushChannel()</a> will return false for isFlushMessageGenerated if it's internal reference counter is not zero, in that case no NMF_FLUSH_MESSAGE error is return by <a class="el" href="group___h_o_s_t_e_e.html#gafaad9ab867b6a460174f04ca1990045f" title="Get received message from specified callback channel.">EE_GetMessage()</a> and user can immediatly call <a class="el" href="group___h_o_s_t_e_e.html#ga1d9d0316360071c0126a3e2a1b414c32" title="Unregister channel.">EE_CloseChannel()</a>. In case user know that no usage of channel is done when he want to destroy channel, call to this api is optionnal and user can safely call <a class="el" href="group___h_o_s_t_e_e.html#ga1d9d0316360071c0126a3e2a1b414c32" title="Unregister channel.">EE_CloseChannel()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>Channel number </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>isFlushMessageGenerated</em>&nbsp;</td><td>Allow user to know if it must wait for NMF_FLUSH_MESSAGE return of <a class="el" href="group___h_o_s_t_e_e.html#gafaad9ab867b6a460174f04ca1990045f" title="Get received message from specified callback channel.">EE_GetMessage()</a> before calling <a class="el" href="group___h_o_s_t_e_e.html#ga1d9d0316360071c0126a3e2a1b414c32" title="Unregister channel.">EE_CloseChannel()</a></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NMF_INVALID_PARAMETER</em>&nbsp;</td><td>The specified flags is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafaad9ab867b6a460174f04ca1990045f"></a><!-- doxytag: member="ee.h::EE_GetMessage" ref="gafaad9ab867b6a460174f04ca1990045f" args="(t_nmf_channel channel, void **clientContext, char **message, t_bool blockable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED t_nmf_error EE_GetMessage </td>
          <td>(</td>
          <td class="paramtype">t_nmf_channel&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>clientContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga95bcce01270fd92083b6d269f921e662">t_bool</a>&nbsp;</td>
          <td class="paramname"> <em>blockable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get received message from specified callback channel. </p>
<p>This method can be used to retrieve callback message from Host ee. Returned message could then be dispatch through EE_ExecuteMessage.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel from which the message must be retrieved </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>clientContext</em>&nbsp;</td><td>client context. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>message</em>&nbsp;</td><td>Reference on buffer to be unmarshalled. The buffer is allocated internally. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blockable</em>&nbsp;</td><td>Indicate if the call could blocked or not.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NMF_NO_MESSAGE</em>&nbsp;</td><td>No waited message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NMF_INVALID_PARAMETER</em>&nbsp;</td><td>At least one input parameters is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga75653620e03cd7cc6cb6dfe29d9d2542"></a><!-- doxytag: member="ee.h::EE_GetVersion" ref="ga75653620e03cd7cc6cb6dfe29d9d2542" args="(t_uint32 *version)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED void EE_GetVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga5543ed798da376a99db035f6ae6aaa1f">t_uint32</a> *&nbsp;</td>
          <td class="paramname"> <em>version</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the version of the NMF Host EE at runtime. </p>
<p>This method should be used to query the version number of the NMF Component Manager engine at runtime. This is useful when using to check if version of the engine linked with application correspond to engine used for development.</p>
<p>Such code can be used to check compatibility: </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga5543ed798da376a99db035f6ae6aaa1f" title="Unsigned 32 bits primitive type.">t_uint32</a> nmfversion;

    <span class="comment">// Print NMF version</span>
    <a class="code" href="group___h_o_s_t_e_e.html#ga75653620e03cd7cc6cb6dfe29d9d2542" title="Get the version of the NMF Host EE at runtime.">EE_GetVersion</a>(&amp;nmfversion);
    LOG(<span class="stringliteral">&quot;NMF Version %d-%d-%d\n&quot;</span>,
            <a class="code" href="group___n_m_f___v_e_r_s_i_o_n.html#ga6ac0268d4461fd28274bbbb308418dfd" title="Get NMF major version corresponding to NMF version number.">VERSION_MAJOR</a>(nmfversion),
            <a class="code" href="group___n_m_f___v_e_r_s_i_o_n.html#ga1caa5ad40816782b54d041fcf54c2cef" title="Get NMF minor version corresponding to NMF version number.">VERSION_MINOR</a>(nmfversion),
            <a class="code" href="group___n_m_f___v_e_r_s_i_o_n.html#gab549dde3257c9732c0b6ffe429c192d1" title="Get NMF patch version corresponding to NMF version number.">VERSION_PATCH</a>(nmfversion));
    <span class="keywordflow">if</span>(<a class="code" href="group___n_m_f___v_e_r_s_i_o_n.html#gaddd0253d832445647cfaaeb40640e225" title="Current NMF version number.">NMF_VERSION</a> != nmfversion) {
        LOG(<span class="stringliteral">&quot;Error: Incompatible API version %d != %d\n&quot;</span>, <a class="code" href="group___n_m_f___v_e_r_s_i_o_n.html#gaddd0253d832445647cfaaeb40640e225" title="Current NMF version number.">NMF_VERSION</a>, nmfversion);
        EXIT();
    }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>version</em>&nbsp;</td><td>Internal hardcoded version (use <a class="el" href="group___n_m_f___v_e_r_s_i_o_n.html#ga6ac0268d4461fd28274bbbb308418dfd">VERSION_MAJOR</a>, <a class="el" href="group___n_m_f___v_e_r_s_i_o_n.html#ga1caa5ad40816782b54d041fcf54c2cef">VERSION_MINOR</a>, <a class="el" href="group___n_m_f___v_e_r_s_i_o_n.html#gab549dde3257c9732c0b6ffe429c192d1">VERSION_PATCH</a> macros to decode it). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga258b770ddfe7e8309b4ea8665f77af8d"></a><!-- doxytag: member="ee.h::EE_RegisterNotify" ref="ga258b770ddfe7e8309b4ea8665f77af8d" args="(t_nmf_channel channel, t_nmf_notify notify, void *contextHandler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED t_nmf_error EE_RegisterNotify </td>
          <td>(</td>
          <td class="paramtype">t_nmf_channel&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___h_o_s_t_e_e.html#ga58fbb06f5b11435effb8bcd479497161">t_nmf_notify</a>&nbsp;</td>
          <td class="paramname"> <em>notify</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>contextHandler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregister a notify callback for this channel. </p>
<p>This method will register a callback that will be call each time a message has been push in queue of the channel. To unregister your callback just register a null notify.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel on which the callback must be registered. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>notify</em>&nbsp;</td><td>The given callback. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>contextHandler</em>&nbsp;</td><td>The context associated with this callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3be5ec4278795dc454cc3d318a4bba1f"></a><!-- doxytag: member="ee.h::EE_RegisterService" ref="ga3be5ec4278795dc454cc3d318a4bba1f" args="(t_nmf_channel channel, t_nmf_serviceCallback handler, void *contextHandler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED t_nmf_error EE_RegisterService </td>
          <td>(</td>
          <td class="paramtype">t_nmf_channel&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___n_m_f___s_e_r_v_i_c_e.html#ga1005f1a6cd6f2e941dd1144a5e4c31fa">t_nmf_serviceCallback</a>&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>contextHandler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a service callback to this channel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel on which the callback must be registered. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handler</em>&nbsp;</td><td>The given callback. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>contextHandler</em>&nbsp;</td><td>The context associated with this callback.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NMF_NO_MORE_MEMORY</em>&nbsp;</td><td>Not enough memory to associate service with the Channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8616ff7112c2797b2fd44487c09f601c"></a><!-- doxytag: member="ee.h::EE_SetMode" ref="ga8616ff7112c2797b2fd44487c09f601c" args="(t_ee_cmd_id aCmdID, t_sint32 aParam)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED t_nmf_error EE_SetMode </td>
          <td>(</td>
          <td class="paramtype">t_ee_cmd_id&nbsp;</td>
          <td class="paramname"> <em>aCmdID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga879ad29618b485db656730acdaae68fa">t_sint32</a>&nbsp;</td>
          <td class="paramname"> <em>aParam</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the mode of the Host EE. </p>
<p>According the (t_ee_cmd_id) value, this routine allows to modify dynamically the behavior of the Host EE.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aCmdID</em>&nbsp;</td><td>Command ID. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aParam</em>&nbsp;</td><td>Parameter of command ID if required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6b580a6c586866d95ab02de8ec5b96f7"></a><!-- doxytag: member="ee.h::EE_UnregisterService" ref="ga6b580a6c586866d95ab02de8ec5b96f7" args="(t_nmf_channel channel, t_nmf_serviceCallback handler, void *contextHandler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED t_nmf_error EE_UnregisterService </td>
          <td>(</td>
          <td class="paramtype">t_nmf_channel&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___n_m_f___s_e_r_v_i_c_e.html#ga1005f1a6cd6f2e941dd1144a5e4c31fa">t_nmf_serviceCallback</a>&nbsp;</td>
          <td class="paramname"> <em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>contextHandler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregister a service callback from this channel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel on which the callback must be registered. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handler</em>&nbsp;</td><td>The given callback. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>contextHandler</em>&nbsp;</td><td>The context associated with this callback.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NMF_INVALID_PARAMETER</em>&nbsp;</td><td>The channel or the callback doesn't exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr size="1">
<address style="align: right;"><small> 
<b>NMF Host Execution Engine Documentation</b> generated by <a href="http://www.doxygen.org">doxygen</a> 1.6.3 on 28 Oct 2011
</small></address>
<address style="align: right;"><small>
Copyright 2006-2009 <a href="http://www.stericsson.com"><b>ST-Ericsson</b></a>
 - Confidential document - Unauthorized reproduction and communication strictly prohibited
</small></address>
</body>
</html>
