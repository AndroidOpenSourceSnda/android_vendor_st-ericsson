/*
 * Copyright (C) ST-Ericsson SA 2010. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 */

#include "AMRWBDecoder.h"
#include "AMRWBDec_BitstreamPort.h"
#include "AMRWBNmfHost_Decoder.h"
#include "AMRWBDec_PcmPort.h"

// UID top dictionnary (generated by trace compiler)
#include "AMRWB_HOST_DEC_top.h"
// TODO FIXME: manage buffers that are not 32-bit multiple  (for Host proxy only)
#define SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES 4 

OMX_ERRORTYPE amrwbhostdecFactoryMethod(ENS_Component_p * ppENSComponent) {
    OMX_ERRORTYPE error  = OMX_ErrorNone;

    AMRWBDecoder *amrwbdec = new AMRWBDecoder(true);
    if (amrwbdec == 0) {
        return OMX_ErrorInsufficientResources;
    }

    error = amrwbdec->construct();

    if (error != OMX_ErrorNone) {
        delete amrwbdec;
        *ppENSComponent = 0;
        return OMX_ErrorInsufficientResources;
    } else {
        *ppENSComponent = amrwbdec;
    }

    AMRWBNmfHost_Decoder *amrwbdec_ProcessingComp = new AMRWBNmfHost_Decoder(*amrwbdec);

    if (amrwbdec_ProcessingComp == 0) {
        delete amrwbdec;
        return OMX_ErrorInsufficientResources;
    }

    amrwbdec->setProcessingComponent(amrwbdec_ProcessingComp);

    return error;
}


OMX_ERRORTYPE AMRWBDecoder::createAMRWBDecBitstreamPort(const OMX_AUDIO_PARAM_AMRTYPE &defaultAmrSettings)
{
#ifdef ANDRO
  OMX_U32 supported_length = getMaxFrameSize();
#else
  OMX_U32 supported_length = getMaxFrameSize()/8;
#endif

  if (mIsHost) {
    supported_length += (SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES - 1);
    supported_length &= ~(SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES - 1);
  }

    AMRWBDec_BitstreamPort *amrwbPort = 
      new AMRWBDec_BitstreamPort(0, OMX_DirInput, supported_length, defaultAmrSettings, *this); 

    if (amrwbPort == 0) {
        return OMX_ErrorInsufficientResources;
    }

    addPort(amrwbPort);
 
   if (mIsHost) {
       //amrwbPort->forceStandardTunneling();
  	    amrwbPort->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);

   }
    return OMX_ErrorNone;
}

OMX_ERRORTYPE  AMRWBDecoder::construct()
{
    OMX_ERRORTYPE error;
    OMX_AUDIO_PARAM_PCMMODETYPE defaultPcmSettings;
    OMX_AUDIO_PARAM_AMRTYPE defaultAmrSettings;

    defaultPcmSettings.nPortIndex     = 1;
    defaultPcmSettings.eNumData       = OMX_NumericalDataSigned;
    defaultPcmSettings.eEndian        = OMX_EndianLittle;
    defaultPcmSettings.bInterleaved   = OMX_TRUE;
    defaultPcmSettings.ePCMMode       = OMX_AUDIO_PCMModeLinear;
    defaultPcmSettings.nBitPerSample  = 16;

    defaultPcmSettings.nChannels      = 1;
    defaultPcmSettings.nSamplingRate  = 16000;

    defaultPcmSettings.eChannelMapping[0] = OMX_AUDIO_ChannelCF;

    defaultAmrSettings.nSize           = sizeof(OMX_AUDIO_PARAM_AMRTYPE);
    getOmxIlSpecVersion(&defaultAmrSettings.nVersion);
    defaultAmrSettings.nPortIndex      = 0;
    defaultAmrSettings.nChannels       = 1;
    defaultAmrSettings.nBitRate        = 23850;
    defaultAmrSettings.eAMRBandMode    = OMX_AUDIO_AMRBandModeWB8;
    defaultAmrSettings.eAMRDTXMode     = OMX_AUDIO_AMRDTXModeOnVAD1;
    defaultAmrSettings.eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;

    error = AFM_Decoder::construct(
            OMX_AUDIO_CodingAMR, getSampleFrameSize(), defaultPcmSettings/*, 1, mIsHost*/);
    if (error != OMX_ErrorNone) return error;

    ENS_String<20> role = "audio_decoder.amrwb";
    role.put((OMX_STRING)mRoles[0]);
    setActiveRole(mRoles[0]);

    error = createAMRWBDecBitstreamPort(defaultAmrSettings);
    if (error != OMX_ErrorNone) return error;

    if (mIsHost) {
        AFM_PcmPort *pcmPort = static_cast<AFM_PcmPort *>(getPort(1));
        //pcmPort->forceStandardTunneling();
   	    pcmPort->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);
    }
    return OMX_ErrorNone;
}

OMX_ERRORTYPE AMRWBDecoder::getExtensionIndex(OMX_STRING cParameterName,
						     OMX_INDEXTYPE* pIndexType) const
{
    if (mIsHost) {
        if (ENS_String<ENS_COMPONENT_NAME_MAX_LENGTH>(cParameterName) 
                == "OMX.ST.AFM.proprietary_communication") {
            return OMX_ErrorNotImplemented;
        }
    }

    return AFM_Component::getExtensionIndex(cParameterName, pIndexType);
}
OMX_ERRORTYPE AMRWBDecoder::createPcmPort(
        OMX_U32 nIndex,
        OMX_DIRTYPE eDir,
        OMX_U32 nBufferSizeMin,
        const OMX_AUDIO_PARAM_PCMMODETYPE &defaultPcmSettings)
{
    ENS_Port * port = new AMRWBDec_PcmPort(
                nIndex, eDir, nBufferSizeMin, defaultPcmSettings, *this);
    if (port == 0) {
        return OMX_ErrorInsufficientResources;
    }

    addPort(port);

    return OMX_ErrorNone;
}
OMX_U32 AMRWBDecoder::getUidTopDictionnary(void)
{
        return KOstAMRWB_HOST_DEC_top_ID;
}

