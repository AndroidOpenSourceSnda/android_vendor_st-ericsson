/*
 * Copyright (C) ST-Ericsson SA 2010. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 */

#include "AMRWBEncoder.h"
#include "AMRWBNmfHost_Encoder.h"
#include "AMRWBEnc_BitstreamPort.h"
#include "AMRWBEnc_PcmPort.h"

#include "audio_chipset_api_index.h"
#include "audio_codecs_chipset_api.h"
// UID top dictionnary (generated by trace compiler)
#include "AMRWB_HOST_ENC_top.h"
// TODO FIXME: manage buffers that are not 32-bit multiple (for Host proxy only)
#define SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES 4

OMX_ERRORTYPE amrwbhostencFactoryMethod(ENS_Component_p * ppENSComponent) {
    OMX_ERRORTYPE error  = OMX_ErrorNone;

    AMRWBEncoder *amrwbenc = new AMRWBEncoder(true);
    if (amrwbenc == 0) {
        return OMX_ErrorInsufficientResources;
    }

    error = amrwbenc->construct();

    if (error != OMX_ErrorNone) {
        delete amrwbenc;
        *ppENSComponent = 0;
        return OMX_ErrorInsufficientResources;
    } else {
        *ppENSComponent = amrwbenc;
    }

    AMRWBNmfHost_Encoder *amrwbenc_ProcessingComp = new AMRWBNmfHost_Encoder(*amrwbenc);

    if (amrwbenc_ProcessingComp == 0) {
        delete amrwbenc;
        return OMX_ErrorInsufficientResources;
    }

    amrwbenc->setProcessingComponent(amrwbenc_ProcessingComp);

    return error;
}

OMX_ERRORTYPE AMRWBEncoder::createAMRWBEncBitstreamPort(const OMX_AUDIO_PARAM_AMRTYPE &defaultAmrSettings)
{
  OMX_U32 supported_length = getMaxFrameSize()/8;

  if (mIsHost) {
    supported_length += (SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES - 1);
    supported_length &= ~(SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES - 1);
  }

    AMRWBEnc_BitstreamPort *amrwbPort =
      new AMRWBEnc_BitstreamPort(1, OMX_DirOutput, supported_length, defaultAmrSettings, *this);

    if (amrwbPort == 0) {
        return OMX_ErrorInsufficientResources;
    }

    addPort(amrwbPort);

   if (mIsHost) {
       //amrwbPort->forceStandardTunneling();
	    amrwbPort->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);

   }

    return OMX_ErrorNone;
}

OMX_ERRORTYPE  AMRWBEncoder::construct()
{
    OMX_ERRORTYPE error;
    OMX_AUDIO_PARAM_PCMMODETYPE defaultPcmSettings;
    OMX_AUDIO_PARAM_AMRTYPE defaultAmrSettings;

    defaultPcmSettings.nPortIndex     = 0;
    defaultPcmSettings.eNumData       = OMX_NumericalDataSigned;
#ifdef ANDRO
    defaultPcmSettings.eEndian        = OMX_EndianLittle;
#else
    defaultPcmSettings.eEndian        = OMX_EndianBig;
#endif
    defaultPcmSettings.bInterleaved   = OMX_TRUE;
    defaultPcmSettings.ePCMMode       = OMX_AUDIO_PCMModeLinear;
    defaultPcmSettings.nBitPerSample  = 16;

    defaultPcmSettings.nChannels      = 1;
    defaultPcmSettings.nSamplingRate  = 16000;

    defaultPcmSettings.eChannelMapping[0] = OMX_AUDIO_ChannelCF;

    defaultAmrSettings.nSize           = sizeof(OMX_AUDIO_PARAM_AMRTYPE);
    getOmxIlSpecVersion(&defaultAmrSettings.nVersion);

    defaultAmrSettings.nPortIndex      = 1;
    defaultAmrSettings.nChannels       = 1;
    defaultAmrSettings.nBitRate        = 23850;
    defaultAmrSettings.eAMRBandMode    = OMX_AUDIO_AMRBandModeWB8;
    defaultAmrSettings.eAMRDTXMode     = OMX_AUDIO_AMRDTXModeOnVAD1;
    defaultAmrSettings.eAMRFrameFormat = OMX_AUDIO_AMRFrameFormatFSF;

    error = AFM_Encoder::construct(
            OMX_AUDIO_CodingAMR, getSampleFrameSize(), defaultPcmSettings/*, 1, mIsHost*/);
    if (error != OMX_ErrorNone) return error;

    ENS_String<20> role = "audio_encoder.amrwb";
    role.put((OMX_STRING)mRoles[0]);
    setActiveRole(mRoles[0]);

    error = createAMRWBEncBitstreamPort(defaultAmrSettings);
    if (error != OMX_ErrorNone) return error;

    if (mIsHost) {
        AFM_PcmPort *pcmPort = static_cast<AFM_PcmPort *>(getPort(0));
        //pcmPort->forceStandardTunneling();
        pcmPort->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);
    }
    return OMX_ErrorNone;
}

OMX_ERRORTYPE AMRWBEncoder::getExtensionIndex(OMX_STRING cParameterName,
						     OMX_INDEXTYPE* pIndexType) const
{
    if (mIsHost) {
        if (ENS_String<ENS_COMPONENT_NAME_MAX_LENGTH>(cParameterName)
                == "OMX.ST.AFM.proprietary_communication") {
            return OMX_ErrorNotImplemented;
        }
    }

    return AFM_Component::getExtensionIndex(cParameterName, pIndexType);
}
OMX_ERRORTYPE AMRWBEncoder::setConfig(
        OMX_INDEXTYPE nConfigIndex,
        OMX_PTR pComponentConfigStructure)
{
    switch (nConfigIndex) {
        case OMX_IndexConfigAudioAmrMode:
            {
                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_AUDIO_CONFIG_AMRMODETYPE);
                OMX_AUDIO_CONFIG_AMRMODETYPE *amrwbConfig =
                    (OMX_AUDIO_CONFIG_AMRMODETYPE *)pComponentConfigStructure;
                AMRWBEnc_BitstreamPort * BSPort;
                //OMX_AUDIO_AMRDTXMODETYPE Dtx;

                if (amrwbConfig->nPortIndex != 1){
                    return OMX_ErrorBadParameter;
                }

                BSPort = static_cast<AMRWBEnc_BitstreamPort *>(getPort(1));
                return BSPort->setBitRate(amrwbConfig->eAMRBandMode);
            }

        default:
            return AFM_Encoder::setConfig(
                    nConfigIndex, pComponentConfigStructure);
    }
}


OMX_ERRORTYPE AMRWBEncoder::getConfig(
        OMX_INDEXTYPE nConfigIndex,
        OMX_PTR pComponentConfigStructure) const
{
    OMX_ERRORTYPE error;
    switch (nConfigIndex) {
        case OMX_IndexConfigAudioAmrMode:
            {
                const AMRWBEnc_BitstreamPort * BSPort = static_cast<const AMRWBEnc_BitstreamPort *>(getPort(1));
                OMX_AUDIO_PARAM_AMRTYPE amrwbOmxParams;
                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_AUDIO_CONFIG_AMRMODETYPE);
                OMX_AUDIO_CONFIG_AMRMODETYPE *amrwbConfig =
                    (OMX_AUDIO_CONFIG_AMRMODETYPE *)pComponentConfigStructure;

                if (amrwbConfig->nPortIndex != 1){
                    return OMX_ErrorBadParameter;
                }

                amrwbOmxParams.nSize           = sizeof(OMX_AUDIO_PARAM_AMRTYPE);
                getOmxIlSpecVersion(&amrwbOmxParams.nVersion);

                error = BSPort->getParameter(OMX_IndexParamAudioAmr, &amrwbOmxParams);
                if (error != OMX_ErrorNone) return error;

                amrwbConfig->eAMRBandMode = amrwbOmxParams.eAMRBandMode;

                return OMX_ErrorNone;
            }

        default:
            return AFM_Encoder::getConfig(
                    nConfigIndex, pComponentConfigStructure);
    }
}

OMX_ERRORTYPE AMRWBEncoder::createPcmPort(
        OMX_U32 nIndex,
        OMX_DIRTYPE eDir,
        OMX_U32 nBufferSizeMin,
        const OMX_AUDIO_PARAM_PCMMODETYPE &defaultPcmSettings)
{
    ENS_Port * port = new AMRWBEnc_PcmPort(
                nIndex, eDir, nBufferSizeMin, defaultPcmSettings, *this);
    if (port == 0) {
        return OMX_ErrorInsufficientResources;
    }

    addPort(port);

    return OMX_ErrorNone;
}
OMX_U32 AMRWBEncoder::getUidTopDictionnary(void)
{
        return KOstAMRWB_HOST_ENC_top_ID;
}
