/* 
 * Copyright (C) ST-Ericsson SA 2010. All rights reserved. 
 * This code is ST-Ericsson proprietary and confidential. 
 * Any use of the code for whatever purpose is subject to 
 * specific written permission of ST-Ericsson SA. 
 */ 
 
#ifndef _CRMhwReg_
#define _CRMhwReg_

#include "Platform.h"



//CRM_EN_CLK_SD_HISPEED
/*Description: Enable the clock clk_sd_hispeed for fast sensor raw Bayer frames capture up to the maximum CSI-2 interface data rate. This clock is used to activate MIPI CSI-2 RX, SDG, ISP RX front-end receiver datapath, and first BMS output location, i.e. before line blanking elimination.

Hard reset is 0, i.e. disabled clock.

Maximum clk_sd_hispeed clock frequency is 400 MHz.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t EN_CLK_SD_HISPEED_T1_STBUS :1;
        uint8_t EN_CLK_SD_HISPEED_DATA :1;
    }CRM_EN_CLK_SD_HISPEED_ts;

}CRM_EN_CLK_SD_HISPEED_tu;



//CRM_EN_CLK_SD_LOSPEED
/*Description: Enable the clock clk_sd_lospeed. This clock is used as a clock write for ISP LBE stage, i.e. line blanking elimination, when the ISP post LBE back-end part is concurrently activated via a smoother and slower clock clk_pipe (until 200Mhz).

Since the LBE buffering enables to increase of 33% the input maximum pixel rate, maximum clk_sd_lospeed clock frequency is 266 MHz.

Hard reset is 0, i.e. disabled clock
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t EN_CLK_SD_LOSPEED_T1_STBUS :1;
        uint8_t EN_CLK_SD_LOSPEED_DATA :1;
    }CRM_EN_CLK_SD_LOSPEED_ts;

}CRM_EN_CLK_SD_LOSPEED_tu;



//CRM_EN_CLK_PIPE
/*Description: Enable the clock clk_pipe. This clock is used to activate the ISP post LBE stage.

Maximum clock frequency of clk_pipe is 200 MHz.

Hard reset is 0, i.e. disabled clock
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t EN_CLK_PIPE_T1_STBUS :1;
        uint8_t EN_CLK_PIPE_RE_DATA :1;
        uint8_t EN_CLK_PIPE_DMCE_DATA :1;
        uint8_t EN_CLK_PIPE_CE0_DATA :1;
        uint8_t EN_CLK_PIPE_CE1_DATA :1;
        uint8_t EN_CLK_PIPE_STATS_DATA :1;
        uint8_t EN_CLK_PIPE_DXO :1;
    }CRM_EN_CLK_PIPE_ts;

}CRM_EN_CLK_PIPE_tu;



//CRM_EN_CLK_BML
/*Description: Enable the clock clk_bml for the BML (and RML) modules.

Hard reset is 0, i.e. disabled clock.

Maximum clk_bml clock frequency is 200 MHz.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t EN_CLK_BML :1;
    }CRM_EN_CLK_BML_ts;

}CRM_EN_CLK_BML_tu;



//CRM_EN_CLK_BMS
/*Description: Enable the clock clk_bms for the BMS module.

Hard reset is 0, i.e. disabled.

Maximum clk_bms clock frequency is 400 MHz.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t EN_CLK_BMS :1;
    }CRM_EN_CLK_BMS_ts;

}CRM_EN_CLK_BMS_tu;



//CRM_EN_CLK_PIPE_IN
/*Description: Enable the clock clk_pipe_in for the CRM module (internal). This clock is generated by the STW8500 top-level clock generator.

On the contrary of the others CRM registers CRM_EN_CLK* which are specifically to enable/disable any CRM destination clock (clk_sd_lospeed, clk_sd_hispeed, clk_pipe, clk_bml, clk_bms), this register is used only internally by the CRM to locally gate the clock clk_pipe_in.

This register is used to safely gate internally the source clock clk_pipe_in, inside the CRM, before switching any destination clock from this clock clk_pipe_in to another potential source clock, which can be either the sensor pixel clock -emulated or not-, or the clk_host_ipp.

Hard reset is 0, i.e. disabled.

Maximum clk_pipe_in clock frequency is 200 MHz.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t EN_CLK_PIPE_IN :1;
    }CRM_EN_CLK_PIPE_IN_ts;

}CRM_EN_CLK_PIPE_IN_tu;



//CRM_EN_CLK_PICTOR_GPIO
/*Description: Enable the clock clk_pictor_gpio for the ISP GPIO sub-module. This clock is used by the ISP Pictor to control via GPIOs external devices (typically use is flash and camera module shutdown).

Hard reset is 0, i.e. disabled.

Maximum clk_pictor_gpio clock frequency is 200 MHz.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t EN_CLK_PICTOR_GPIO :1;
    }CRM_EN_CLK_PICTOR_GPIO_ts;

}CRM_EN_CLK_PICTOR_GPIO_tu;



//CRM_CLK_PIPE_IN_DIV
/*Description: Set the value for the clk_pipe_in clock division. This clk_pipe_in is generated by the STW8500 clock generator. Although this is used when the ISP is driven by a clock coming from the host and then clk_pipe_in has nothing in common with any sensor clock CCP or CSI, the underlying HW clock divider is reused from the clock dividers used for the CSI and CCP clock manager, in order to have fine steps between 1and 3.5 clock division values, for extra flexibility.

The clock divison is set via a specific encoding as described below in the table.

The two msb bits represent the integer part.

The three lsb bits represent the fractional part via a specific encoding, in order to align both the possible number of data lanes (1, 2, or 3) and the possible supported number of bits per pixel (6, 7, 8, 10, or 12). Therefore there are only a restricted set of values to be supported, all values being either a multiple of 1/4 or 1/6.

Hard reset is 0x8, i.e. clock divsion equal to 1.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t CLK_PIPE_IN_DIV :5;
        /* 
        5'b01_00_0 : 1
        5'b01_00_1: 7/6 (1.16...)
        5'b01_01_0: 8/6 (1.33...)
        5'b01_10_0: 6/4 (1.5)
        5'b01_10_1: 10/6 (1.66
        5'b01_11_0: 7/4 (1.75)
        5'b10_00_0: 2
        5'b10_10_0: 10/4 (2.5)
        5'b11_10_0: 14/4 (3.5)*/
    }CRM_CLK_PIPE_IN_DIV_ts;

}CRM_CLK_PIPE_IN_DIV_tu;



//CRM_CLK_HOST_IPP_DIV
/*Description: This integer division is used to generate a destination clock (clk_sd_lospeed, clk_sd_hispeed, clk_clk_pipe, clk_bms, clk_bml) from the clk_host_ipp clock.

This clock is a dummy source clock for the potential destination clocks (c.f. the settings CRM_CLK_***_SOURCE_SEL. When the destination datapaths of the modules like BMS, BML, or related ISP sub-modules are supposed to be inactive, a dummy clock must be provided so that any of their HW registers can be accessed by CPUs (xP70/MMDSP/ARM).

If the integer division is set to 0 or 1, then the divided clock from the clk_host_ipp is gated. Maximum frequency of the divided clk_host_ipp clock is 100 Mhz.

Hard reset value is 0, i.e. gated divided clk_host_ipp.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t CLK_HOST_IPP_DIV :7;
    }CRM_CLK_HOST_IPP_DIV_ts;

}CRM_CLK_HOST_IPP_DIV_tu;



//CRM_CLK_PICTOR_GPIO_DIV
/*Description: This integer division is used to generate the clk_pictor_gpio clock.

If the integer division is set to 0 or 1, then the divided clock is gated.

Maximum frequency of the divided clk_pictor_gpio clock is 200 Mhz.

According to the selected source clock via the register CRM_CLK_PICTOR_GPIO_SOURCE_SEL, the resulting frequency of the clk_pictor_gpio is the product of this integer division clk_pictor_gpio_div by one of the three first division ratio i.e.

Hard reset value is 0, i.e. gated divided clk_pictor_gpio.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t CLK_PICTOR_GPIO_DIV :7;
    }CRM_CLK_PICTOR_GPIO_DIV_ts;

}CRM_CLK_PICTOR_GPIO_DIV_tu;



//CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV
/*Description: Static register used to set the CCP fixed point division and generate to the sensor datapath SDG, ISP, and BMS, a pixel clock which is derived from the ccp_clk, provided by the CCP secondary camera.

This static register must be written only when IPP_TOP_DATA_IF.top_if_en=0, i.e. disabled clock from high speed receiver of DPHYs in subLVDS mode.

This static register is to be used accordingly to the IPP_CCP_IF value when IPP_TOP_DATA_IF.top_if_sel[1:0]=2'b1X (input sensor is the CCP secondary camera).

This register has no impact on the camera datapath, since CDG and IFP are not requiring any pixel clock.

Hard reset value is 0x8, encoding a CCP pixel clock division of 4, i.e. CCP in data/strobe mode with 8 bits per pixel..
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t STATIC_SD_CCP_PIXEL_CLOCK_DIV :5;
        /* 
        valid values are:
        5'b0011_0: 3
        5'b0011_1: 3.5
        5'b0100_0: 4
        5'b0101_0: 5
        5'b0110_0: 6
        5'b0111_0: 7
        5'b1000_0: 8
        5'b1010_0: 10
        5'b1100_0: 12*/
    }CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV_ts;

}CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV_tu;



//CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL
/*Description: Static register to select the source clock for the generation of the clk_sd_hispeed, either from the sensor pixel clock, the divided clk_pipe_in, or the divided clk_host_ipp.

Note that the sensor pixel clock can be also the emulated clock (and then derived from the clk_host_ipp). In that case, there is no need to update this register. HW automatically operates a safe switch via the FW command to the CRM_EMUL_SENSOR_CLOCK register.

This static register must be written to switch from a current source clock to a next source clock after that:

Then typically FW should enable the clk_sd_hispeed clock by setting CRM_EN_CLK_SD_HISPEED=1.

Hard reset value is 0, i.e. clk_sd_hispeed is derived from the emulated pixel sensor clock.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t STATIC_CLK_SD_HISPEED_SOURCE_SEL :2;
        /* 
        1x: divided clk_host_ipp (e.g. when BML)*/
    }CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL_ts;

}CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL_tu;



//CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL
/*Description: Static register to select the source clock for the generation of the clk_sd_lospeed, either from the sensor pixel clock, the divided clk_pipe_in, or the divided clk_host_ipp.

Note that the sensor pixel clock can be also the emulated clock (and then derived from the clk_host_ipp). In that case, there is no need to update this register. HW automatically operates a safe switch via the FW command to the CRM_EMUL_SENSOR_CLOCK register.

This static register must be written to switch from a current source clock to a next source clock after that:

Then typically FW should enable the clk_sd_lospeed clock by setting CRM_EN_CLK_SD_LOSPEED=1.

Hard reset value is 0, i.e. clk_sd_lospeed is derived from the emulated pixel sensor clock.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t STATIC_CLK_SD_LOSPEED_SOURCE_SEL :2;
        /* 
        1x: divided clk_host_ipp (e.g. when BMS from Bayer Store 0)*/
    }CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL_ts;

}CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL_tu;



//CRM_STATIC_CLK_PIPE_SOURCE_SEL
/*Description: Static register to select the source clock for the generation of the clk_pipe, either from the sensor pixel clock, the divided clk_pipe_in, or the divided clk_host_ipp.

Note that the sensor pixel clock can be also the emulated clock (and then derived from the clk_host_ipp). In that case, there is no need to update this register. HW automatically operates a safe switch via the FW command to the CRM_EMUL_SENSOR_CLOCK register.

This static register must be written to switch from a current source clock to a next source clock after that:

Then typically FW should enable the clk_pipe by setting CRM_EN_CLK_PIPE=1.

Hard reset value is 0, i.e. clk_pipe is derived from the emulated sensor pixel clock.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t STATIC_CLK_PIPE_SOURCE_SEL :2;
        /* 
        1x: divided clk_host_ipp (e.g. when BMS from Bayer Store 0)*/
    }CRM_STATIC_CLK_PIPE_SOURCE_SEL_ts;

}CRM_STATIC_CLK_PIPE_SOURCE_SEL_tu;



//CRM_STATIC_CLK_BMS_SOURCE_SEL
/*Description: Static register to select the source clock for the generation of the clk_bms, either from the sensor pixel clock, the divided clk_pipe_in, or the divided clk_host_ipp.

Note that the sensor pixel clock can be also the emulated clock (and then derived from the clk_host_ipp). In that case, there is no need to update this register. HW automatically operates a safe switch via the FW command to the CRM_EMUL_SENSOR_CLOCK or CRM_EMUL_SENSOR_CLOCK_3D registers, depending on whether "legacy" or "simultaneous capture" use case is in place.

This static register must be written to switch from a current source clock to a next source clock after that:

Then typically FW should enable the clk_bms by setting CRM_EN_CLK_BMS=1.

Hard reset value is 0, i.e. clk_pipe is derived from the emulated sensor pixel clock.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t STATIC_CLK_BMS_SOURCE_SEL :2;
        /* 
        1x: divided clk_host_ipp (e.g when ISP on-the fly w/o BMS)*/
    }CRM_STATIC_CLK_BMS_SOURCE_SEL_ts;

}CRM_STATIC_CLK_BMS_SOURCE_SEL_tu;



//CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL
/*Description: Static register to select the source clock for the generation of the clk_pictor_gpio, either from the sensor pixel clock (typical configuration), the divided clk_pipe_in, or the divided clk_host_ipp.

Note that the sensor pixel clock can be also the emulated clock (and then derived from the clk_host_ipp). In that case, there is no need to update this register. HW automatically operates a safe switch via the FW command to the CRM_EMUL_SENSOR_CLOCK register.

This static register must be written to switch from a current source clock to a next source clock after that:

Then typically FW should enable the clk_pictor_gpio by setting CRM_EN_CLK_PICTOR_GPIO=1.

Hard reset value is 0, i.e. clk_pictor_gpio is derived from the emulated sensor pixel clock.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t STATIC_CLK_PICTOR_GPIO_SOURCE_SEL :2;
        /* 
        1x: divided clk_host_ipp*/
    }CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_ts;

}CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_tu;



//CRM_EMUL_SENSOR_CLOCK
/*Description: Emulate the sensor clock, for CCP0, CCP1, CSI0 or CSI1 sensor by the clock clk_host_ipp/clk_host_ipp_div (active high).Hard reset is 1: emulated clock
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t EMUL_SENSOR_CLOCK :1;
    }CRM_EMUL_SENSOR_CLOCK_ts;

}CRM_EMUL_SENSOR_CLOCK_tu;



//CRM_CHECKER_LOST_EN_CTRL_N
/*Description: Enable the clock checker for monitoring the loss/stop of the top_if_sel[1:0] sensor clock (CCP0, CSI0 or CSI1 in an exclusive way). If so, then the register CRM_CHECKER_ITS status is updated and provided that the interrupt mask register CRM_CHECKER_ITM is set, an crm_checker_irq is triggered. Hard reset value is 0 (enabled).
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t CHECKER_LOST_EN_CTRL_N :1;
    }CRM_CHECKER_LOST_EN_CTRL_N_ts;

}CRM_CHECKER_LOST_EN_CTRL_N_tu;



//DEPRECATED2
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint32_t DEPRECATED;
        /* , default to 0*/
    }DEPRECATED2_ts;

}DEPRECATED2_tu;



//CRM_CHECKER_ITS
/*Description: Reading this register after an enabled interrupt crm_checker_irq was triggered, provides to the SW information about the interrupt source root cause, whether it is a sensor clock detection (ckc_ok_its=1) or a sensor clock loss (ckc_lost_its=1).

In case of a sensor clock detection, then FW can be guaranteed that the sensor is streaming. More precisely the clock checker detects the top_if_sel[1:0] clock was started/awaken, i.e. there was at leat one first active sensor clock edge for a time window width equal to VPBUS_CKC_DETECT_WDW (unit is XXX clock cycles).

Then the FW can ask the HW to switch off safely from the emulated clock (FW writes CRM_EMUL_SENSOR_CLOCK=0) and to go for streaming from the top_if_sel[1:0] clock sensor.

In case of a sensor clock lost (provided that the register CRM_CHECKER_LOST_EN_CTRL_N was enabled), typically FW can be acknowledged that the sensor has safely swiched off after a standby CCI command. On top of that, the clock checker is able to monitor continuously the sensor clock and can alarm the FW that the CCP/CSI clock has been lost from the 8500 SIA receiver side, in order to possibly recover and escape from this blocking stage.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t CKC_OK_ITS :1;
        uint8_t CKC_LOST_ITS :1;
        uint8_t CKC_OK_3D_ITS :1;
        uint8_t CKC_LOST_3D_ITS :1;
    }CRM_CHECKER_ITS_ts;

}CRM_CHECKER_ITS_tu;



//CRM_CHECKER_ITS_BCLR
/*Description: Writing 1 to this bit register clears the interrupt status CRM_CHECKER_ITS.

Writing 0 has no impact.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t CKC_OK_ITS_BCLR :1;
        uint8_t CKC_LOST_ITS_BCLR :1;
        uint8_t CKC_OK_3D_ITS_BCLR :1;
        uint8_t CKC_LOST_3D_ITS_BCLR :1;
    }CRM_CHECKER_ITS_BCLR_ts;

}CRM_CHECKER_ITS_BCLR_tu;



//CRM_CHECKER_ITS_BSET
/*Description: Writing 1 to this bit register sets the interrupt status CRM_CHECKER_ITS.

Writing 0 has no impact.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t CKC_OK_ITS_BSET :1;
        uint8_t CKC_LOST_ITS_BSET :1;
        uint8_t CKC_OK_3D_ITS_BSET :1;
        uint8_t CKC_LOST_3D_ITS_BSET :1;
    }CRM_CHECKER_ITS_BSET_ts;

}CRM_CHECKER_ITS_BSET_tu;



//CRM_CHECKER_ITM
/*Description: This register is the interrupt bit mask read register for the the irp_sensor_irq line.

When bit value is 0 the interrupt source is disabled/masked, when bit value is 1 the interrupt source is enabled.

Hard reset is 0, i.e. disabled interrupt line.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t CKC_OK_ITM :1;
        uint8_t CKC_LOST_ITM :1;
        uint8_t CKC_OK_3D_ITM :1;
        uint8_t CKC_LOST_3D_ITM :1;
    }CRM_CHECKER_ITM_ts;

}CRM_CHECKER_ITM_tu;



//CRM_CHECKER_ITM_BCLR
/*Description: Writing 1 to this bit mask register clears the bit interrupt mask CRM_CHECKER_ITM.

Writing 0 has no impact.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t CKC_OK_ITM_BCLR :1;
        uint8_t CKC_LOST_ITM_BCLR :1;
        uint8_t CKC_OK_3D_ITM_BCLR :1;
        uint8_t CKC_LOST_3D_ITM_BCLR :1;
    }CRM_CHECKER_ITM_BCLR_ts;

}CRM_CHECKER_ITM_BCLR_tu;



//CRM_CHECKER_ITM_BSET
/*Description: Writing 1 to this bit mask register sets the bit interrupt status mask CRM_CHECKER_ITM.

Writing 0 has no impact.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t CKC_OK_ITM_BSET :1;
        uint8_t CKC_LOST_ITM_BSET :1;
        uint8_t CKC_OK_3D_ITM_BSET :1;
        uint8_t CKC_LOST_3D_ITM_BSET :1;
    }CRM_CHECKER_ITM_BSET_ts;

}CRM_CHECKER_ITM_BSET_tu;



//CRM_CHECKER_DETECT_WDW
/*Description: The clock CCP, CSI0, or CSI1 detection requires a parametrable window of detection to be aligned with the frequency of the clock to detect.

The equation to respect is the following where Fhost is the clk_host frequency and Fin is the top_if_sel[1:0] clock to detect.

First constraint is: Fin > 4Fhost / (CRM_CHECKER_DETECT_WDW +1)

equivalent to CRM_CHECKER_DETECT_WDW > (4Fhost/Fin) -1.

Hard reset value is 9.

With this default value and Fhost = 200 Mhz, an input clock above 80 Mhz can be detected.

With the maximum value , (1023) , an input clock above 780 khz can be detected.

There is another design constraint concerning the Fhost and Fin value, the counter counting the active edges occurences of the top_if_sel[1:0] clock must not overflow.

If D is the sensor_count of clk_sensor_for_ckc maximum value, then

Fin < DFhost/(CRM_CHECKER_DETECT_WDW +1).

Given that D = 255

Fin < 255.Fhost/(CRM_CHECKER_DETECT_WDW +1)

Finally with reset value and Fhost = 200 MHz

80 MHz < Fin < 5.1 GHz

There are two clock checkers in the SIA, to support simultaneous capture use cases: the CRM_CHECKER_DETECT_WDW is used to configure the detection time window for both cameras.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint16_t CKC_DETECT_WDW :11;
    }CRM_CHECKER_DETECT_WDW_ts;

}CRM_CHECKER_DETECT_WDW_tu;



//CRM_EMUL_SENSOR_CLOCK_3D
/*Description: Emulate the sensor clock, for CSI0 (1DL only) or CSI1 sensor by the clock clk_host_ipp/clk_host_ipp_div (active high). This register is used to switch clock from sensor (the "concurrent camera") clock to emulated clock for SMIA_RX_3D and BMS modules in case of "simultaneous camera operation". Note than in "legacy" use cases (not involving two simultaneous captures), the BMS clock switching is operated using CRM_EMUL_SENSOR_CLOCK instead.

Hard reset is 1: emulated clock
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t EMUL_SENSOR_CLOCK_3D :1;
    }CRM_EMUL_SENSOR_CLOCK_3D_ts;

}CRM_EMUL_SENSOR_CLOCK_3D_tu;



//CRM_EN_CLK_SD_3D_HISPEED
/*Description: Enable the clock clk_sd_3d_hispeed for fast sensor raw Bayer frames capture up to the maximum CSI-2 interface data rate. This clock is used to activate MIPI CSI-2 RX 3D, SDG 3D , ISP RX 3D front-end receiver datapath, and first BMS output location, i.e. before line blanking elimination.

Hard reset is 0, i.e. disabled clock.

Maximum clk_sd_hispeed clock frequency is 400 MHz.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t EN_CLK_SD_3D_HISPEED_T1_STBUS :1;
        uint8_t EN_CLK_SD_3D_HISPEED_DATA :1;
    }CRM_EN_CLK_SD_3D_HISPEED_ts;

}CRM_EN_CLK_SD_3D_HISPEED_tu;



//CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL
/*Description: Static register to select the source clock for the generation of the clk_sd_3d_hispeed, either from the sensor pixel clock, the divided clk_pipe_in, or the divided clk_host_ipp.

Note that the sensor pixel clock can be also the emulated clock (and then derived from the clk_host_ipp). In that case, there is no need to update this register. HW automatically operates a safe switch via the FW command to the CRM_EMUL_SENSOR_CLOCK_3D register.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL :2;
        /* 
        1x: divided clk_host_ipp (e.g. when BML*/
    }CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_ts;

}CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_tu;



//CRM_STATIC_BMS_CSI2_SEL
/*Description: Static register to select the source clock for the generation of the clk_sd_3d_hispeed, either from the sensor pixel clock, the divided clk_pipe_in, or the divided clk_host_ipp.

Note that the sensor pixel clock can be also the emulated clock (and then derived from the clk_host_ipp). In that case, there is no need to update this register. HW automatically operates a safe switch via the FW command to the CRM_EMUL_SENSOR_CLOCK_3D register.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t STATIC_BMS_CSI2_SEL :1;
        /* CSI2RX to BMS*/
    }CRM_STATIC_BMS_CSI2_SEL_ts;

}CRM_STATIC_BMS_CSI2_SEL_tu;



//CRM_CLK_SD_HISPEED_SOURCE_STATUS
/*Description: Read status register for the current source clock of the generation of the clk_sd_hispeed.

This register should be typically read during the clock switching SW procedure for the clock source for the generation of the clk_sd_hispeed, for both 'manual' switching mode when writing to the CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL, or for 'automatic' switching mode when writing to the CRM_EMUL_SENSOR_CLOCK. So that the SW can be informed that the HW clock switching has been completed.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS :2;
        /* sensor pixel clock*/
        uint8_t reserved0 :6;
        uint8_t CRM_CLK_SD_HISPEED_ENABLED_SOURCE_STATUS :3;
        /* 
        bit10: enabled sensor pixel clock
        bit9: enabled divided clk_pipe_in
        bit8: enabled divided clk_host_ipp*/
    }CRM_CLK_SD_HISPEED_SOURCE_STATUS_ts;

}CRM_CLK_SD_HISPEED_SOURCE_STATUS_tu;



//CRM_CLK_SD_LOSPEED_SOURCE_STATUS
/*Description: Read status register for the current source clock of the generation of the clk_sd_lospeed.

This register should be typically read during the clock switching SW procedure for the clock source for the generation of the clk_sd_hispeed, for both 'manual' switching mode when writing to the CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL, or for 'automatic' switching mode when writing to the CRM_EMUL_SENSOR_CLOCK. So that the SW can be informed that the HW clock switching has been completed.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS :2;
        /* sensor pixel clock*/
        uint8_t reserved0 :6;
        uint8_t CRM_CLK_SD_LOSPEED_ENABLED_SOURCE_STATUS :3;
        /* 
        bit10: enabled sensor pixel clock
        bit9: enabled divided clk_pipe_in
        bit8: enabled divided clk_host_ipp*/
    }CRM_CLK_SD_LOSPEED_SOURCE_STATUS_ts;

}CRM_CLK_SD_LOSPEED_SOURCE_STATUS_tu;



//CRM_CLK_PIPE_SOURCE_STATUS
/*Description: Read status register for the current source clock of the generation of the clk_pipe.

This register should be typically read during the clock switching SW procedure for the clock source for the generation of the clk_sd_hispeed, for both 'manual' switching mode when writing to the CRM_STATIC_CLK_PIPE_SOURCE_SEL, or for 'automatic' switching mode when writing to the CRM_EMUL_SENSOR_CLOCK. So that the SW can be informed that the HW clock switching has been completed.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t CRM_CLK_PIPE_SELECTED_SOURCE_STATUS :2;
        /* sensor pixel clock*/
        uint8_t reserved0 :6;
        uint8_t CRM_CLK_PIPE_ENABLED_SOURCE_STATUS :3;
        /* 
        bit10: enabled sensor pixel clock
        bit9: enabled divided clk_pipe_in
        bit8: enabled divided clk_host_ipp*/
    }CRM_CLK_PIPE_SOURCE_STATUS_ts;

}CRM_CLK_PIPE_SOURCE_STATUS_tu;



//CRM_CLK_BMS_SOURCE_STATUS
/*Description: Read status register for the current source clock of the generation of the clk_bms.

This register should be typically read during the clock switching SW procedure for the clock source for the generation of the clk_sd_hispeed, for both 'manual' switching mode when writing to the CRM_STATIC_CLK_BMS_SOURCE_SEL, or for 'automatic' switching mode when writing to the CRM_EMUL_SENSOR_CLOCK. So that the SW can be informed that the HW clock switching has been completed.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t CRM_CLK_BMS_SELECTED_SOURCE_STATUS :2;
        /* sensor pixel clock*/
        uint8_t reserved0 :6;
        uint8_t CRM_CLK_BMS_ENABLED_SOURCE_STATUS :3;
        /* 
        bit10: enabled sensor pixel clock
        bit9: enabled divided clk_pipe_in
        bit8: enabled divided clk_host_ipp*/
    }CRM_CLK_BMS_SOURCE_STATUS_ts;

}CRM_CLK_BMS_SOURCE_STATUS_tu;



//CRM_CLK_PICTOR_GPIO_SOURCE_STATUS
/*Description: Read status register for the current source clock of the generation of the clk_bms.

This register should be typically read during the clock switching SW procedure for the clock source for the generation of the clk_sd_hispeed, for both 'manual' switching mode when writing to the CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL, or for 'automatic' switching mode when writing to the CRM_EMUL_SENSOR_CLOCK. So that the SW can be informed that the HW clock switching has been completed.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS :2;
        /* sensor pixel clock*/
        uint8_t reserved0 :6;
        uint8_t CRM_CLK_PICTOR_GPIO_ENABLED_SOURCE_STATUS :3;
        /* 
        bit10: enabled sensor pixel clock
        bit9: enabled divided clk_pipe_in
        bit8: enabled divided clk_host_ipp*/
    }CRM_CLK_PICTOR_GPIO_SOURCE_STATUS_ts;

}CRM_CLK_PICTOR_GPIO_SOURCE_STATUS_tu;



//CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS
/*Description: Read status register for the current source clock of the generation of the clk_sd_3d_hispeed.

This register should be typically read during the clock switching SW procedure for the clock source for the generation of the clk_sd_hispeed, for both 'manual' switching mode when writing to the CRM_STATIC_SD_3D_HISPEED_SOURCE_SEL, or for 'automatic' switching mode when writing to the CRM_EMUL_SENSOR_CLOCK. So that the SW can be informed that the HW clock switching has been completed.
*/
typedef union
{
    uint32_t word;
    uint32_t data;
    struct
    {
        uint8_t CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS :2;
        /* sensor pixel clock (not in emulated clock mode)*/
        uint8_t reserved0 :6;
        uint8_t CRM_CLK_SD_3D_HISPEED_ENABLED_SOURCE_STATUS :3;
        /* 
        bit10: enabled sensor pixel clock (not in emulated clock mode)
        bit9: enabled divided clk_pipe_in clock
        bit8: enabled divided clk_host_ipp*/
    }CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS_ts;

}CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS_tu;

typedef struct
{
    CRM_EN_CLK_SD_HISPEED_tu CRM_EN_CLK_SD_HISPEED;
    CRM_EN_CLK_SD_LOSPEED_tu CRM_EN_CLK_SD_LOSPEED;
    CRM_EN_CLK_PIPE_tu CRM_EN_CLK_PIPE;
    CRM_EN_CLK_BML_tu CRM_EN_CLK_BML;
    CRM_EN_CLK_BMS_tu CRM_EN_CLK_BMS;
    CRM_EN_CLK_PIPE_IN_tu CRM_EN_CLK_PIPE_IN;
    CRM_EN_CLK_PICTOR_GPIO_tu CRM_EN_CLK_PICTOR_GPIO;
    CRM_CLK_PIPE_IN_DIV_tu CRM_CLK_PIPE_IN_DIV;
    CRM_CLK_HOST_IPP_DIV_tu CRM_CLK_HOST_IPP_DIV;
    CRM_CLK_PICTOR_GPIO_DIV_tu CRM_CLK_PICTOR_GPIO_DIV;
    CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV_tu CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV;
    CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL_tu CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL;
    CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL_tu CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL;
    CRM_STATIC_CLK_PIPE_SOURCE_SEL_tu CRM_STATIC_CLK_PIPE_SOURCE_SEL;
    CRM_STATIC_CLK_BMS_SOURCE_SEL_tu CRM_STATIC_CLK_BMS_SOURCE_SEL;
    CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_tu CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL;
    uint32_t pad_CRM_EMUL_SENSOR_CLOCK[4];
    CRM_EMUL_SENSOR_CLOCK_tu CRM_EMUL_SENSOR_CLOCK;
    CRM_CHECKER_LOST_EN_CTRL_N_tu CRM_CHECKER_LOST_EN_CTRL_N;
    DEPRECATED2_tu DEPRECATED2;
    CRM_CHECKER_ITS_tu CRM_CHECKER_ITS;
    CRM_CHECKER_ITS_BCLR_tu CRM_CHECKER_ITS_BCLR;
    CRM_CHECKER_ITS_BSET_tu CRM_CHECKER_ITS_BSET;
    CRM_CHECKER_ITM_tu CRM_CHECKER_ITM;
    CRM_CHECKER_ITM_BCLR_tu CRM_CHECKER_ITM_BCLR;
    CRM_CHECKER_ITM_BSET_tu CRM_CHECKER_ITM_BSET;
    CRM_CHECKER_DETECT_WDW_tu CRM_CHECKER_DETECT_WDW;
    CRM_EMUL_SENSOR_CLOCK_3D_tu CRM_EMUL_SENSOR_CLOCK_3D;
    uint32_t pad_CRM_EN_CLK_SD_3D_HISPEED;
    CRM_EN_CLK_SD_3D_HISPEED_tu CRM_EN_CLK_SD_3D_HISPEED;
    CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_tu CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL;
    CRM_STATIC_BMS_CSI2_SEL_tu CRM_STATIC_BMS_CSI2_SEL;
    uint32_t pad_CRM_CLK_SD_HISPEED_SOURCE_STATUS;
    CRM_CLK_SD_HISPEED_SOURCE_STATUS_tu CRM_CLK_SD_HISPEED_SOURCE_STATUS;
    CRM_CLK_SD_LOSPEED_SOURCE_STATUS_tu CRM_CLK_SD_LOSPEED_SOURCE_STATUS;
    CRM_CLK_PIPE_SOURCE_STATUS_tu CRM_CLK_PIPE_SOURCE_STATUS;
    CRM_CLK_BMS_SOURCE_STATUS_tu CRM_CLK_BMS_SOURCE_STATUS;
    CRM_CLK_PICTOR_GPIO_SOURCE_STATUS_tu CRM_CLK_PICTOR_GPIO_SOURCE_STATUS;
    CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS_tu CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS;
}CRM_IP_ts;




//CRM_EN_CLK_SD_HISPEED


#define Get_CRM_CRM_EN_CLK_SD_HISPEED_EN_CLK_SD_HISPEED_T1_STBUS() p_CRM_IP->CRM_EN_CLK_SD_HISPEED.CRM_EN_CLK_SD_HISPEED_ts.EN_CLK_SD_HISPEED_T1_STBUS
#define Set_CRM_CRM_EN_CLK_SD_HISPEED_EN_CLK_SD_HISPEED_T1_STBUS(x) (p_CRM_IP->CRM_EN_CLK_SD_HISPEED.CRM_EN_CLK_SD_HISPEED_ts.EN_CLK_SD_HISPEED_T1_STBUS = x)


#define Get_CRM_CRM_EN_CLK_SD_HISPEED_EN_CLK_SD_HISPEED_DATA() p_CRM_IP->CRM_EN_CLK_SD_HISPEED.CRM_EN_CLK_SD_HISPEED_ts.EN_CLK_SD_HISPEED_DATA
#define Set_CRM_CRM_EN_CLK_SD_HISPEED_EN_CLK_SD_HISPEED_DATA(x) (p_CRM_IP->CRM_EN_CLK_SD_HISPEED.CRM_EN_CLK_SD_HISPEED_ts.EN_CLK_SD_HISPEED_DATA = x)
#define Set_CRM_CRM_EN_CLK_SD_HISPEED(EN_CLK_SD_HISPEED_T1_STBUS,EN_CLK_SD_HISPEED_DATA) (p_CRM_IP->CRM_EN_CLK_SD_HISPEED.word = (uint32_t)EN_CLK_SD_HISPEED_T1_STBUS<<0 | (uint32_t)EN_CLK_SD_HISPEED_DATA<<1)
#define Get_CRM_CRM_EN_CLK_SD_HISPEED() p_CRM_IP->CRM_EN_CLK_SD_HISPEED.word
#define Set_CRM_CRM_EN_CLK_SD_HISPEED_word(x) (p_CRM_IP->CRM_EN_CLK_SD_HISPEED.word = x)


//CRM_EN_CLK_SD_LOSPEED


#define Get_CRM_CRM_EN_CLK_SD_LOSPEED_EN_CLK_SD_LOSPEED_T1_STBUS() p_CRM_IP->CRM_EN_CLK_SD_LOSPEED.CRM_EN_CLK_SD_LOSPEED_ts.EN_CLK_SD_LOSPEED_T1_STBUS
#define Set_CRM_CRM_EN_CLK_SD_LOSPEED_EN_CLK_SD_LOSPEED_T1_STBUS(x) (p_CRM_IP->CRM_EN_CLK_SD_LOSPEED.CRM_EN_CLK_SD_LOSPEED_ts.EN_CLK_SD_LOSPEED_T1_STBUS = x)


#define Get_CRM_CRM_EN_CLK_SD_LOSPEED_EN_CLK_SD_LOSPEED_DATA() p_CRM_IP->CRM_EN_CLK_SD_LOSPEED.CRM_EN_CLK_SD_LOSPEED_ts.EN_CLK_SD_LOSPEED_DATA
#define Set_CRM_CRM_EN_CLK_SD_LOSPEED_EN_CLK_SD_LOSPEED_DATA(x) (p_CRM_IP->CRM_EN_CLK_SD_LOSPEED.CRM_EN_CLK_SD_LOSPEED_ts.EN_CLK_SD_LOSPEED_DATA = x)
#define Set_CRM_CRM_EN_CLK_SD_LOSPEED(EN_CLK_SD_LOSPEED_T1_STBUS,EN_CLK_SD_LOSPEED_DATA) (p_CRM_IP->CRM_EN_CLK_SD_LOSPEED.word = (uint32_t)EN_CLK_SD_LOSPEED_T1_STBUS<<0 | (uint32_t)EN_CLK_SD_LOSPEED_DATA<<1)
#define Get_CRM_CRM_EN_CLK_SD_LOSPEED() p_CRM_IP->CRM_EN_CLK_SD_LOSPEED.word
#define Set_CRM_CRM_EN_CLK_SD_LOSPEED_word(x) (p_CRM_IP->CRM_EN_CLK_SD_LOSPEED.word = x)


//CRM_EN_CLK_PIPE


#define Get_CRM_CRM_EN_CLK_PIPE_EN_CLK_PIPE_T1_STBUS() p_CRM_IP->CRM_EN_CLK_PIPE.CRM_EN_CLK_PIPE_ts.EN_CLK_PIPE_T1_STBUS
#define Set_CRM_CRM_EN_CLK_PIPE_EN_CLK_PIPE_T1_STBUS(x) (p_CRM_IP->CRM_EN_CLK_PIPE.CRM_EN_CLK_PIPE_ts.EN_CLK_PIPE_T1_STBUS = x)


#define Get_CRM_CRM_EN_CLK_PIPE_EN_CLK_PIPE_RE_DATA() p_CRM_IP->CRM_EN_CLK_PIPE.CRM_EN_CLK_PIPE_ts.EN_CLK_PIPE_RE_DATA
#define Set_CRM_CRM_EN_CLK_PIPE_EN_CLK_PIPE_RE_DATA(x) (p_CRM_IP->CRM_EN_CLK_PIPE.CRM_EN_CLK_PIPE_ts.EN_CLK_PIPE_RE_DATA = x)


#define Get_CRM_CRM_EN_CLK_PIPE_EN_CLK_PIPE_DMCE_DATA() p_CRM_IP->CRM_EN_CLK_PIPE.CRM_EN_CLK_PIPE_ts.EN_CLK_PIPE_DMCE_DATA
#define Set_CRM_CRM_EN_CLK_PIPE_EN_CLK_PIPE_DMCE_DATA(x) (p_CRM_IP->CRM_EN_CLK_PIPE.CRM_EN_CLK_PIPE_ts.EN_CLK_PIPE_DMCE_DATA = x)


#define Get_CRM_CRM_EN_CLK_PIPE_EN_CLK_PIPE_CE0_DATA() p_CRM_IP->CRM_EN_CLK_PIPE.CRM_EN_CLK_PIPE_ts.EN_CLK_PIPE_CE0_DATA
#define Set_CRM_CRM_EN_CLK_PIPE_EN_CLK_PIPE_CE0_DATA(x) (p_CRM_IP->CRM_EN_CLK_PIPE.CRM_EN_CLK_PIPE_ts.EN_CLK_PIPE_CE0_DATA = x)


#define Get_CRM_CRM_EN_CLK_PIPE_EN_CLK_PIPE_CE1_DATA() p_CRM_IP->CRM_EN_CLK_PIPE.CRM_EN_CLK_PIPE_ts.EN_CLK_PIPE_CE1_DATA
#define Set_CRM_CRM_EN_CLK_PIPE_EN_CLK_PIPE_CE1_DATA(x) (p_CRM_IP->CRM_EN_CLK_PIPE.CRM_EN_CLK_PIPE_ts.EN_CLK_PIPE_CE1_DATA = x)


#define Get_CRM_CRM_EN_CLK_PIPE_EN_CLK_PIPE_STATS_DATA() p_CRM_IP->CRM_EN_CLK_PIPE.CRM_EN_CLK_PIPE_ts.EN_CLK_PIPE_STATS_DATA
#define Set_CRM_CRM_EN_CLK_PIPE_EN_CLK_PIPE_STATS_DATA(x) (p_CRM_IP->CRM_EN_CLK_PIPE.CRM_EN_CLK_PIPE_ts.EN_CLK_PIPE_STATS_DATA = x)

#define Get_CRM_CRM_EN_CLK_PIPE_EN_CLK_PIPE_DXO() p_CRM_IP->CRM_EN_CLK_PIPE.CRM_EN_CLK_PIPE_ts.EN_CLK_PIPE_DXO
#define Set_CRM_CRM_EN_CLK_PIPE_EN_CLK_PIPE_DXO(x) (p_CRM_IP->CRM_EN_CLK_PIPE.CRM_EN_CLK_PIPE_ts.EN_CLK_PIPE_DXO = x)
#define Set_CRM_CRM_EN_CLK_PIPE(EN_CLK_PIPE_T1_STBUS,EN_CLK_PIPE_RE_DATA,EN_CLK_PIPE_DMCE_DATA,EN_CLK_PIPE_CE0_DATA,EN_CLK_PIPE_CE1_DATA,EN_CLK_PIPE_STATS_DATA,EN_CLK_PIPE_DXO) (p_CRM_IP->CRM_EN_CLK_PIPE.word = (uint32_t)EN_CLK_PIPE_T1_STBUS<<0 | (uint32_t)EN_CLK_PIPE_RE_DATA<<1 | (uint32_t)EN_CLK_PIPE_DMCE_DATA<<2 | (uint32_t)EN_CLK_PIPE_CE0_DATA<<3 | (uint32_t)EN_CLK_PIPE_CE1_DATA<<4 | (uint32_t)EN_CLK_PIPE_STATS_DATA<<5| (uint32_t)EN_CLK_PIPE_DXO<<6)
//#define Set_CRM_CRM_EN_CLK_PIPE(EN_CLK_PIPE_T1_STBUS,EN_CLK_PIPE_RE_DATA,EN_CLK_PIPE_DMCE_DATA,EN_CLK_PIPE_CE0_DATA,EN_CLK_PIPE_CE1_DATA,EN_CLK_PIPE_STATS_DATA) (p_CRM_IP->CRM_EN_CLK_PIPE.word = (uint32_t)EN_CLK_PIPE_T1_STBUS<<0 | (uint32_t)EN_CLK_PIPE_RE_DATA<<1 | (uint32_t)EN_CLK_PIPE_DMCE_DATA<<2 | (uint32_t)EN_CLK_PIPE_CE0_DATA<<3 | (uint32_t)EN_CLK_PIPE_CE1_DATA<<4 | (uint32_t)EN_CLK_PIPE_STATS_DATA<<5)
#define Get__CRM_EN_CLK_PIPE() p__IP->CRM_EN_CLK_PIPE.word
#define Get_CRM_CRM_EN_CLK_PIPE() p_CRM_IP->CRM_EN_CLK_PIPE.word
#define Set_CRM_CRM_EN_CLK_PIPE_word(x) (p_CRM_IP->CRM_EN_CLK_PIPE.word = x)


//CRM_EN_CLK_BML


#define Get_CRM_CRM_EN_CLK_BML_EN_CLK_BML() p_CRM_IP->CRM_EN_CLK_BML.CRM_EN_CLK_BML_ts.EN_CLK_BML
#define Set_CRM_CRM_EN_CLK_BML_EN_CLK_BML(x) (p_CRM_IP->CRM_EN_CLK_BML.CRM_EN_CLK_BML_ts.EN_CLK_BML = x)
#define Set_CRM_CRM_EN_CLK_BML(EN_CLK_BML) (p_CRM_IP->CRM_EN_CLK_BML.word = (uint32_t)EN_CLK_BML<<0)
#define Get_CRM_CRM_EN_CLK_BML() p_CRM_IP->CRM_EN_CLK_BML.word
#define Set_CRM_CRM_EN_CLK_BML_word(x) (p_CRM_IP->CRM_EN_CLK_BML.word = x)


//CRM_EN_CLK_BMS


#define Get_CRM_CRM_EN_CLK_BMS_EN_CLK_BMS() p_CRM_IP->CRM_EN_CLK_BMS.CRM_EN_CLK_BMS_ts.EN_CLK_BMS
#define Set_CRM_CRM_EN_CLK_BMS_EN_CLK_BMS(x) (p_CRM_IP->CRM_EN_CLK_BMS.CRM_EN_CLK_BMS_ts.EN_CLK_BMS = x)
#define Set_CRM_CRM_EN_CLK_BMS(EN_CLK_BMS) (p_CRM_IP->CRM_EN_CLK_BMS.word = (uint32_t)EN_CLK_BMS<<0)
#define Get_CRM_CRM_EN_CLK_BMS() p_CRM_IP->CRM_EN_CLK_BMS.word
#define Set_CRM_CRM_EN_CLK_BMS_word(x) (p_CRM_IP->CRM_EN_CLK_BMS.word = x)


//CRM_EN_CLK_PIPE_IN


#define Get_CRM_CRM_EN_CLK_PIPE_IN_EN_CLK_PIPE_IN() p_CRM_IP->CRM_EN_CLK_PIPE_IN.CRM_EN_CLK_PIPE_IN_ts.EN_CLK_PIPE_IN
#define Set_CRM_CRM_EN_CLK_PIPE_IN_EN_CLK_PIPE_IN(x) (p_CRM_IP->CRM_EN_CLK_PIPE_IN.CRM_EN_CLK_PIPE_IN_ts.EN_CLK_PIPE_IN = x)
#define Set_CRM_CRM_EN_CLK_PIPE_IN(EN_CLK_PIPE_IN) (p_CRM_IP->CRM_EN_CLK_PIPE_IN.word = (uint32_t)EN_CLK_PIPE_IN<<0)
#define Get_CRM_CRM_EN_CLK_PIPE_IN() p_CRM_IP->CRM_EN_CLK_PIPE_IN.word
#define Set_CRM_CRM_EN_CLK_PIPE_IN_word(x) (p_CRM_IP->CRM_EN_CLK_PIPE_IN.word = x)


//CRM_EN_CLK_PICTOR_GPIO


#define Get_CRM_CRM_EN_CLK_PICTOR_GPIO_EN_CLK_PICTOR_GPIO() p_CRM_IP->CRM_EN_CLK_PICTOR_GPIO.CRM_EN_CLK_PICTOR_GPIO_ts.EN_CLK_PICTOR_GPIO
#define Set_CRM_CRM_EN_CLK_PICTOR_GPIO_EN_CLK_PICTOR_GPIO(x) (p_CRM_IP->CRM_EN_CLK_PICTOR_GPIO.CRM_EN_CLK_PICTOR_GPIO_ts.EN_CLK_PICTOR_GPIO = x)
#define Set_CRM_CRM_EN_CLK_PICTOR_GPIO(EN_CLK_PICTOR_GPIO) (p_CRM_IP->CRM_EN_CLK_PICTOR_GPIO.word = (uint32_t)EN_CLK_PICTOR_GPIO<<0)
#define Get_CRM_CRM_EN_CLK_PICTOR_GPIO() p_CRM_IP->CRM_EN_CLK_PICTOR_GPIO.word
#define Set_CRM_CRM_EN_CLK_PICTOR_GPIO_word(x) (p_CRM_IP->CRM_EN_CLK_PICTOR_GPIO.word = x)


//CRM_CLK_PIPE_IN_DIV


#define Get_CRM_CRM_CLK_PIPE_IN_DIV_CLK_PIPE_IN_DIV() p_CRM_IP->CRM_CLK_PIPE_IN_DIV.CRM_CLK_PIPE_IN_DIV_ts.CLK_PIPE_IN_DIV
#define Set_CRM_CRM_CLK_PIPE_IN_DIV_CLK_PIPE_IN_DIV(x) (p_CRM_IP->CRM_CLK_PIPE_IN_DIV.CRM_CLK_PIPE_IN_DIV_ts.CLK_PIPE_IN_DIV = x)
#define Set_CRM_CRM_CLK_PIPE_IN_DIV(CLK_PIPE_IN_DIV) (p_CRM_IP->CRM_CLK_PIPE_IN_DIV.word = (uint32_t)CLK_PIPE_IN_DIV<<0)
#define Get_CRM_CRM_CLK_PIPE_IN_DIV() p_CRM_IP->CRM_CLK_PIPE_IN_DIV.word
#define Set_CRM_CRM_CLK_PIPE_IN_DIV_word(x) (p_CRM_IP->CRM_CLK_PIPE_IN_DIV.word = x)


//CRM_CLK_HOST_IPP_DIV


#define Get_CRM_CRM_CLK_HOST_IPP_DIV_CLK_HOST_IPP_DIV() p_CRM_IP->CRM_CLK_HOST_IPP_DIV.CRM_CLK_HOST_IPP_DIV_ts.CLK_HOST_IPP_DIV
#define Set_CRM_CRM_CLK_HOST_IPP_DIV_CLK_HOST_IPP_DIV(x) (p_CRM_IP->CRM_CLK_HOST_IPP_DIV.CRM_CLK_HOST_IPP_DIV_ts.CLK_HOST_IPP_DIV = x)
#define Set_CRM_CRM_CLK_HOST_IPP_DIV(CLK_HOST_IPP_DIV) (p_CRM_IP->CRM_CLK_HOST_IPP_DIV.word = (uint32_t)CLK_HOST_IPP_DIV<<0)
#define Get_CRM_CRM_CLK_HOST_IPP_DIV() p_CRM_IP->CRM_CLK_HOST_IPP_DIV.word
#define Set_CRM_CRM_CLK_HOST_IPP_DIV_word(x) (p_CRM_IP->CRM_CLK_HOST_IPP_DIV.word = x)


//CRM_CLK_PICTOR_GPIO_DIV


#define Get_CRM_CRM_CLK_PICTOR_GPIO_DIV_CLK_PICTOR_GPIO_DIV() p_CRM_IP->CRM_CLK_PICTOR_GPIO_DIV.CRM_CLK_PICTOR_GPIO_DIV_ts.CLK_PICTOR_GPIO_DIV
#define Set_CRM_CRM_CLK_PICTOR_GPIO_DIV_CLK_PICTOR_GPIO_DIV(x) (p_CRM_IP->CRM_CLK_PICTOR_GPIO_DIV.CRM_CLK_PICTOR_GPIO_DIV_ts.CLK_PICTOR_GPIO_DIV = x)
#define Set_CRM_CRM_CLK_PICTOR_GPIO_DIV(CLK_PICTOR_GPIO_DIV) (p_CRM_IP->CRM_CLK_PICTOR_GPIO_DIV.word = (uint32_t)CLK_PICTOR_GPIO_DIV<<0)
#define Get_CRM_CRM_CLK_PICTOR_GPIO_DIV() p_CRM_IP->CRM_CLK_PICTOR_GPIO_DIV.word
#define Set_CRM_CRM_CLK_PICTOR_GPIO_DIV_word(x) (p_CRM_IP->CRM_CLK_PICTOR_GPIO_DIV.word = x)


//CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV


#define Get_CRM_CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV_STATIC_SD_CCP_PIXEL_CLOCK_DIV() p_CRM_IP->CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV.CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV_ts.STATIC_SD_CCP_PIXEL_CLOCK_DIV
#define Set_CRM_CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV_STATIC_SD_CCP_PIXEL_CLOCK_DIV(x) (p_CRM_IP->CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV.CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV_ts.STATIC_SD_CCP_PIXEL_CLOCK_DIV = x)
#define Set_CRM_CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV(STATIC_SD_CCP_PIXEL_CLOCK_DIV) (p_CRM_IP->CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV.word = (uint32_t)STATIC_SD_CCP_PIXEL_CLOCK_DIV<<0)
#define Get_CRM_CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV() p_CRM_IP->CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV.word
#define Set_CRM_CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV_word(x) (p_CRM_IP->CRM_STATIC_SD_CCP_PIXEL_CLOCK_DIV.word = x)


//CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL


#define Get_CRM_CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL_STATIC_CLK_SD_HISPEED_SOURCE_SEL() p_CRM_IP->CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL.CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL_ts.STATIC_CLK_SD_HISPEED_SOURCE_SEL
#define Is_CRM_CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL_STATIC_CLK_SD_HISPEED_SOURCE_SEL_B_0x0() (p_CRM_IP->CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL.CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL_ts.STATIC_CLK_SD_HISPEED_SOURCE_SEL == STATIC_CLK_SD_HISPEED_SOURCE_SEL_B_0x0)
#define Set_CRM_CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL_STATIC_CLK_SD_HISPEED_SOURCE_SEL__B_0x0() (p_CRM_IP->CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL.CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL_ts.STATIC_CLK_SD_HISPEED_SOURCE_SEL = STATIC_CLK_SD_HISPEED_SOURCE_SEL_B_0x0)
#define STATIC_CLK_SD_HISPEED_SOURCE_SEL_B_0x0 0x0    //sensor pixel clock (in emulated clock mode or no, e.g when ISP on-the-fly)
#define Is_CRM_CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL_STATIC_CLK_SD_HISPEED_SOURCE_SEL_B_0x1() (p_CRM_IP->CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL.CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL_ts.STATIC_CLK_SD_HISPEED_SOURCE_SEL == STATIC_CLK_SD_HISPEED_SOURCE_SEL_B_0x1)
#define Set_CRM_CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL_STATIC_CLK_SD_HISPEED_SOURCE_SEL__B_0x1() (p_CRM_IP->CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL.CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL_ts.STATIC_CLK_SD_HISPEED_SOURCE_SEL = STATIC_CLK_SD_HISPEED_SOURCE_SEL_B_0x1)
#define STATIC_CLK_SD_HISPEED_SOURCE_SEL_B_0x1 0x1    //divided clk_pipe_in (unused by now)
#define Set_CRM_CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL(STATIC_CLK_SD_HISPEED_SOURCE_SEL) (p_CRM_IP->CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL.word = (uint32_t)STATIC_CLK_SD_HISPEED_SOURCE_SEL<<0)
#define Get_CRM_CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL() p_CRM_IP->CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL.word
#define Set_CRM_CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL_word(x) (p_CRM_IP->CRM_STATIC_CLK_SD_HISPEED_SOURCE_SEL.word = x)


//CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL


#define Get_CRM_CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL_STATIC_CLK_SD_LOSPEED_SOURCE_SEL() p_CRM_IP->CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL.CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL_ts.STATIC_CLK_SD_LOSPEED_SOURCE_SEL
#define Is_CRM_CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL_STATIC_CLK_SD_LOSPEED_SOURCE_SEL_B_0x0() (p_CRM_IP->CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL.CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL_ts.STATIC_CLK_SD_LOSPEED_SOURCE_SEL == STATIC_CLK_SD_LOSPEED_SOURCE_SEL_B_0x0)
#define Set_CRM_CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL_STATIC_CLK_SD_LOSPEED_SOURCE_SEL__B_0x0() (p_CRM_IP->CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL.CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL_ts.STATIC_CLK_SD_LOSPEED_SOURCE_SEL = STATIC_CLK_SD_LOSPEED_SOURCE_SEL_B_0x0)
#define STATIC_CLK_SD_LOSPEED_SOURCE_SEL_B_0x0 0x0    //sensor pixel clock (in emulated clock mode or no, e.g when ISP on-the-fly)
#define Is_CRM_CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL_STATIC_CLK_SD_LOSPEED_SOURCE_SEL_B_0x1() (p_CRM_IP->CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL.CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL_ts.STATIC_CLK_SD_LOSPEED_SOURCE_SEL == STATIC_CLK_SD_LOSPEED_SOURCE_SEL_B_0x1)
#define Set_CRM_CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL_STATIC_CLK_SD_LOSPEED_SOURCE_SEL__B_0x1() (p_CRM_IP->CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL.CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL_ts.STATIC_CLK_SD_LOSPEED_SOURCE_SEL = STATIC_CLK_SD_LOSPEED_SOURCE_SEL_B_0x1)
#define STATIC_CLK_SD_LOSPEED_SOURCE_SEL_B_0x1 0x1    //divided clk_pipe_in (unused by now)
#define Set_CRM_CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL(STATIC_CLK_SD_LOSPEED_SOURCE_SEL) (p_CRM_IP->CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL.word = (uint32_t)STATIC_CLK_SD_LOSPEED_SOURCE_SEL<<0)
#define Get_CRM_CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL() p_CRM_IP->CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL.word
#define Set_CRM_CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL_word(x) (p_CRM_IP->CRM_STATIC_CLK_SD_LOSPEED_SOURCE_SEL.word = x)


//CRM_STATIC_CLK_PIPE_SOURCE_SEL


#define Get_CRM_CRM_STATIC_CLK_PIPE_SOURCE_SEL_STATIC_CLK_PIPE_SOURCE_SEL() p_CRM_IP->CRM_STATIC_CLK_PIPE_SOURCE_SEL.CRM_STATIC_CLK_PIPE_SOURCE_SEL_ts.STATIC_CLK_PIPE_SOURCE_SEL
#define Is_CRM_CRM_STATIC_CLK_PIPE_SOURCE_SEL_STATIC_CLK_PIPE_SOURCE_SEL_B_0x0() (p_CRM_IP->CRM_STATIC_CLK_PIPE_SOURCE_SEL.CRM_STATIC_CLK_PIPE_SOURCE_SEL_ts.STATIC_CLK_PIPE_SOURCE_SEL == STATIC_CLK_PIPE_SOURCE_SEL_B_0x0)
#define Set_CRM_CRM_STATIC_CLK_PIPE_SOURCE_SEL_STATIC_CLK_PIPE_SOURCE_SEL__B_0x0() (p_CRM_IP->CRM_STATIC_CLK_PIPE_SOURCE_SEL.CRM_STATIC_CLK_PIPE_SOURCE_SEL_ts.STATIC_CLK_PIPE_SOURCE_SEL = STATIC_CLK_PIPE_SOURCE_SEL_B_0x0)
#define STATIC_CLK_PIPE_SOURCE_SEL_B_0x0 0x0    //sensor pixel clock (in emulated clock mode or no, e.g when ISP on-the-fly)
#define Is_CRM_CRM_STATIC_CLK_PIPE_SOURCE_SEL_STATIC_CLK_PIPE_SOURCE_SEL_B_0x1() (p_CRM_IP->CRM_STATIC_CLK_PIPE_SOURCE_SEL.CRM_STATIC_CLK_PIPE_SOURCE_SEL_ts.STATIC_CLK_PIPE_SOURCE_SEL == STATIC_CLK_PIPE_SOURCE_SEL_B_0x1)
#define Set_CRM_CRM_STATIC_CLK_PIPE_SOURCE_SEL_STATIC_CLK_PIPE_SOURCE_SEL__B_0x1() (p_CRM_IP->CRM_STATIC_CLK_PIPE_SOURCE_SEL.CRM_STATIC_CLK_PIPE_SOURCE_SEL_ts.STATIC_CLK_PIPE_SOURCE_SEL = STATIC_CLK_PIPE_SOURCE_SEL_B_0x1)
#define STATIC_CLK_PIPE_SOURCE_SEL_B_0x1 0x1    //divided clk_pipe_in (e.g when LBE or BML is active)
#define Set_CRM_CRM_STATIC_CLK_PIPE_SOURCE_SEL(STATIC_CLK_PIPE_SOURCE_SEL) (p_CRM_IP->CRM_STATIC_CLK_PIPE_SOURCE_SEL.word = (uint32_t)STATIC_CLK_PIPE_SOURCE_SEL<<0)
#define Get_CRM_CRM_STATIC_CLK_PIPE_SOURCE_SEL() p_CRM_IP->CRM_STATIC_CLK_PIPE_SOURCE_SEL.word
#define Set_CRM_CRM_STATIC_CLK_PIPE_SOURCE_SEL_word(x) (p_CRM_IP->CRM_STATIC_CLK_PIPE_SOURCE_SEL.word = x)


//CRM_STATIC_CLK_BMS_SOURCE_SEL


#define Get_CRM_CRM_STATIC_CLK_BMS_SOURCE_SEL_STATIC_CLK_BMS_SOURCE_SEL() p_CRM_IP->CRM_STATIC_CLK_BMS_SOURCE_SEL.CRM_STATIC_CLK_BMS_SOURCE_SEL_ts.STATIC_CLK_BMS_SOURCE_SEL
#define Is_CRM_CRM_STATIC_CLK_BMS_SOURCE_SEL_STATIC_CLK_BMS_SOURCE_SEL_B_0x0() (p_CRM_IP->CRM_STATIC_CLK_BMS_SOURCE_SEL.CRM_STATIC_CLK_BMS_SOURCE_SEL_ts.STATIC_CLK_BMS_SOURCE_SEL == STATIC_CLK_BMS_SOURCE_SEL_B_0x0)
#define Set_CRM_CRM_STATIC_CLK_BMS_SOURCE_SEL_STATIC_CLK_BMS_SOURCE_SEL__B_0x0() (p_CRM_IP->CRM_STATIC_CLK_BMS_SOURCE_SEL.CRM_STATIC_CLK_BMS_SOURCE_SEL_ts.STATIC_CLK_BMS_SOURCE_SEL = STATIC_CLK_BMS_SOURCE_SEL_B_0x0)
#define STATIC_CLK_BMS_SOURCE_SEL_B_0x0 0x0    //sensor pixel clock (in emulated clock mode or no, e.g when BMS from Bayer Store 0)
#define Is_CRM_CRM_STATIC_CLK_BMS_SOURCE_SEL_STATIC_CLK_BMS_SOURCE_SEL_B_0x1() (p_CRM_IP->CRM_STATIC_CLK_BMS_SOURCE_SEL.CRM_STATIC_CLK_BMS_SOURCE_SEL_ts.STATIC_CLK_BMS_SOURCE_SEL == STATIC_CLK_BMS_SOURCE_SEL_B_0x1)
#define Set_CRM_CRM_STATIC_CLK_BMS_SOURCE_SEL_STATIC_CLK_BMS_SOURCE_SEL__B_0x1() (p_CRM_IP->CRM_STATIC_CLK_BMS_SOURCE_SEL.CRM_STATIC_CLK_BMS_SOURCE_SEL_ts.STATIC_CLK_BMS_SOURCE_SEL = STATIC_CLK_BMS_SOURCE_SEL_B_0x1)
#define STATIC_CLK_BMS_SOURCE_SEL_B_0x1 0x1    //divided clk_pipe_in (e.g. when BMS from Bayer Store 2)
#define Set_CRM_CRM_STATIC_CLK_BMS_SOURCE_SEL(STATIC_CLK_BMS_SOURCE_SEL) (p_CRM_IP->CRM_STATIC_CLK_BMS_SOURCE_SEL.word = (uint32_t)STATIC_CLK_BMS_SOURCE_SEL<<0)
#define Get_CRM_CRM_STATIC_CLK_BMS_SOURCE_SEL() p_CRM_IP->CRM_STATIC_CLK_BMS_SOURCE_SEL.word
#define Set_CRM_CRM_STATIC_CLK_BMS_SOURCE_SEL_word(x) (p_CRM_IP->CRM_STATIC_CLK_BMS_SOURCE_SEL.word = x)


//CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL


#define Get_CRM_CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL() p_CRM_IP->CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL.CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_ts.STATIC_CLK_PICTOR_GPIO_SOURCE_SEL
#define Is_CRM_CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_B_0x0() (p_CRM_IP->CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL.CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_ts.STATIC_CLK_PICTOR_GPIO_SOURCE_SEL == STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_B_0x0)
#define Set_CRM_CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL__B_0x0() (p_CRM_IP->CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL.CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_ts.STATIC_CLK_PICTOR_GPIO_SOURCE_SEL = STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_B_0x0)
#define STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_B_0x0 0x0    //sensor pixel clock (in emulated clock mode or no, typical configuration)
#define Is_CRM_CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_B_0x1() (p_CRM_IP->CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL.CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_ts.STATIC_CLK_PICTOR_GPIO_SOURCE_SEL == STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_B_0x1)
#define Set_CRM_CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL__B_0x1() (p_CRM_IP->CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL.CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_ts.STATIC_CLK_PICTOR_GPIO_SOURCE_SEL = STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_B_0x1)
#define STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_B_0x1 0x1    //divided clk_pipe_in
#define Set_CRM_CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL(STATIC_CLK_PICTOR_GPIO_SOURCE_SEL) (p_CRM_IP->CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL.word = (uint32_t)STATIC_CLK_PICTOR_GPIO_SOURCE_SEL<<0)
#define Get_CRM_CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL() p_CRM_IP->CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL.word
#define Set_CRM_CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL_word(x) (p_CRM_IP->CRM_STATIC_CLK_PICTOR_GPIO_SOURCE_SEL.word = x)


//CRM_EMUL_SENSOR_CLOCK


#define Get_CRM_CRM_EMUL_SENSOR_CLOCK_EMUL_SENSOR_CLOCK() p_CRM_IP->CRM_EMUL_SENSOR_CLOCK.CRM_EMUL_SENSOR_CLOCK_ts.EMUL_SENSOR_CLOCK
#define Set_CRM_CRM_EMUL_SENSOR_CLOCK_EMUL_SENSOR_CLOCK(x) (p_CRM_IP->CRM_EMUL_SENSOR_CLOCK.CRM_EMUL_SENSOR_CLOCK_ts.EMUL_SENSOR_CLOCK = x)
#define Set_CRM_CRM_EMUL_SENSOR_CLOCK(EMUL_SENSOR_CLOCK) (p_CRM_IP->CRM_EMUL_SENSOR_CLOCK.word = (uint32_t)EMUL_SENSOR_CLOCK<<0)
#define Get_CRM_CRM_EMUL_SENSOR_CLOCK() p_CRM_IP->CRM_EMUL_SENSOR_CLOCK.word
#define Set_CRM_CRM_EMUL_SENSOR_CLOCK_word(x) (p_CRM_IP->CRM_EMUL_SENSOR_CLOCK.word = x)


//CRM_CHECKER_LOST_EN_CTRL_N //deprecated


#define Get_CRM_CRM_CHECKER_LOST_EN_CTRL_N_CHECKER_LOST_EN_CTRL_N() p_CRM_IP->CRM_CHECKER_LOST_EN_CTRL_N.CRM_CHECKER_LOST_EN_CTRL_N_ts.CHECKER_LOST_EN_CTRL_N
#define Set_CRM_CRM_CHECKER_LOST_EN_CTRL_N_CHECKER_LOST_EN_CTRL_N(x) (p_CRM_IP->CRM_CHECKER_LOST_EN_CTRL_N.CRM_CHECKER_LOST_EN_CTRL_N_ts.CHECKER_LOST_EN_CTRL_N = x)
#define Set_CRM_CRM_CHECKER_LOST_EN_CTRL_N(CHECKER_LOST_EN_CTRL_N) (p_CRM_IP->CRM_CHECKER_LOST_EN_CTRL_N.word = (uint32_t)CHECKER_LOST_EN_CTRL_N<<0)
#define Get_CRM_CRM_CHECKER_LOST_EN_CTRL_N() p_CRM_IP->CRM_CHECKER_LOST_EN_CTRL_N.word
#define Set_CRM_CRM_CHECKER_LOST_EN_CTRL_N_word(x) (p_CRM_IP->CRM_CHECKER_LOST_EN_CTRL_N.word = x)


//DEPRECATED2


#define Get__DEPRECATED2_DEPRECATED() p__IP->DEPRECATED2.DEPRECATED2_ts.DEPRECATED
#define Get__DEPRECATED2() p__IP->DEPRECATED2.word


//CRM_CHECKER_ITS


#define Get_CRM_CRM_CHECKER_ITS_CKC_OK_ITS() p_CRM_IP->CRM_CHECKER_ITS.CRM_CHECKER_ITS_ts.CKC_OK_ITS


#define Get_CRM_CRM_CHECKER_ITS_CKC_LOST_ITS() p_CRM_IP->CRM_CHECKER_ITS.CRM_CHECKER_ITS_ts.CKC_LOST_ITS


#define Get_CRM_CRM_CHECKER_ITS_CKC_OK_3D_ITS() p_CRM_IP->CRM_CHECKER_ITS.CRM_CHECKER_ITS_ts.CKC_OK_3D_ITS


#define Get_CRM_CRM_CHECKER_ITS_CKC_LOST_3D_ITS() p_CRM_IP->CRM_CHECKER_ITS.CRM_CHECKER_ITS_ts.CKC_LOST_3D_ITS
#define Get_CRM_CRM_CHECKER_ITS() p_CRM_IP->CRM_CHECKER_ITS.word


//CRM_CHECKER_ITS_BCLR


#define Set_CRM_CRM_CHECKER_ITS_BCLR_CKC_OK_ITS_BCLR(x) (p_CRM_IP->CRM_CHECKER_ITS_BCLR.CRM_CHECKER_ITS_BCLR_ts.CKC_OK_ITS_BCLR = x)


#define Set_CRM_CRM_CHECKER_ITS_BCLR_CKC_LOST_ITS_BCLR(x) (p_CRM_IP->CRM_CHECKER_ITS_BCLR.CRM_CHECKER_ITS_BCLR_ts.CKC_LOST_ITS_BCLR = x)


#define Set_CRM_CRM_CHECKER_ITS_BCLR_CKC_OK_3D_ITS_BCLR(x) (p_CRM_IP->CRM_CHECKER_ITS_BCLR.CRM_CHECKER_ITS_BCLR_ts.CKC_OK_3D_ITS_BCLR = x)


#define Set_CRM_CRM_CHECKER_ITS_BCLR_CKC_LOST_3D_ITS_BCLR(x) (p_CRM_IP->CRM_CHECKER_ITS_BCLR.CRM_CHECKER_ITS_BCLR_ts.CKC_LOST_3D_ITS_BCLR = x)
#define Set_CRM_CRM_CHECKER_ITS_BCLR(CKC_OK_ITS_BCLR,CKC_LOST_ITS_BCLR,CKC_OK_3D_ITS_BCLR,CKC_LOST_3D_ITS_BCLR) (p_CRM_IP->CRM_CHECKER_ITS_BCLR.word = (uint32_t)CKC_OK_ITS_BCLR<<0 | (uint32_t)CKC_LOST_ITS_BCLR<<1 | (uint32_t)CKC_OK_3D_ITS_BCLR<<2 | (uint32_t)CKC_LOST_3D_ITS_BCLR<<3)
#define Set_CRM_CRM_CHECKER_ITS_BCLR_word(x) (p_CRM_IP->CRM_CHECKER_ITS_BCLR.word = x)


//CRM_CHECKER_ITS_BSET


#define Set_CRM_CRM_CHECKER_ITS_BSET_CKC_OK_ITS_BSET(x) (p_CRM_IP->CRM_CHECKER_ITS_BSET.CRM_CHECKER_ITS_BSET_ts.CKC_OK_ITS_BSET = x)


#define Set_CRM_CRM_CHECKER_ITS_BSET_CKC_LOST_ITS_BSET(x) (p_CRM_IP->CRM_CHECKER_ITS_BSET.CRM_CHECKER_ITS_BSET_ts.CKC_LOST_ITS_BSET = x)


#define Set_CRM_CRM_CHECKER_ITS_BSET_CKC_OK_3D_ITS_BSET(x) (p_CRM_IP->CRM_CHECKER_ITS_BSET.CRM_CHECKER_ITS_BSET_ts.CKC_OK_3D_ITS_BSET = x)


#define Set_CRM_CRM_CHECKER_ITS_BSET_CKC_LOST_3D_ITS_BSET(x) (p_CRM_IP->CRM_CHECKER_ITS_BSET.CRM_CHECKER_ITS_BSET_ts.CKC_LOST_3D_ITS_BSET = x)
#define Set_CRM_CRM_CHECKER_ITS_BSET(CKC_OK_ITS_BSET,CKC_LOST_ITS_BSET,CKC_OK_3D_ITS_BSET,CKC_LOST_3D_ITS_BSET) (p_CRM_IP->CRM_CHECKER_ITS_BSET.word = (uint32_t)CKC_OK_ITS_BSET<<0 | (uint32_t)CKC_LOST_ITS_BSET<<1 | (uint32_t)CKC_OK_3D_ITS_BSET<<2 | (uint32_t)CKC_LOST_3D_ITS_BSET<<3)
#define Set_CRM_CRM_CHECKER_ITS_BSET_word(x) (p_CRM_IP->CRM_CHECKER_ITS_BSET.word = x)


//CRM_CHECKER_ITM


#define Get_CRM_CRM_CHECKER_ITM_CKC_OK_ITM() p_CRM_IP->CRM_CHECKER_ITM.CRM_CHECKER_ITM_ts.CKC_OK_ITM


#define Get_CRM_CRM_CHECKER_ITM_CKC_LOST_ITM() p_CRM_IP->CRM_CHECKER_ITM.CRM_CHECKER_ITM_ts.CKC_LOST_ITM


#define Get_CRM_CRM_CHECKER_ITM_CKC_OK_3D_ITM() p_CRM_IP->CRM_CHECKER_ITM.CRM_CHECKER_ITM_ts.CKC_OK_3D_ITM


#define Get_CRM_CRM_CHECKER_ITM_CKC_LOST_3D_ITM() p_CRM_IP->CRM_CHECKER_ITM.CRM_CHECKER_ITM_ts.CKC_LOST_3D_ITM
#define Get_CRM_CRM_CHECKER_ITM() p_CRM_IP->CRM_CHECKER_ITM.word


//CRM_CHECKER_ITM_BCLR


#define Set_CRM_CRM_CHECKER_ITM_BCLR_CKC_OK_ITM_BCLR(x) (p_CRM_IP->CRM_CHECKER_ITM_BCLR.CRM_CHECKER_ITM_BCLR_ts.CKC_OK_ITM_BCLR = x)


#define Set_CRM_CRM_CHECKER_ITM_BCLR_CKC_LOST_ITM_BCLR(x) (p_CRM_IP->CRM_CHECKER_ITM_BCLR.CRM_CHECKER_ITM_BCLR_ts.CKC_LOST_ITM_BCLR = x)


#define Set_CRM_CRM_CHECKER_ITM_BCLR_CKC_OK_3D_ITM_BCLR(x) (p_CRM_IP->CRM_CHECKER_ITM_BCLR.CRM_CHECKER_ITM_BCLR_ts.CKC_OK_3D_ITM_BCLR = x)


#define Set_CRM_CRM_CHECKER_ITM_BCLR_CKC_LOST_3D_ITM_BCLR(x) (p_CRM_IP->CRM_CHECKER_ITM_BCLR.CRM_CHECKER_ITM_BCLR_ts.CKC_LOST_3D_ITM_BCLR = x)
#define Set_CRM_CRM_CHECKER_ITM_BCLR(CKC_OK_ITM_BCLR,CKC_LOST_ITM_BCLR,CKC_OK_3D_ITM_BCLR,CKC_LOST_3D_ITM_BCLR) (p_CRM_IP->CRM_CHECKER_ITM_BCLR.word = (uint32_t)CKC_OK_ITM_BCLR<<0 | (uint32_t)CKC_LOST_ITM_BCLR<<1 | (uint32_t)CKC_OK_3D_ITM_BCLR<<2 | (uint32_t)CKC_LOST_3D_ITM_BCLR<<3)
#define Set_CRM_CRM_CHECKER_ITM_BCLR_word(x) (p_CRM_IP->CRM_CHECKER_ITM_BCLR.word = x)


//CRM_CHECKER_ITM_BSET


#define Set_CRM_CRM_CHECKER_ITM_BSET_CKC_OK_ITM_BSET(x) (p_CRM_IP->CRM_CHECKER_ITM_BSET.CRM_CHECKER_ITM_BSET_ts.CKC_OK_ITM_BSET = x)


#define Set_CRM_CRM_CHECKER_ITM_BSET_CKC_LOST_ITM_BSET(x) (p_CRM_IP->CRM_CHECKER_ITM_BSET.CRM_CHECKER_ITM_BSET_ts.CKC_LOST_ITM_BSET = x)


#define Set_CRM_CRM_CHECKER_ITM_BSET_CKC_OK_3D_ITM_BSET(x) (p_CRM_IP->CRM_CHECKER_ITM_BSET.CRM_CHECKER_ITM_BSET_ts.CKC_OK_3D_ITM_BSET = x)


#define Set_CRM_CRM_CHECKER_ITM_BSET_CKC_LOST_3D_ITM_BSET(x) (p_CRM_IP->CRM_CHECKER_ITM_BSET.CRM_CHECKER_ITM_BSET_ts.CKC_LOST_3D_ITM_BSET = x)
#define Set_CRM_CRM_CHECKER_ITM_BSET(CKC_OK_ITM_BSET,CKC_LOST_ITM_BSET,CKC_OK_3D_ITM_BSET,CKC_LOST_3D_ITM_BSET) (p_CRM_IP->CRM_CHECKER_ITM_BSET.word = (uint32_t)CKC_OK_ITM_BSET<<0 | (uint32_t)CKC_LOST_ITM_BSET<<1 | (uint32_t)CKC_OK_3D_ITM_BSET<<2 | (uint32_t)CKC_LOST_3D_ITM_BSET<<3)
#define Set_CRM_CRM_CHECKER_ITM_BSET_word(x) (p_CRM_IP->CRM_CHECKER_ITM_BSET.word = x)


//CRM_CHECKER_DETECT_WDW


#define Get_CRM_CRM_CHECKER_DETECT_WDW_CKC_DETECT_WDW() p_CRM_IP->CRM_CHECKER_DETECT_WDW.CRM_CHECKER_DETECT_WDW_ts.CKC_DETECT_WDW
#define Set_CRM_CRM_CHECKER_DETECT_WDW_CKC_DETECT_WDW(x) (p_CRM_IP->CRM_CHECKER_DETECT_WDW.CRM_CHECKER_DETECT_WDW_ts.CKC_DETECT_WDW = x)
#define Set_CRM_CRM_CHECKER_DETECT_WDW(CKC_DETECT_WDW) (p_CRM_IP->CRM_CHECKER_DETECT_WDW.word = (uint32_t)CKC_DETECT_WDW<<0)
#define Get_CRM_CRM_CHECKER_DETECT_WDW() p_CRM_IP->CRM_CHECKER_DETECT_WDW.word
#define Set_CRM_CRM_CHECKER_DETECT_WDW_word(x) (p_CRM_IP->CRM_CHECKER_DETECT_WDW.word = x)


//CRM_EMUL_SENSOR_CLOCK_3D


#define Get_CRM_CRM_EMUL_SENSOR_CLOCK_3D_EMUL_SENSOR_CLOCK_3D() p_CRM_IP->CRM_EMUL_SENSOR_CLOCK_3D.CRM_EMUL_SENSOR_CLOCK_3D_ts.EMUL_SENSOR_CLOCK_3D
#define Set_CRM_CRM_EMUL_SENSOR_CLOCK_3D_EMUL_SENSOR_CLOCK_3D(x) (p_CRM_IP->CRM_EMUL_SENSOR_CLOCK_3D.CRM_EMUL_SENSOR_CLOCK_3D_ts.EMUL_SENSOR_CLOCK_3D = x)
#define Set_CRM_CRM_EMUL_SENSOR_CLOCK_3D(EMUL_SENSOR_CLOCK_3D) (p_CRM_IP->CRM_EMUL_SENSOR_CLOCK_3D.word = (uint32_t)EMUL_SENSOR_CLOCK_3D<<0)
#define Get_CRM_CRM_EMUL_SENSOR_CLOCK_3D() p_CRM_IP->CRM_EMUL_SENSOR_CLOCK_3D.word
#define Set_CRM_CRM_EMUL_SENSOR_CLOCK_3D_word(x) (p_CRM_IP->CRM_EMUL_SENSOR_CLOCK_3D.word = x)


//CRM_EN_CLK_SD_3D_HISPEED


#define Get_CRM_CRM_EN_CLK_SD_3D_HISPEED_EN_CLK_SD_3D_HISPEED_T1_STBUS() p_CRM_IP->CRM_EN_CLK_SD_3D_HISPEED.CRM_EN_CLK_SD_3D_HISPEED_ts.EN_CLK_SD_3D_HISPEED_T1_STBUS
#define Set_CRM_CRM_EN_CLK_SD_3D_HISPEED_EN_CLK_SD_3D_HISPEED_T1_STBUS(x) (p_CRM_IP->CRM_EN_CLK_SD_3D_HISPEED.CRM_EN_CLK_SD_3D_HISPEED_ts.EN_CLK_SD_3D_HISPEED_T1_STBUS = x)


#define Get_CRM_CRM_EN_CLK_SD_3D_HISPEED_EN_CLK_SD_3D_HISPEED_DATA() p_CRM_IP->CRM_EN_CLK_SD_3D_HISPEED.CRM_EN_CLK_SD_3D_HISPEED_ts.EN_CLK_SD_3D_HISPEED_DATA
#define Set_CRM_CRM_EN_CLK_SD_3D_HISPEED_EN_CLK_SD_3D_HISPEED_DATA(x) (p_CRM_IP->CRM_EN_CLK_SD_3D_HISPEED.CRM_EN_CLK_SD_3D_HISPEED_ts.EN_CLK_SD_3D_HISPEED_DATA = x)
#define Set_CRM_CRM_EN_CLK_SD_3D_HISPEED(EN_CLK_SD_3D_HISPEED_T1_STBUS,EN_CLK_SD_3D_HISPEED_DATA) (p_CRM_IP->CRM_EN_CLK_SD_3D_HISPEED.word = (uint32_t)EN_CLK_SD_3D_HISPEED_T1_STBUS<<0 | (uint32_t)EN_CLK_SD_3D_HISPEED_DATA<<1)
#define Get_CRM_CRM_EN_CLK_SD_3D_HISPEED() p_CRM_IP->CRM_EN_CLK_SD_3D_HISPEED.word
#define Set_CRM_CRM_EN_CLK_SD_3D_HISPEED_word(x) (p_CRM_IP->CRM_EN_CLK_SD_3D_HISPEED.word = x)


//CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL


#define Get_CRM_CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL() p_CRM_IP->CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL.CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_ts.STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL
#define Is_CRM_CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_B_0x0() (p_CRM_IP->CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL.CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_ts.STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL == STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_B_0x0)
#define Set_CRM_CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL__B_0x0() (p_CRM_IP->CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL.CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_ts.STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL = STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_B_0x0)
#define STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_B_0x0 0x0    //sensor pixel clock (in emulated clock mode or no, e.g when ISP on-the-fly)
#define Is_CRM_CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_B_0x1() (p_CRM_IP->CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL.CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_ts.STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL == STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_B_0x1)
#define Set_CRM_CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL__B_0x1() (p_CRM_IP->CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL.CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_ts.STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL = STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_B_0x1)
#define STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_B_0x1 0x1    //divided clk_pipe_in (unused by now)
#define Set_CRM_CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL(STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL) (p_CRM_IP->CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL.word = (uint32_t)STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL<<0)
#define Get_CRM_CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL() p_CRM_IP->CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL.word
#define Set_CRM_CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL_word(x) (p_CRM_IP->CRM_STATIC_CLK_SD_3D_HISPEED_SOURCE_SEL.word = x)


//CRM_STATIC_BMS_CSI2_SEL


#define Get_CRM_CRM_STATIC_BMS_CSI2_SEL_STATIC_BMS_CSI2_SEL() p_CRM_IP->CRM_STATIC_BMS_CSI2_SEL.CRM_STATIC_BMS_CSI2_SEL_ts.STATIC_BMS_CSI2_SEL
#define Is_CRM_CRM_STATIC_BMS_CSI2_SEL_STATIC_BMS_CSI2_SEL_B_0x0() (p_CRM_IP->CRM_STATIC_BMS_CSI2_SEL.CRM_STATIC_BMS_CSI2_SEL_ts.STATIC_BMS_CSI2_SEL == STATIC_BMS_CSI2_SEL_B_0x0)
#define Set_CRM_CRM_STATIC_BMS_CSI2_SEL_STATIC_BMS_CSI2_SEL__B_0x0() (p_CRM_IP->CRM_STATIC_BMS_CSI2_SEL.CRM_STATIC_BMS_CSI2_SEL_ts.STATIC_BMS_CSI2_SEL = STATIC_BMS_CSI2_SEL_B_0x0)
#define STATIC_BMS_CSI2_SEL_B_0x0 0x0    //CSI2RX to BMS
#define Is_CRM_CRM_STATIC_BMS_CSI2_SEL_STATIC_BMS_CSI2_SEL_B_0x1() (p_CRM_IP->CRM_STATIC_BMS_CSI2_SEL.CRM_STATIC_BMS_CSI2_SEL_ts.STATIC_BMS_CSI2_SEL == STATIC_BMS_CSI2_SEL_B_0x1)
#define Set_CRM_CRM_STATIC_BMS_CSI2_SEL_STATIC_BMS_CSI2_SEL__B_0x1() (p_CRM_IP->CRM_STATIC_BMS_CSI2_SEL.CRM_STATIC_BMS_CSI2_SEL_ts.STATIC_BMS_CSI2_SEL = STATIC_BMS_CSI2_SEL_B_0x1)
#define STATIC_BMS_CSI2_SEL_B_0x1 0x1    //CSI2RX_3D to BMS
#define Set_CRM_CRM_STATIC_BMS_CSI2_SEL(STATIC_BMS_CSI2_SEL) (p_CRM_IP->CRM_STATIC_BMS_CSI2_SEL.word = (uint32_t)STATIC_BMS_CSI2_SEL<<0)
#define Get_CRM_CRM_STATIC_BMS_CSI2_SEL() p_CRM_IP->CRM_STATIC_BMS_CSI2_SEL.word
#define Set_CRM_CRM_STATIC_BMS_CSI2_SEL_word(x) (p_CRM_IP->CRM_STATIC_BMS_CSI2_SEL.word = x)


//CRM_CLK_SD_HISPEED_SOURCE_STATUS


#define Get_CRM_CRM_CLK_SD_HISPEED_SOURCE_STATUS_CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS() p_CRM_IP->CRM_CLK_SD_HISPEED_SOURCE_STATUS.CRM_CLK_SD_HISPEED_SOURCE_STATUS_ts.CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS
#define Is_CRM_CRM_CLK_SD_HISPEED_SOURCE_STATUS_CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS_B_0x0() (p_CRM_IP->CRM_CLK_SD_HISPEED_SOURCE_STATUS.CRM_CLK_SD_HISPEED_SOURCE_STATUS_ts.CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS == CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS_B_0x0)
#define CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS_B_0x0 0x0    //sensor pixel clock
#define Is_CRM_CRM_CLK_SD_HISPEED_SOURCE_STATUS_CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS_B_0x1() (p_CRM_IP->CRM_CLK_SD_HISPEED_SOURCE_STATUS.CRM_CLK_SD_HISPEED_SOURCE_STATUS_ts.CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS == CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS_B_0x1)
#define CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS_B_0x1 0x1    //divided clk_pipe_in
#define Is_CRM_CRM_CLK_SD_HISPEED_SOURCE_STATUS_CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS_B_0x2() (p_CRM_IP->CRM_CLK_SD_HISPEED_SOURCE_STATUS.CRM_CLK_SD_HISPEED_SOURCE_STATUS_ts.CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS == CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS_B_0x2)
#define CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS_B_0x2 0x2    //transient switching clock
#define Is_CRM_CRM_CLK_SD_HISPEED_SOURCE_STATUS_CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS_B_0x3() (p_CRM_IP->CRM_CLK_SD_HISPEED_SOURCE_STATUS.CRM_CLK_SD_HISPEED_SOURCE_STATUS_ts.CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS == CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS_B_0x3)
#define CRM_CLK_SD_HISPEED_SELECTED_SOURCE_STATUS_B_0x3 0x3    //divided clk_host_ipp


#define Get_CRM_CRM_CLK_SD_HISPEED_SOURCE_STATUS_CRM_CLK_SD_HISPEED_ENABLED_SOURCE_STATUS() p_CRM_IP->CRM_CLK_SD_HISPEED_SOURCE_STATUS.CRM_CLK_SD_HISPEED_SOURCE_STATUS_ts.CRM_CLK_SD_HISPEED_ENABLED_SOURCE_STATUS
#define Get_CRM_CRM_CLK_SD_HISPEED_SOURCE_STATUS() p_CRM_IP->CRM_CLK_SD_HISPEED_SOURCE_STATUS.word


//CRM_CLK_SD_LOSPEED_SOURCE_STATUS


#define Get_CRM_CRM_CLK_SD_LOSPEED_SOURCE_STATUS_CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS() p_CRM_IP->CRM_CLK_SD_LOSPEED_SOURCE_STATUS.CRM_CLK_SD_LOSPEED_SOURCE_STATUS_ts.CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS
#define Is_CRM_CRM_CLK_SD_LOSPEED_SOURCE_STATUS_CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS_B_0x0() (p_CRM_IP->CRM_CLK_SD_LOSPEED_SOURCE_STATUS.CRM_CLK_SD_LOSPEED_SOURCE_STATUS_ts.CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS == CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS_B_0x0)
#define CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS_B_0x0 0x0    //sensor pixel clock
#define Is_CRM_CRM_CLK_SD_LOSPEED_SOURCE_STATUS_CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS_B_0x1() (p_CRM_IP->CRM_CLK_SD_LOSPEED_SOURCE_STATUS.CRM_CLK_SD_LOSPEED_SOURCE_STATUS_ts.CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS == CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS_B_0x1)
#define CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS_B_0x1 0x1    //divided clk_pipe_in
#define Is_CRM_CRM_CLK_SD_LOSPEED_SOURCE_STATUS_CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS_B_0x2() (p_CRM_IP->CRM_CLK_SD_LOSPEED_SOURCE_STATUS.CRM_CLK_SD_LOSPEED_SOURCE_STATUS_ts.CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS == CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS_B_0x2)
#define CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS_B_0x2 0x2    //transient switching clock
#define Is_CRM_CRM_CLK_SD_LOSPEED_SOURCE_STATUS_CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS_B_0x3() (p_CRM_IP->CRM_CLK_SD_LOSPEED_SOURCE_STATUS.CRM_CLK_SD_LOSPEED_SOURCE_STATUS_ts.CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS == CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS_B_0x3)
#define CRM_CLK_SD_LOSPEED_SELECTED_SOURCE_STATUS_B_0x3 0x3    //divided clk_host_ipp


#define Get_CRM_CRM_CLK_SD_LOSPEED_SOURCE_STATUS_CRM_CLK_SD_LOSPEED_ENABLED_SOURCE_STATUS() p_CRM_IP->CRM_CLK_SD_LOSPEED_SOURCE_STATUS.CRM_CLK_SD_LOSPEED_SOURCE_STATUS_ts.CRM_CLK_SD_LOSPEED_ENABLED_SOURCE_STATUS
#define Get_CRM_CRM_CLK_SD_LOSPEED_SOURCE_STATUS() p_CRM_IP->CRM_CLK_SD_LOSPEED_SOURCE_STATUS.word


//CRM_CLK_PIPE_SOURCE_STATUS


#define Get_CRM_CRM_CLK_PIPE_SOURCE_STATUS_CRM_CLK_PIPE_SELECTED_SOURCE_STATUS() p_CRM_IP->CRM_CLK_PIPE_SOURCE_STATUS.CRM_CLK_PIPE_SOURCE_STATUS_ts.CRM_CLK_PIPE_SELECTED_SOURCE_STATUS
#define Is_CRM_CRM_CLK_PIPE_SOURCE_STATUS_CRM_CLK_PIPE_SELECTED_SOURCE_STATUS_B_0x0() (p_CRM_IP->CRM_CLK_PIPE_SOURCE_STATUS.CRM_CLK_PIPE_SOURCE_STATUS_ts.CRM_CLK_PIPE_SELECTED_SOURCE_STATUS == CRM_CLK_PIPE_SELECTED_SOURCE_STATUS_B_0x0)
#define CRM_CLK_PIPE_SELECTED_SOURCE_STATUS_B_0x0 0x0    //sensor pixel clock
#define Is_CRM_CRM_CLK_PIPE_SOURCE_STATUS_CRM_CLK_PIPE_SELECTED_SOURCE_STATUS_B_0x1() (p_CRM_IP->CRM_CLK_PIPE_SOURCE_STATUS.CRM_CLK_PIPE_SOURCE_STATUS_ts.CRM_CLK_PIPE_SELECTED_SOURCE_STATUS == CRM_CLK_PIPE_SELECTED_SOURCE_STATUS_B_0x1)
#define CRM_CLK_PIPE_SELECTED_SOURCE_STATUS_B_0x1 0x1    //divided clk_pipe_in
#define Is_CRM_CRM_CLK_PIPE_SOURCE_STATUS_CRM_CLK_PIPE_SELECTED_SOURCE_STATUS_B_0x2() (p_CRM_IP->CRM_CLK_PIPE_SOURCE_STATUS.CRM_CLK_PIPE_SOURCE_STATUS_ts.CRM_CLK_PIPE_SELECTED_SOURCE_STATUS == CRM_CLK_PIPE_SELECTED_SOURCE_STATUS_B_0x2)
#define CRM_CLK_PIPE_SELECTED_SOURCE_STATUS_B_0x2 0x2    //transient switching clock
#define Is_CRM_CRM_CLK_PIPE_SOURCE_STATUS_CRM_CLK_PIPE_SELECTED_SOURCE_STATUS_B_0x3() (p_CRM_IP->CRM_CLK_PIPE_SOURCE_STATUS.CRM_CLK_PIPE_SOURCE_STATUS_ts.CRM_CLK_PIPE_SELECTED_SOURCE_STATUS == CRM_CLK_PIPE_SELECTED_SOURCE_STATUS_B_0x3)
#define CRM_CLK_PIPE_SELECTED_SOURCE_STATUS_B_0x3 0x3    //divided clk_host_ipp


#define Get_CRM_CRM_CLK_PIPE_SOURCE_STATUS_CRM_CLK_PIPE_ENABLED_SOURCE_STATUS() p_CRM_IP->CRM_CLK_PIPE_SOURCE_STATUS.CRM_CLK_PIPE_SOURCE_STATUS_ts.CRM_CLK_PIPE_ENABLED_SOURCE_STATUS
#define Get_CRM_CRM_CLK_PIPE_SOURCE_STATUS() p_CRM_IP->CRM_CLK_PIPE_SOURCE_STATUS.word


//CRM_CLK_BMS_SOURCE_STATUS


#define Get_CRM_CRM_CLK_BMS_SOURCE_STATUS_CRM_CLK_BMS_SELECTED_SOURCE_STATUS() p_CRM_IP->CRM_CLK_BMS_SOURCE_STATUS.CRM_CLK_BMS_SOURCE_STATUS_ts.CRM_CLK_BMS_SELECTED_SOURCE_STATUS
#define Is_CRM_CRM_CLK_BMS_SOURCE_STATUS_CRM_CLK_BMS_SELECTED_SOURCE_STATUS_B_0x0() (p_CRM_IP->CRM_CLK_BMS_SOURCE_STATUS.CRM_CLK_BMS_SOURCE_STATUS_ts.CRM_CLK_BMS_SELECTED_SOURCE_STATUS == CRM_CLK_BMS_SELECTED_SOURCE_STATUS_B_0x0)
#define CRM_CLK_BMS_SELECTED_SOURCE_STATUS_B_0x0 0x0    //sensor pixel clock
#define Is_CRM_CRM_CLK_BMS_SOURCE_STATUS_CRM_CLK_BMS_SELECTED_SOURCE_STATUS_B_0x1() (p_CRM_IP->CRM_CLK_BMS_SOURCE_STATUS.CRM_CLK_BMS_SOURCE_STATUS_ts.CRM_CLK_BMS_SELECTED_SOURCE_STATUS == CRM_CLK_BMS_SELECTED_SOURCE_STATUS_B_0x1)
#define CRM_CLK_BMS_SELECTED_SOURCE_STATUS_B_0x1 0x1    //divided clk_pipe_in
#define Is_CRM_CRM_CLK_BMS_SOURCE_STATUS_CRM_CLK_BMS_SELECTED_SOURCE_STATUS_B_0x2() (p_CRM_IP->CRM_CLK_BMS_SOURCE_STATUS.CRM_CLK_BMS_SOURCE_STATUS_ts.CRM_CLK_BMS_SELECTED_SOURCE_STATUS == CRM_CLK_BMS_SELECTED_SOURCE_STATUS_B_0x2)
#define CRM_CLK_BMS_SELECTED_SOURCE_STATUS_B_0x2 0x2    //transient switching clock
#define Is_CRM_CRM_CLK_BMS_SOURCE_STATUS_CRM_CLK_BMS_SELECTED_SOURCE_STATUS_B_0x3() (p_CRM_IP->CRM_CLK_BMS_SOURCE_STATUS.CRM_CLK_BMS_SOURCE_STATUS_ts.CRM_CLK_BMS_SELECTED_SOURCE_STATUS == CRM_CLK_BMS_SELECTED_SOURCE_STATUS_B_0x3)
#define CRM_CLK_BMS_SELECTED_SOURCE_STATUS_B_0x3 0x3    //divided clk_host_ipp


#define Get_CRM_CRM_CLK_BMS_SOURCE_STATUS_CRM_CLK_BMS_ENABLED_SOURCE_STATUS() p_CRM_IP->CRM_CLK_BMS_SOURCE_STATUS.CRM_CLK_BMS_SOURCE_STATUS_ts.CRM_CLK_BMS_ENABLED_SOURCE_STATUS
#define Get_CRM_CRM_CLK_BMS_SOURCE_STATUS() p_CRM_IP->CRM_CLK_BMS_SOURCE_STATUS.word


//CRM_CLK_PICTOR_GPIO_SOURCE_STATUS


#define Get_CRM_CRM_CLK_PICTOR_GPIO_SOURCE_STATUS_CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS() p_CRM_IP->CRM_CLK_PICTOR_GPIO_SOURCE_STATUS.CRM_CLK_PICTOR_GPIO_SOURCE_STATUS_ts.CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS
#define Is_CRM_CRM_CLK_PICTOR_GPIO_SOURCE_STATUS_CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS_B_0x0() (p_CRM_IP->CRM_CLK_PICTOR_GPIO_SOURCE_STATUS.CRM_CLK_PICTOR_GPIO_SOURCE_STATUS_ts.CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS == CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS_B_0x0)
#define CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS_B_0x0 0x0    //sensor pixel clock
#define Is_CRM_CRM_CLK_PICTOR_GPIO_SOURCE_STATUS_CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS_B_0x1() (p_CRM_IP->CRM_CLK_PICTOR_GPIO_SOURCE_STATUS.CRM_CLK_PICTOR_GPIO_SOURCE_STATUS_ts.CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS == CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS_B_0x1)
#define CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS_B_0x1 0x1    //divided clk_pipe_in
#define Is_CRM_CRM_CLK_PICTOR_GPIO_SOURCE_STATUS_CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS_B_0x2() (p_CRM_IP->CRM_CLK_PICTOR_GPIO_SOURCE_STATUS.CRM_CLK_PICTOR_GPIO_SOURCE_STATUS_ts.CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS == CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS_B_0x2)
#define CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS_B_0x2 0x2    //transient switching clock
#define Is_CRM_CRM_CLK_PICTOR_GPIO_SOURCE_STATUS_CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS_B_0x3() (p_CRM_IP->CRM_CLK_PICTOR_GPIO_SOURCE_STATUS.CRM_CLK_PICTOR_GPIO_SOURCE_STATUS_ts.CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS == CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS_B_0x3)
#define CRM_CLK_PICTOR_GPIO_SELECTED_SOURCE_STATUS_B_0x3 0x3    //divided clk_host_ipp


#define Get_CRM_CRM_CLK_PICTOR_GPIO_SOURCE_STATUS_CRM_CLK_PICTOR_GPIO_ENABLED_SOURCE_STATUS() p_CRM_IP->CRM_CLK_PICTOR_GPIO_SOURCE_STATUS.CRM_CLK_PICTOR_GPIO_SOURCE_STATUS_ts.CRM_CLK_PICTOR_GPIO_ENABLED_SOURCE_STATUS
#define Get_CRM_CRM_CLK_PICTOR_GPIO_SOURCE_STATUS() p_CRM_IP->CRM_CLK_PICTOR_GPIO_SOURCE_STATUS.word


//CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS


#define Get_CRM_CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS_CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS() p_CRM_IP->CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS.CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS_ts.CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS
#define Is_CRM_CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS_CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS_B_0x0() (p_CRM_IP->CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS.CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS_ts.CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS == CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS_B_0x0)
#define CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS_B_0x0 0x0    //sensor pixel clock (not in emulated clock mode)
#define Is_CRM_CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS_CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS_B_0x1() (p_CRM_IP->CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS.CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS_ts.CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS == CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS_B_0x1)
#define CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS_B_0x1 0x1    //divided clk_pipe_in (unused by now)
#define Is_CRM_CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS_CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS_B_0x2() (p_CRM_IP->CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS.CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS_ts.CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS == CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS_B_0x2)
#define CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS_B_0x2 0x2    //transient switching clock
#define Is_CRM_CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS_CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS_B_0x3() (p_CRM_IP->CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS.CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS_ts.CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS == CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS_B_0x3)
#define CRM_CLK_SD_3D_HISPEED_SELECTED_SOURCE_STATUS_B_0x3 0x3    //divided clk_host_ipp


#define Get_CRM_CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS_CRM_CLK_SD_3D_HISPEED_ENABLED_SOURCE_STATUS() p_CRM_IP->CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS.CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS_ts.CRM_CLK_SD_3D_HISPEED_ENABLED_SOURCE_STATUS
#define Get_CRM_CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS() p_CRM_IP->CRM_CLK_SD_3D_HISPEED_SOURCE_STATUS.word

extern volatile CRM_IP_ts *p_CRM_IP;

#endif 

