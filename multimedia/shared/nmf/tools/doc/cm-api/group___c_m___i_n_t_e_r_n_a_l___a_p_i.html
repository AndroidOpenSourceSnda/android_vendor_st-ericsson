<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>NMF Component Manager Documentation: CM Proxy Internal API (used by generated code)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<small><b>
<a href="http://www.stericsson.com"><img src="logo.jpg" width=220 height=68></a>
 WMM/MCP/MMD <a href="https://codex.cro.st.com/projects/nmf/">Nomadik Multiprocessing Framework</a>
</b></small>
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>CM Proxy Internal API (used by generated code)<br/>
<small>
[<a class="el" href="group___c_m___p_r_o_x_y___m_o_d_u_l_e.html">CM Proxy</a>]</small>
</h1>
<p>Component Manager Internal API for stubs.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for CM Proxy Internal API (used by generated code):</div>
<div class="dynsection">
<center><table><tr><td><img src="group___c_m___i_n_t_e_r_n_a_l___a_p_i.png" border="0" alt="" usemap="#group______c__m______i__n__t__e__r__n__a__l______a__p__i_map"/>
<map name="group______c__m______i__n__t__e__r__n__a__l______a__p__i_map" id="group______c__m______i__n__t__e__r__n__a__l______a__p__i">
<area shape="rect" href="group___c_m___p_r_o_x_y___m_o_d_u_l_e.html" title="CM Proxy" alt="" coords="5,5,85,35"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__service__entry.html">t_service_entry</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Component Manager Communication Type.  <a href="structt__service__entry.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__channel__entry.html">t_channel_entry</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">There is one such entry per opened channel.  <a href="structt__channel__entry.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="group___c_m___e_n_g_i_n_e___a_p_i.html#gacb472f3bf94f3cac513a65ff8520ce66">t_event_params_handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga844ad07ceb9dba13289502768d14e272">CM_INTERNAL_AllocEvent</a> (<a class="el" href="group___c_m___e_n_g_i_n_e___a_p_i.html#gadd9abf4afdde37539dfcc37a2d1584c4">t_cm_bf_host2mpc_handle</a> host2mpcId)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate Event buffer where parameters will be marshalled.  <a href="#ga844ad07ceb9dba13289502768d14e272"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="group__t__cm__error.html#ga0c6e4897ef6a9f579c3dcac1b697141b">t_cm_error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga8e5a23472d8fbb4d34189b0dc03910d0">CM_INTERNAL_PushEvent</a> (<a class="el" href="group___c_m___e_n_g_i_n_e___a_p_i.html#gadd9abf4afdde37539dfcc37a2d1584c4">t_cm_bf_host2mpc_handle</a> host2mpcId, <a class="el" href="group___c_m___e_n_g_i_n_e___a_p_i.html#gacb472f3bf94f3cac513a65ff8520ce66">t_event_params_handle</a> h, <a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga5543ed798da376a99db035f6ae6aaa1f">t_uint32</a> methodIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Push a event in Fifo.  <a href="#ga8e5a23472d8fbb4d34189b0dc03910d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED <a class="el" href="group__t__cm__error.html#ga0c6e4897ef6a9f579c3dcac1b697141b">t_cm_error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#gac82969f4fef95305913696da7e85d586">CM_INTERNAL_PushEventWithSize</a> (<a class="el" href="group___c_m___e_n_g_i_n_e___a_p_i.html#gadd9abf4afdde37539dfcc37a2d1584c4">t_cm_bf_host2mpc_handle</a> host2mpcId, <a class="el" href="group___c_m___e_n_g_i_n_e___a_p_i.html#gacb472f3bf94f3cac513a65ff8520ce66">t_event_params_handle</a> h, <a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga5543ed798da376a99db035f6ae6aaa1f">t_uint32</a> size, <a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga5543ed798da376a99db035f6ae6aaa1f">t_uint32</a> methodIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Push a event in Fifo.  <a href="#gac82969f4fef95305913696da7e85d586"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga15cbe35fb6fa823f82f8efb688e2616b">CM_INTERNAL_RegisterHost2MpcInterfaces</a> (t_nmf_stub_register *pInterfacesArray)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Host stubs registering facilities.  <a href="#ga15cbe35fb6fa823f82f8efb688e2616b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga59d3ead4e35d597cac0a2c11bee0b323">CM_INTERNAL_UnregisterHost2MpcInterfaces</a> (t_nmf_stub_register *pInterfacesArray)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Host stubs unregistering facilities.  <a href="#ga59d3ead4e35d597cac0a2c11bee0b323"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga4a862111cb353b5d11c1f7720c140e1a">CM_INTERNAL_RegisterMpc2HostInterfaces</a> (t_nmf_skel_register *pInterfacesArray)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Host skeletons registering facilities.  <a href="#ga4a862111cb353b5d11c1f7720c140e1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC IMPORT_SHARED void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#gac1906fdfeefff21b8a7f6f052bbf5bd5">CM_INTERNAL_UnregisterMpc2HostInterfaces</a> (t_nmf_skel_register *pInterfacesArray)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Host skeletons unregistering facilities.  <a href="#gac1906fdfeefff21b8a7f6f052bbf5bd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga52623b8c1e7c0101c5eed78ea963496f">CM_INTERNAL_ProxyInit</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Very early init of the CM Proxy.  <a href="#ga52623b8c1e7c0101c5eed78ea963496f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga2434a24a7919f46ae5f376c8cbcd3b9a">CM_INTERNAL_ProxyDestroy</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy of the CM Proxy.  <a href="#ga2434a24a7919f46ae5f376c8cbcd3b9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga9fa6395b40c79b14072f8f8fb5f05309">CM_INTERNAL_Init</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the CM Proxy.  <a href="#ga9fa6395b40c79b14072f8f8fb5f05309"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga05a28f4167ee6c656f563ec42905bb77">CM_INTERNAL_Destroy</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy the CM Proxy.  <a href="#ga05a28f4167ee6c656f563ec42905bb77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#gac14051b9da9c929fe584a79bfcda578a">CM_INTERNAL_CreateChannel</a> (<a class="el" href="group____t__nmf__channel__flag.html#ga673eb84bed6799730e793b5e37439ffc">t_nmf_channel_flag</a> flags, <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga83e5886d66e2e3a546f5be82d58512df">t_nmf_channel</a> *channel, <a class="el" href="group___c_m___o_s___a_p_i.html#ga156144063090c4c43cc67a46f2b415a7">t_os_channel</a> **OSchannel)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create/get a channel.  <a href="#gac14051b9da9c929fe584a79bfcda578a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga94688c3bf56f11c0d1c7fba912afabcb">CM_INTERNAL_FlushChannel</a> (<a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga83e5886d66e2e3a546f5be82d58512df">t_nmf_channel</a> channel, <a class="el" href="group___c_m___o_s___a_p_i.html#ga156144063090c4c43cc67a46f2b415a7">t_os_channel</a> *OSchannel)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush a channel.  <a href="#ga94688c3bf56f11c0d1c7fba912afabcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga2cd9c16b7b9260d846c66304853c9db7">CM_INTERNAL_CloseChannel</a> (<a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga83e5886d66e2e3a546f5be82d58512df">t_nmf_channel</a> channel, <a class="el" href="group___c_m___o_s___a_p_i.html#ga156144063090c4c43cc67a46f2b415a7">t_os_channel</a> *pOSchannel)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a channel.  <a href="#ga2cd9c16b7b9260d846c66304853c9db7"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Component Manager Internal API for stubs. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This API is not for developers, this API is only an internal API.<br/>
</dd></dl>
<p>This API is used internally by code generated by <a class="el" href="namespace_n_m_f.html" title="C++ component abstract definition.">NMF</a>. This code will be linked with application and CM proxy.</p>
<p>If no concurrent access will be perform, a method call is enough and dependencies will be handle by link. If not, it could be necessary to wrap this API during the system integration. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga844ad07ceb9dba13289502768d14e272"></a><!-- doxytag: member="stub&#45;requiredapi.h::CM_INTERNAL_AllocEvent" ref="ga844ad07ceb9dba13289502768d14e272" args="(t_cm_bf_host2mpc_handle host2mpcId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="group___c_m___e_n_g_i_n_e___a_p_i.html#gacb472f3bf94f3cac513a65ff8520ce66">t_event_params_handle</a> CM_INTERNAL_AllocEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_m___e_n_g_i_n_e___a_p_i.html#gadd9abf4afdde37539dfcc37a2d1584c4">t_cm_bf_host2mpc_handle</a>&nbsp;</td>
          <td class="paramname"> <em>host2mpcId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate Event buffer where parameters will be marshalled. </p>
<p>The purpose of this pre-allocation is to avoid copy.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host2mpcId</em>&nbsp;</td><td>Host -&gt; MPC param id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Event param handle. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2cd9c16b7b9260d846c66304853c9db7"></a><!-- doxytag: member="communication_internal.h::CM_INTERNAL_CloseChannel" ref="ga2cd9c16b7b9260d846c66304853c9db7" args="(t_nmf_channel channel, t_os_channel *pOSchannel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a> CM_INTERNAL_CloseChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga83e5886d66e2e3a546f5be82d58512df">t_nmf_channel</a>&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_m___o_s___a_p_i.html#ga156144063090c4c43cc67a46f2b415a7">t_os_channel</a> *&nbsp;</td>
          <td class="paramname"> <em>pOSchannel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a channel. </p>
<p>The purpose of the function is to destroy or clear a reference to a channel from the user to the CM engine in the common User Proxy Part. This function must be called by <a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga02edd0ce2d444394a41282520c3ff69c">CM_CloseChannel()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>Channel number: </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pOSchannel</em>&nbsp;</td><td>If successful, *pOSchannel is filled. If *pOSchannel is not 0, the OS Integration have to destroy the channel pointed by pOSchannel</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CM_INVALID_PARAMETER</em>&nbsp;</td><td>The specified channel is invalid or some callback are still registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac14051b9da9c929fe584a79bfcda578a"></a><!-- doxytag: member="communication_internal.h::CM_INTERNAL_CreateChannel" ref="gac14051b9da9c929fe584a79bfcda578a" args="(t_nmf_channel_flag flags, t_nmf_channel *channel, t_os_channel **OSchannel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a> CM_INTERNAL_CreateChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group____t__nmf__channel__flag.html#ga673eb84bed6799730e793b5e37439ffc">t_nmf_channel_flag</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga83e5886d66e2e3a546f5be82d58512df">t_nmf_channel</a> *&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_m___o_s___a_p_i.html#ga156144063090c4c43cc67a46f2b415a7">t_os_channel</a> **&nbsp;</td>
          <td class="paramname"> <em>OSchannel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create/get a channel. </p>
<p>The purpose of the function is to create a channel or get a channel a channel entry in the common User Proxy Part, regarding the flag parameter This function must be called by <a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga7a4218590ff148870199bbfb384095ef">CM_CreateChannel()</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Whether the caller want to create a new channel (NMF_CHANNEL_PRIVATE) or use the shared one (NMF_CHANNEL_SHARED) (it will be created if it does not yet exist) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>Channel number. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>OSchannel</em>&nbsp;</td><td>If *OSchannel is not NULL, the OS Integrator has to create an os_channel and set **OSchannel.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CM_NO_MORE_MEMORY</em>&nbsp;</td><td>Not enough memory to create the callback Channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CM_INVALID_PARAMETER</em>&nbsp;</td><td>The specified flags is invalid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CM_INTEGRATION_ERROR</em>&nbsp;</td><td>OS specific error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga05a28f4167ee6c656f563ec42905bb77"></a><!-- doxytag: member="communication_internal.h::CM_INTERNAL_Destroy" ref="ga05a28f4167ee6c656f563ec42905bb77" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC void CM_INTERNAL_Destroy </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy the CM Proxy. </p>
<p>The purpose of the function is to:</p>
<ul>
<li>destroy all ressources allocated by the CM User Proxy.</li>
</ul>
<p>It must be called, once, by the OS Integrator at the last <a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga02edd0ce2d444394a41282520c3ff69c">CM_CloseChannel()</a> call. It's up to the OS Integrator to manage concurrent access to this call.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>It MUST be called only once, if a <a class="el" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga9fa6395b40c79b14072f8f8fb5f05309" title="Initialize the CM Proxy.">CM_INTERNAL_Init()</a> has been called before, once all previously allocated ressources have been freed </dd></dl>

</div>
</div>
<a class="anchor" id="ga94688c3bf56f11c0d1c7fba912afabcb"></a><!-- doxytag: member="communication_internal.h::CM_INTERNAL_FlushChannel" ref="ga94688c3bf56f11c0d1c7fba912afabcb" args="(t_nmf_channel channel, t_os_channel *OSchannel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a> CM_INTERNAL_FlushChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga83e5886d66e2e3a546f5be82d58512df">t_nmf_channel</a>&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_m___o_s___a_p_i.html#ga156144063090c4c43cc67a46f2b415a7">t_os_channel</a> *&nbsp;</td>
          <td class="paramname"> <em>OSchannel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush a channel. </p>
<p>The purpose of this function is to return OSchannel need by OS Integration. In case of shared channel if reference counter will not be zero on next close then we return 0 in OSchannel, in that case OS integration must not generate CM_FLUSH_MESSAGE.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>Channel number: </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>OSchannel</em>&nbsp;</td><td>Is *OSchannel is not NULL, the OS integrator has to generate a CM_FLUSH_MESSAGE error in <a class="el" href="group___c_m___c_a_l_l_b_a_c_k___a_p_i.html#ga3a22d66689ae843f9c00a35bf64dc6d2" title="Get received message from specified callback channel.">CM_GetMessage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9fa6395b40c79b14072f8f8fb5f05309"></a><!-- doxytag: member="communication_internal.h::CM_INTERNAL_Init" ref="ga9fa6395b40c79b14072f8f8fb5f05309" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="group___n_m_f___c_o_m_m_o_n___t_y_p_e.html#ga1c0966cee0197433dbfcb1867f30d727">t_nmf_error</a> CM_INTERNAL_Init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the CM Proxy. </p>
<p>The purpose of the function is to:</p>
<ul>
<li>initialize the CM User Proxy.</li>
</ul>
<p>It must be called once, by the OS Integrator, at the first <a class="el" href="group___c_m___c_o_n_f_i_g_u_r_a_t_i_o_n___a_p_i.html#ga7a4218590ff148870199bbfb384095ef">CM_CreateChannel()</a> call. It's up to the OS Integrator to manage concurrent access to this call.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>It MUST be called only once, unless <a class="el" href="group___c_m___i_n_t_e_r_n_a_l___a_p_i.html#ga05a28f4167ee6c656f563ec42905bb77" title="Destroy the CM Proxy.">CM_INTERNAL_Destroy()</a> has been called before.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CM_NO_MORE_MEMORY</em>&nbsp;</td><td>Not enough memory to create the callback Channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CM_INTEGRATION_ERROR</em>&nbsp;</td><td>OS specific error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2434a24a7919f46ae5f376c8cbcd3b9a"></a><!-- doxytag: member="communication_internal.h::CM_INTERNAL_ProxyDestroy" ref="ga2434a24a7919f46ae5f376c8cbcd3b9a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC void CM_INTERNAL_ProxyDestroy </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy of the CM Proxy. </p>
<p>The purpose of the function is to:</p>
<ul>
<li>destroy the cery last ressources used in the CM User Proxy library.</li>
</ul>
<p>It must be called once, at exit() of the user program is called </p>

</div>
</div>
<a class="anchor" id="ga52623b8c1e7c0101c5eed78ea963496f"></a><!-- doxytag: member="communication_internal.h::CM_INTERNAL_ProxyInit" ref="ga52623b8c1e7c0101c5eed78ea963496f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC void CM_INTERNAL_ProxyInit </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Very early init of the CM Proxy. </p>
<p>The purpose of the function is to:</p>
<ul>
<li>initialize the CM User Proxy library.</li>
</ul>
<p>It must be called once, before the main() function of the user program is called </p>

</div>
</div>
<a class="anchor" id="ga8e5a23472d8fbb4d34189b0dc03910d0"></a><!-- doxytag: member="stub&#45;requiredapi.h::CM_INTERNAL_PushEvent" ref="ga8e5a23472d8fbb4d34189b0dc03910d0" args="(t_cm_bf_host2mpc_handle host2mpcId, t_event_params_handle h, t_uint32 methodIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC <a class="el" href="group__t__cm__error.html#ga0c6e4897ef6a9f579c3dcac1b697141b">t_cm_error</a> CM_INTERNAL_PushEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_m___e_n_g_i_n_e___a_p_i.html#gadd9abf4afdde37539dfcc37a2d1584c4">t_cm_bf_host2mpc_handle</a>&nbsp;</td>
          <td class="paramname"> <em>host2mpcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_m___e_n_g_i_n_e___a_p_i.html#gacb472f3bf94f3cac513a65ff8520ce66">t_event_params_handle</a>&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga5543ed798da376a99db035f6ae6aaa1f">t_uint32</a>&nbsp;</td>
          <td class="paramname"> <em>methodIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push a event in Fifo. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host2mpcId</em>&nbsp;</td><td>Host -&gt; MPC param id. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>h</em>&nbsp;</td><td>Event param handle. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>methodIndex</em>&nbsp;</td><td>Index in the interface of the method to be called.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CM_MPC_NOT_RESPONDING</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac82969f4fef95305913696da7e85d586"></a><!-- doxytag: member="stub&#45;requiredapi.h::CM_INTERNAL_PushEventWithSize" ref="gac82969f4fef95305913696da7e85d586" args="(t_cm_bf_host2mpc_handle host2mpcId, t_event_params_handle h, t_uint32 size, t_uint32 methodIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED <a class="el" href="group__t__cm__error.html#ga0c6e4897ef6a9f579c3dcac1b697141b">t_cm_error</a> CM_INTERNAL_PushEventWithSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_m___e_n_g_i_n_e___a_p_i.html#gadd9abf4afdde37539dfcc37a2d1584c4">t_cm_bf_host2mpc_handle</a>&nbsp;</td>
          <td class="paramname"> <em>host2mpcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_m___e_n_g_i_n_e___a_p_i.html#gacb472f3bf94f3cac513a65ff8520ce66">t_event_params_handle</a>&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga5543ed798da376a99db035f6ae6aaa1f">t_uint32</a>&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___n_m_f___p_r_i_m_i_t_i_v_e___t_y_p_e.html#ga5543ed798da376a99db035f6ae6aaa1f">t_uint32</a>&nbsp;</td>
          <td class="paramname"> <em>methodIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push a event in Fifo. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host2mpcId</em>&nbsp;</td><td>Host -&gt; MPC param id. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>h</em>&nbsp;</td><td>Event param handle. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>Event param size. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>methodIndex</em>&nbsp;</td><td>Index in the interface of the method to be called.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CM_PARAM_FIFO_FULL</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CM_MPC_NOT_RESPONDING</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga15cbe35fb6fa823f82f8efb688e2616b"></a><!-- doxytag: member="stub&#45;requiredapi.h::CM_INTERNAL_RegisterHost2MpcInterfaces" ref="ga15cbe35fb6fa823f82f8efb688e2616b" args="(t_nmf_stub_register *pInterfacesArray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED void CM_INTERNAL_RegisterHost2MpcInterfaces </td>
          <td>(</td>
          <td class="paramtype">t_nmf_stub_register *&nbsp;</td>
          <td class="paramname"> <em>pInterfacesArray</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Host stubs registering facilities. </p>
<p>Not used directly by user (used only by CM_REGISTER_XX macros)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pInterfacesArray</em>&nbsp;</td><td>Stubs array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4a862111cb353b5d11c1f7720c140e1a"></a><!-- doxytag: member="stub&#45;requiredapi.h::CM_INTERNAL_RegisterMpc2HostInterfaces" ref="ga4a862111cb353b5d11c1f7720c140e1a" args="(t_nmf_skel_register *pInterfacesArray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED void CM_INTERNAL_RegisterMpc2HostInterfaces </td>
          <td>(</td>
          <td class="paramtype">t_nmf_skel_register *&nbsp;</td>
          <td class="paramname"> <em>pInterfacesArray</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Host skeletons registering facilities. </p>
<p>Not used directly by user (used only by CM_REGISTER_XX macros)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pInterfacesArray</em>&nbsp;</td><td>Skels array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga59d3ead4e35d597cac0a2c11bee0b323"></a><!-- doxytag: member="stub&#45;requiredapi.h::CM_INTERNAL_UnregisterHost2MpcInterfaces" ref="ga59d3ead4e35d597cac0a2c11bee0b323" args="(t_nmf_stub_register *pInterfacesArray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED void CM_INTERNAL_UnregisterHost2MpcInterfaces </td>
          <td>(</td>
          <td class="paramtype">t_nmf_stub_register *&nbsp;</td>
          <td class="paramname"> <em>pInterfacesArray</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Host stubs unregistering facilities. </p>
<p>Not used directly by user (used only by CM_REGISTER_XX macros)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pInterfacesArray</em>&nbsp;</td><td>Stubs array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac1906fdfeefff21b8a7f6f052bbf5bd5"></a><!-- doxytag: member="stub&#45;requiredapi.h::CM_INTERNAL_UnregisterMpc2HostInterfaces" ref="gac1906fdfeefff21b8a7f6f052bbf5bd5" args="(t_nmf_skel_register *pInterfacesArray)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC IMPORT_SHARED void CM_INTERNAL_UnregisterMpc2HostInterfaces </td>
          <td>(</td>
          <td class="paramtype">t_nmf_skel_register *&nbsp;</td>
          <td class="paramname"> <em>pInterfacesArray</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Host skeletons unregistering facilities. </p>
<p>Not used directly by user (used only by CM_REGISTER_XX macros)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pInterfacesArray</em>&nbsp;</td><td>Skels array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr size="1">
<address style="align: right;"><small> 
<b>NMF Component Manager Documentation</b> generated by <a href="http://www.doxygen.org">doxygen</a> 1.6.3 on 28 Oct 2011
</small></address>
<address style="align: right;"><small>
Copyright 2006-2009 <a href="http://www.stericsson.com"><b>ST-Ericsson</b></a>
 - Confidential document - Unauthorized reproduction and communication strictly prohibited
</small></address>
</body>
</html>
