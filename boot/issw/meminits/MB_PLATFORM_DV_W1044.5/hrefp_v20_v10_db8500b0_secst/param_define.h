/*----------------------------------------------------------------------------*
 *      Copyright 2000-2005, STMicroelectronics, Incorporated.                *
 *      All rights reserved.                                                  *
 *                                                                            *
 *        STMICROELECTRONICS, INCORPORATED PROPRIETARY INFORMATION            *
 * This software is supplied under the terms of a license agreement or nondis-*
 * closure agreement with STMicroelectronics and may not be copied or disclo- *
 * sed except in accordance with the terms of that agreement.                 *
 *----------------------------------------------------------------------------*
 * System           : STxP70 Processor                                        *
 * Project Component: System Library                                          *
 * File Name        : param_define.h                                         *
 * Purpose          : parameters definitions used by prcmufw.c file           *
 * History          : 2009/09/21 - First implementation.                      *
 *----------------------------------------------------------------------------*/
#ifndef _PARAM_DEFINE_H
#define _PARAM_DEFINE_H

#include "defs.h"

////////////////////////////////////////////
// PRCMU function choice for the compilation
// because code size is reached for AB8500A1
////////////////////////////////////////////
#ifdef DB8500A1

  //DEBUG service isn't available
  //  #define DEBUG_ACCESS		// IT14.

  //ANC service isn't available
  //  #define ANC_ACCESS			// IT13.

  //SVAMMDSP service is available
  #define SVAMMDSP_ACCESS		// IT18, IT generated by SVAMMDSP is available

  //DDR particular service isn't available
  //  #define DDRSERVICE_ACCESS	// on IT16, remove partialSrefreshCSxH/ SrefreshCSxH/QoSPortxH 

  //AVS service isn't available
  //  #define AVS_ACCESS			// on IT16, remove AvsH 

  //ROMCODE_PATCH_VALIDATION isn't available
  // #define ROMCODE_PATCH_VALIDATION  // allow to validate romcode_patch

  //DEEPIDLE power state isn't available
  //  #define DEEPIDLE_ACCESS

  //GENI2C Read modify write service isn't available
  //  #define GENI2CRW_ACCESS
  
#endif

#ifdef DB8500B0

  //DEBUG service is available
//  #define DEBUG_ACCESS		// IT14.

#endif



//////////////////////
/// SIMULATION SETTING
//////////////////////
#ifdef MAPSIMU_CODE

  // shorter timing are used to accelerate simulation
  #define SIMULATION

  // Put here code that is meant to be executed on the VHDL platform (map)
  #undef _IO_
  #define _IO_(x)
  #define _PROBE_INT_(y)
  #define _BOOTSTATUS_(x) share_var.boot_status_debug_var = x;
  #define _DEBUG_(x) PRCMUREG->PRCM_STM_DATA = x;

  // allow to write _DEBUG_((t_STM)POLFCT_TIMER) into polling_fct
  #define STM_POLFCT_TIMER

#endif

//////////////////////////////////
/// DEVELOPMENT VERSION 
//////////////////////////////////
#ifdef DEV_CODE

/* Put here code that is meant to be executed on the xp70 toolset (dev) */
#undef _IO_
#define _IO_(x) x
#define _PROBE_INT_(y) printf("Value of <" #y "> = %u (%#X)\n", y, y);
#define _BOOTSTATUS_(x) share_var.boot_status_debug_var = x;
#define _DEBUG_(x) PRCMUREG->PRCM_STM_DATA = x; printf("PRCMUREG->PRCM_STM_DATA = %3u : %s\n", x, #x);

//#define _DEBUG_(x) share_var.boot_status_debug_var = x; printf("boot_status_debug_var = %u\n", x);

#endif

//////////////////////////////////
/// MAPPING REAL VERSION 
//////////////////////////////////
#ifdef MAP_CODE

  // true timing are used 
  //#define SIMULATION

 /* Put here code that is meant to be executed on the VHDL platform (map) */
  #undef _IO_
  #define _IO_(x)
  #define _PROBE_INT_(y)
  #define _BOOTSTATUS_(x) share_var.boot_status_debug_var = x;
  #define _DEBUG_(x) PRCMUREG->PRCM_STM_DATA = x;

  // _DEBUG_((t_STM)POLFCT_TIMER) isn't wrote into polling_fct
  // #define STM_POLFCT_TIMER

#endif

///////////////////////////////////
// DEFINE for ReqMb0
///////////////////////////////////
#define NB_HWEVT4500 	20	/* number of mailbox 8bit to write wake up reason coming from ST4500 */

///////////////////////////////////
// DEFINE for ESRAM0
///////////////////////////////////
#define PRCMUPRCM_ESRAM0_EPOD_C_SETESRAM0_OFF 	0	

////////////////////////////////////////////////////
// DEFINE for romcode mailbox message when deep_idle
////////////////////////////////////////////////////
#define VALINIT_ROMCODE_BOX	0x01000000

///////////////////////////////////
// DEFINE for DENALI CONTROLER
///////////////////////////////////
#define NB_MASK					5	/* number of word 32b to mask the DENALI controler regiters that are not to configure */
#define DENALI_CTL_MAX_VALUE 	144+1 /* last DENALI_CTL register to load +1 */
#define NB_BIT					32
#define LAST_LOOP_INDICE		DENALI_CTL_MAX_VALUE-((NB_MASK-1)*NB_BIT)
#define MASK_DDR_SIZE			0xE0000000	/* mask used to extract DDR size value */


//////////////////////////////////
/// DEFINE VARIABLE DESCRIPTION
//////////////////////////////////
 
#define PRCMUREG_I2C_SECURE ((volatile struct s_PRCMU *) 0x00808000)
#define PRCMUREG	((volatile struct s_PRCMU *) 0x00807000)
#define DBAHN 		((volatile struct s_DBAHN *) 0x00806000)
#define TCDM_BEG  ((volatile struct s_initTCDM *) 0x00000000)
#define SVAMMDSPREG  ((volatile struct s_MMDSP *) 0x00807680)
#define SIAMMDSPREG  ((volatile struct s_MMDSP *) 0x00807A80)

// MMDSP STATUS
#define MMDSP_UCMD_CTRL_STATUS_ACCESS	0x10
#define MMDSP_UCMD_WRITE				0
#define MMDSP_UCMD_READ					4
#define MMDSP_UBKCMD_EXT_CODE_MEM_ACCESS_ENABLE    (1 << 3)
#define MMDSP_CLOCKCMD_START_CLOCK        0
#define SVAMMDSP_ON						0x00000200
#define SIAMMDSP_ON						0x00000040
#define SVAMMDSP_OFF_TCMRET				0x00000100
#define SIAMMDSP_OFF_TCMRET				0x00000020

//Configure (by SIAMMDSP) fifo4500it as wakeup event or not
//FIFO4500IT is unmasked
#define FIFO4500IT_UNMASKED		0xFFFFFEFF
//FIFO4500IT is masked
#define FIFO4500IT_MASKED		0x00000100


// indirect adress for MMDSPs context saving/restoring
#define NB_MMDSP_CONTEXT_ADDR   17
#define stbus_id_config			0x08
#define stbus_timeout			0x0e
#define prg_base_1_2			0x07
#define prg_base_3_4			0x1a
#define prg_base_act			0x13
#define data_base_1				0x0a
#define data_top_1				0x14
#define data_base_2				0x0c
#define data_top_2				0x15
#define data_base_3				0x1b
#define data_top_3				0x1d
#define data_base_4				0x1c
#define data_top_4				0x1e
#define data_dsp_addr_space		0x0f
#define data_top_base_check_act	0x16
#define data_base_act			0x17
#define mmio_base				0x0b


#define I2C_ON_GOING	 		0x1
#define I2C_ABORT		 		0x3
#define NO_MODE_DEBUG_A9 		0x0
#define NO_MODE_DEBUG_A9_MMDSP	0x0
#define NO_TRANSFER_DATA123		0x0
#define RESET_NO_EXIST			0x0
#define RETENTION_NO_EXIST		0x0
#define NO_EPOD_C_L_ON			0x0
#define NO_LS_CLAMP				0x0
#define NOPOWER_STATE			0x0
#define ENABLE_NO_EXIST			0x0
#define ENABLE_MASK          	0x00000100

///* IT mask definition */
#define ALL_IT						0xFFFFFFFF
#define ALL_IT_NOIT26_NOIT27		0xF3FFFFFF  // except IT26 to update msb timer4 and IT27 to update Primary watchdog timer5
//#define ALL_IT_MASKED_EXCEPT_IT15	0xFFFF7FFF

#define POWER_STATE_OFF	0x00
#define POWER_STATE_RET	0x01
#define POWER_STATE_ON	0x02

///////////////////////////////////
// DEFINE for AUTOIDLE
///////////////////////////////////
#define AUTO_IDLE_ENABLE_HSEM_MASK	0x01


///////////////////////////////////
// DEFINE for HWACC
///////////////////////////////////
#define NB_TOTAL_BLOCKS         9
#define NB_HW_ACC_BLOCKS        6

#define SVADSP_BLOCK_INDICE 	0
#define SVAPIPE_BLOCK_INDICE 	1
#define SIADSP_BLOCK_INDICE 	2
#define SIAPIPE_BLOCK_INDICE 	3
#define SGA_BLOCK_INDICE 		4
#define B2R2_BLOCK_INDICE 		5

#define ESRAM12_BLOCK_INDICE 	6
#define ESRAM34_BLOCK_INDICE 	7
#define ESRAM0_BLOCK_INDICE 	8
//#define APERAMS_BLOCK_INDICE 	9

///////////////////////////////////
// DEFINE for DDR_SERVICE
///////////////////////////////////
#define MASK_WR						0x00000001
#define MASK_RD						0x00000002
#define MASK_BW						0x00000004
#define MASK_ALL_EXCEPT_0_1			0xFFFFFFFC
#define MASK_ALL_EXCEPT_8_9			0xFFFFFCFF
#define MASK_ALL_EXCEPT_16_17		0xFFFCFFFF
#define MASK_ALL_EXCEPT_24_25		0xFCFFFFFF
#define MASK_ALL_EXCEPT_8_TO_14 	0xFFFF80FF
#define MASK_ALL_EXCEPT_24_TO_30 	0x80FFFFFF
#define MASK_16LSB 	0x0000FFFF
#define MASK_16MSB 	0xFFFF0000
#define MASK_ALL 	0xFFFFFFFF
#define SHIFT27 	27
#define SHIFT26 	26
#define SHIFT24 	24
#define SHIFT16 	16
#define SHIFT8 		8
#define SHIFT5 		5
#define SHIFT4 		4
#define SHIFT0 		0
#define CS_VAL 		0x30
#define ADDR_DENALI_CTL_09_IN_RAM_DATA 	9
#define ADDR_DENALI_CTL_10_IN_RAM_DATA 	10
#define ADDR_DENALI_CTL_11_IN_RAM_DATA 	11
#define ADDR_DENALI_CTL_12_IN_RAM_DATA 	12
#define ADDR_DENALI_CTL_23_IN_RAM_DATA 	23
#define ADDR_DENALI_CTL_24_IN_RAM_DATA 	24
#define ADDR_DENALI_CTL_73_IN_RAM_DATA 	48
#define ADDR_DENALI_CTL_85_IN_RAM_DATA 	58
#define ADDR_DENALI_CTL_86_IN_RAM_DATA 	59
#define ADDR_DENALI_CTL_87_IN_RAM_DATA 	60

///////////////////////////////////
// DEFINE for ITSTATUS
///////////////////////////////////
#define ITSTATUS0_SHIFT	0
#define IT15_SHIFT		17
#define ITSTATUS5_SHIFT	23
#define ITSTATUS4_SHIFT	17

#define ITSTATUS0_ALL_MASK		0x000000FF
#define ITSTATUS0_MASK_WO_USB	0x000000BF
#define IT15_MASK				0x00020000
#define ITSTATUS5_MASK			0xFF800000
#define ITSTATUS4_MASK			0x00100000

#define APEINT4500_VAL0	0x00
#define APEINT4500_VAL1	0x01
#define NO_IT15_CLR		0x02

#define IT15_STATUS		0x01
#define IT4_STATUS		0x08


///////////////////////////////////
// DEFINE for I2C to AB8500
///////////////////////////////////
#define I2CWR 				0xFFFFFFFE

#ifdef AB8500A1
  #define AB8500_FIELD		0x00000000
#endif

#ifdef AB8500B0
  #define AB8500_FIELD		0x00000040
#endif

#define STW4500CTRL2_RD 	(0x00810803|AB8500_FIELD)	// BANK1
#define VARM_ON_MAXOPP_WR   VARM_ON_100OPP_WR
#define VARM_ON_100OPP_WR	(0x01000808|AB8500_FIELD)	// BANK4: VarmPWMMode=0, VarmAutoMode=0, VBBNSelCtrl=0 , VBBPSelCtrl=0 , VarmSelCtrl[1:0]=00 (VarmSel1), VarmRegu[1:0]=01
#define VARM_ON_50OPP_WR	(0x05000808|AB8500_FIELD)	// BANK4: VarmPWMMode=0, VarmAutoMode=0, VBBNSelCtrl=0 , VBBPSelCtrl=0 , VarmSelCtrl[1:0]=01 (VarmSel2), VarmRegu[1:0]=01
#define VARM_RET_WR			(0x39000808|AB8500_FIELD)	// BANK4: VarmPWMMode=0, VarmAutoMode=0, VBBNSelCtrl=1 , VBBPSelCtrl=1 , VarmSelCtrl[1:0]=10 (VarmSel3), VarmRegu[1:0]=01
#define VARM_OFF_WR			(0x00000808|AB8500_FIELD)	// BANK4: VarmPWMMode=0, VarmAutoMode=0, VBBNSelCtrl=0 , VBBPSelCtrl=0 , VarmSelCtrl[1:0]=00 (VarmSel1), VarmRegu[1:0]=00
#define VAPE_ON_100OPP_WR	(0x01020808|AB8500_FIELD)	// BANK4: VapeSelCtrl2=0, VapePWMMode=0, VapeAutoMode=0, VapeSelCtrl=0 (VapeSel1), VapeRegu[1:0]=01 
#define VAPE_ON_50OPP_WR	(0x05020808|AB8500_FIELD)	// BANK4: VapeSelCtrl2=0, VapePWMMode=0, VapeAutoMode=0, VapeSelCtrl=1 (VapeSel2), VapeRegu[1:0]=01 
#define VAPE_OFF_WR			(0x00020808|AB8500_FIELD)	// BANK4: VapeSelCtrl2=0, VapePWMMode=0, VapeAutoMode=0, VapeSelCtrl=0 (VapeSel1), VapeRegu[1:0]=00
#define ITLATCH1_RD			(0x0020081D|AB8500_FIELD)	// BANKE  
#define SYSCLKREQ1VALID_WR	(0x000D0804|AB8500_FIELD)	// BANK2
#define VMODREGU_RD			(0x00400809|AB8500_FIELD)	// BANK4
#define VMODREGU_WR			(0x00400808|AB8500_FIELD)	// BANK4
#define ARMREGU1_0X3F_WR	(0x3F000808|AB8500_FIELD)	// BANK4
#define ARMREGU2_0X45_WR	(0x45010808|AB8500_FIELD)	// BANK4
#define ARMREGU2_0X05_WR	(0x05010808|AB8500_FIELD)	// BANK4
#define BANK4_I2C_WR		(0x00000808|AB8500_FIELD)	// BANK4
#define MAINWDOGCTRL_RD		(0x00010805|AB8500_FIELD)	// BANK2
#define MAINWDOGCTRL_WR		(0x02010804|AB8500_FIELD)	// BANK2
#define SIDFIRCONF_RD 		(0x0064081B|AB8500_FIELD)	// BANKD
#define SIDFIRCOEF_WR 		(0x0062081A|AB8500_FIELD)	// BANKD
#define SIDFIRGAIN_WR 		(0x0051081A|AB8500_FIELD)	// BANKD
#define ANCCONF1_WR  		(0x0053081A|AB8500_FIELD)	// BANKD
#define ANCFIRCOEF_WR 		(0x0057081A|AB8500_FIELD)	// BANKD
#define ANCIIRCOEF_WR 		(0x0059081A|AB8500_FIELD)	// BANKD
#define ANCSHIFT_WR 		(0x0054081A|AB8500_FIELD)	// BANKD
#define ANCWARP_WR 			(0x005B081A|AB8500_FIELD)	// BANKD
#define REGUSERIALCTRL1_WR 	(0x02000806|AB8500_FIELD)	// BANK3


#define RSTMODEM0		 			0xF7FFFFFF
#define RESETNVAUX1VALID			0x01000000
#define RSTMODEM1_RESETNVAUX1VALID	0x09000000
#define VMODREGUBIT1TO0				0xFDFFFFFF
#define VMODREGUBIT0TO1				0x01000000
#define VMODREGUBITTO0				0xFCFFFFFF



////////////////////////////////////
// DEFINE FOR GPIO RESET HANDLING //
////////////////////////////////////
#define _GPIO_RESET_SET PRCMUREG->PRCM_GPIO_RESETN_SET=GPIORstSettings;
#define _GPIO_RESET_CLR PRCMUREG->PRCM_GPIO_RESETN_CLR=GPIORstSettings;



//////////////////////////////
// DEFINE FOR AVS PARAMETER //
//////////////////////////////

// bit7 of ARM MAX OPP voltage value in t_AVSData struct may be used as enable
// flag for the corresponding dvfs mode. Next macro returns TRUE if mode is enabled,
// FALSE else.
#define IS_DVFS_MODE_ALLOWED(a)     ((a & MASK_BIT7)>>7)

// bit 6 of ARM MAX OPP voltage value in t_AVSData struct is used to signal 
// (when set) that VARM and VAPE voltage will move at 2.4V/ms instead of
// 7V/ms. In that case timing loop should be dimensionned accordingly.
#define IS_VOLTAGE_SLOPE_SLOW(a)      ((a & MASK_BIT6)>>6)


///////////////////////////////////
// DEFINE for PRIMARY WATCHDOG 
///////////////////////////////////
#define MAINWDOGCTRL_ENA	0x01000000
#define MAINWDOGENABIT1		0x01 
#define WDOGTIMERVALMAX		0x7F 



///////////////////////////////////
// DEFINE for BOOTSTATUS 
///////////////////////////////////
#define MAINBEG		0xFE 
#define MAINEND		0xFF 


//////////////////////////
// APPLICATION PARAMETERS 
//////////////////////////

/* Vsupply used from STn4500 */
#define VARMHIGHSPEED	1.125
#define VARMLOWSPEED	1.0375
#define VARMRET			0.75
#define VAPEHIGHSPEED	1.1375
#define VAPELOWSPEED	1.0375
#define VSAFEHP			1.1625
#define VMODSEL1		1.0250 
#define VMODSEL2		1.2125
#define VTIMESLOPE1		2.4 	/* Slope from 2.4V/ms for STn4500 de  0V a 1.1V */
#define VTIMESLOPE2		10 		/* Slope from 10V/ms for STn4500 de 1.1V a 1.2V */

/* CLK definition */
#define CLK32_VAL		   32 	/* CLK32 value(32KHz) */
#define SYSCLK_VAL		38400 	/* SYSCLK value(38.4Mhz) */
#define ULPCLK_VAL		38400	/* ULPCLK value(38.4Mhz) */ 
#define FREERUNOSC_VAL	38400	/* FREE RUNNING OSCILLATOR value(38.4Mhz) */  

/* Timing definition */
#define TIME_ULPCLKRDY_IDLE  7.8 	/* Time used to have ULPCK ready for power state changing from idle to execute (7.8 ms) */
#define TIME_ULPCLKRDY_SLEEP 7.5 	/* Time used to have ULPCK ready for power state changing from sleep/deepsleep to execute (7.5 ms) */
#define TIME_PLL_ENABLE		 0.013	/* Time used to have PLLs available after enable='1' (13.3 us) */
#define TIME_PLLSOC_LOCKP	 0.2133	/* Time used to Lock PLLSOC0/PLLSOC1(213.3 us) */
#define TIME_PLLARM_LOCKP	 0.2133 /* Time used to Lock PLLARM (213.3 us) */
#define TIME_PLLDDR_LOCKP	 0.2133 /* Time used to Lock PLLARM (213.3 us) */
#define TIME_PLL32K_LOCKP	 8 		/* Time used to Lock PLL32K (8 ms) */
#define TIME_SYSCLKOK		 4		/* Time used by STn4500 to have SYSCLK available (4 ms) */
#define TIME_4500RST		 13		/*  Time used by STn4500 for reset (13 ms) */
#define TIME_AFTER_4500_EN   5		/*  Time used by STn4500 for reset (13 ms) */
#define TIME_I2C			 0.008	/* Timeout definition for enabling I2C access(4us), but two access followed (8us)*/
//#define TIME_ARMWFI			 55		/* Timeout definition for Arm in Wfi mode(55 ms) */
#define TIME_ARMWFI			 2		/* Timeout definition for Arm in Wfi mode(2 ms) */
#define TIME_BOOT			 1		/* Timeout definition when polling on romcode_mb=ReadyToXp70Rst(1 ms) */
#define TIME_TO_VMOD_STABLE  0.5    /* Time to have VMOD ON when modem power mgt is requested */
#define TIME_MODSWRSTACK	 0.010	/* TIME definition used by MODEM to answer to MOD_SWRESET_REQ (10us TO BE DEFINED WITH MODEM SPEC?)*/
/* TIME definition used by DDR to go in deepsleep mode before receiving mod_mem_req='0' and mod_mem_latency='1' */
/* TIME_DDRDEEPSLEEP_VAL= (TIME_DDRDEEPSLEEP*ULPCLK_VAL)= (0.5*38400)= 0d16 */
#define TIME_DDRDEEPSLEEP	 0.5	/* Time used by DDR to go in deepsleep mode before receiving mod_mem_req='0' and mod_mem_latency='1' */ 

/* Timing loop definition */
#ifdef SIMULATION /* Timing loop used for simulation */

  /* Value to put into timer ref of timing_loop_fct (take into account time to go from VApeHighSpeed to VApeLowSpeed) */
  #define TIME_VAPEHIGHSPEED_VAPELOWSPEED	0x000000B3
  /* Value to put into timer ref of timing_loop_fct (take into account time to go from VArmHighSpeed to VArmLowSpeed) */
  #define TIME_VARMHIGHSPEED_VARMLOWSPEED	0x000000B2
  /* Value to put into timer ref of timing_loop_fct (take into account time to go from VArmHighSpeed to VArmRetention) */
  #define TIME_VARMHIGHSPEED_VARMRET		0x000000B1
  /* Value to put into timer ref of timing_loop_fct (take into account time to go from VMAX(VSAFEHP in this case) to V=0) */
  #define TIME_VMAX_V0						0x000000B0
  /* on AB8500v2 voltage slope has benn improved and thus time is reduced */
  #define TIME_VMAX_V0_FAST                 0x000000AF
  /* Time of timing loop used to have ULPCLK available when going from deepsleep/sleep/idle power state to execute */
  #define TIME_ULPCKREADY					0x0000000B
  /* Timeout definition for polling registers on SYSCLK available by STn4500*/
  #define TIME_SYSCLKOK_VAL					0x00000013
  /* Time of timing loop needs for STn4500 reset */
  #define TIME_4500RST_VAL					0x00000016
  /* Time of timing loop needs when STn4500 leaves reset */
  #define TIME_AFTER_4500_EN_VAL			0x00000018
  /* Timeout definition for polling registers on ARM in WFI */
  #define TIME_ARMWFI_VAL					0x20000000 /* used for romcode simulation to be sure to not trigger timeout */
  /* Timeout definition to go from starting ULPCLK to ModSysClkReq1Valid for modem power management */
  #define TIME_TO_ACTIV_MODSYSCLKREQ1VALID  0x00000020
  /* Value to put into timer ref of timing_loop_fct (take into account time to go from VMODSEL1 to VMODSEL2) */
  #define TIME_VMODSEL1_VMODSEL2 			0x00000011
  // timing used to Supply is OK for hardware accelerator
  #define VOK_POOLING_VAL 					0x00001FFF
  // timing used to Supply is off for hardware accelerator
  #define SUPPLY_ON_OFF 					0x0000000F 
  /* Timeout definition to put Hostaccess_req to '0', after that MOD_MEM_REQ goes from '0' to '1' */
  #define TIME_TO_HOSTACCESS_REQ_0		    0x00000017
  /* init value for timer4 */
  #define TIMER_4_INIT_VAL					0x000000FF
  /* value timer5 for primary watchdog */
  #define COEF_TIMER5						32
  /* 27us at 38.4MHz */
  #define TIMING_BODY_BIAS_UPDATE           0x0000040D

#else

  /* Value to put into timer ref of timing_loop_fct (take into account time to go from VApeHighSpeed to VApeLowSpeed) */
  /* TIME_VAPEHIGHSPEED_VAPELOWSPEED=	(((VAPEHIGHSPEED-VAPELOWSPEED)/VTIMESLOPE)*ULPCLK_VAL)= (((1.1375-1.0375)/2.4)*38400)= 0d1600 */
  #define TIME_VAPEHIGHSPEED_VAPELOWSPEED	0x00000640
  /* Value to put into timer ref of timing_loop_fct (take into account time to go from VArmHighSpeed to VArmLowSpeed) */
  /* TIME_VARMHIGHSPEED_VARMLOWSPEED=	(((VARMHIGHSPEED-VARMLOWSPEED)/VTIMESLOPE)*ULPCLK_VAL)= (((1.125-1.0375)/2.4)*38400)= 0d1400 */
  #define TIME_VARMHIGHSPEED_VARMLOWSPEED	0x00000580
  /* Value to put into timer ref of timing_loop_fct  (take into account time to go from VArmHighSpeed to VArmRetention) */
  /* TIME_VARMHIGHSPEED_VARMRET= (((VARMHIGHSPEED-VARMRET)/VTIMESLOPE)*ULPCLK_VAL)= (((1.125-0.75)/2.4)*38400)= 0d6000 */
  #define TIME_VARMHIGHSPEED_VARMRET		0x00001780
  /* Value to put into timer ref of timing_loop_fct (take into account time to go from VMAX(VSAFEHP in this case) to V=0) */
  /* TIME_VMAX_V0= (((VSAFEHP-0)/VTIMESLOPE)*ULPCLK_VAL)= (((1.1625-0)/2.4)*38400)= 0d18600 */
  #define TIME_VMAX_V0						0x000048B0 
  /* on AB8500v2 voltage slope has benn improved and thus time is reduced */
  /* TIME_VMAX_V0= (((VSAFEHP-0)/VTIMESLOPE)*ULPCLK_VAL)= (((1.1625-0)/7)*38400)= 0d18600 */
  #define TIME_VMAX_V0_FAST                 0x000018F0
  /* Time of timing loop used to have ULPCLK available when going from deepslee/sleep/idle power state to excecute */
  /* TIME_ULPCKREADY= (TIME_ULPCLKRDY_SLEEP*FREERUNOSC_VAL)= (7.5*38400)= 0d288000 */
  #define TIME_ULPCKREADY					0x00046510
  /* Timeout definition for polling registers on SYSCLK available by STn4500*/
  /* TIME_SYSCLKOK_VAL= (TIME_SYSCLKOK*ULPCLK_VAL)= (4*38400)= 0d153600*/
  #define TIME_SYSCLKOK_VAL					0x00025800
  /* Time of timing loop needs for STn4500 reset */
  /* TIME_4500RST_VAL= (TIME_4500RST*SYSCLK_VAL)= (13*38400)= 0d499200 */
  #define TIME_4500RST_VAL					0x00079E01
  /* Time of timing loop needs when STn4500 leaves reset */
  /* TIME_TIME_AFTER_4500_EN_VAL= (TIME_4500RST*SYSCLK_VAL)= (5*38400)= 0d192000 */
  #define TIME_AFTER_4500_EN_VAL			0x0002EE00
  /* Timeout definition for polling registers on ARM in WFI */
  /* TIME_ARMWFI_VAL= (TIME_ARMWFI*ULPCLK_VAL)= (2*38400)= 0d76800 */
  #define TIME_ARMWFI_VAL					76800
  /* Timeout definition to go from starting ULPCLK to ModSysClkReq1Valid for modem power management */
  /* (8ms-.5ms-2ms-0.1875ms-2ms)= 3.3125ms => (0.0033125*32000)=0d106 */
  #define TIME_TO_ACTIV_MODSYSCLKREQ1VALID  0x0000006A
  /* Value to put into timer ref of timing_loop_fct (take into account time to go from VMODSEL1 to VMODSEL2) */
  /* TIME_VMODSEL1_VMODSEL2=	(((VMODSEL2-VMODSEL1)/VTIMESLOPE2)*ULPCLK_VAL)= (((1.2125-1.0250)/2.4)*38400)= 0d3000 */
  #define TIME_VMODSEL1_VMODSEL2 			3000 /* 78 us */
  // timing used to Supply is OK for hardware accelerator. TO BE DEFINED
  #define VOK_POOLING_VAL 					0x00001FFF
  // timing used to Supply is off for hardware accelerator. TO BE DEFINED
  #define SUPPLY_ON_OFF 					0x000000FF 
  /* Timeout definition to put Hostaccess_req to '0', after that MOD_MEM_REQ goes from '0' to '1' */
  /* (10s*32000)=0d320000 */
  #define TIME_TO_HOSTACCESS_REQ_0		    0x0004E200
  /* init value for timer4 */
  #define TIMER_4_INIT_VAL					0xFFFFFFFF
  /* value timer5 for primary watchdog */
  #define COEF_TIMER5						32000
  
  
  /* 27us at 38.4MHz */
  #define TIMING_BODY_BIAS_UPDATE           0x0000040D

  
  
#endif

/* Time used from PLL configuration to enable PLL */
/* TIME_PLL_ENABLE_VAL= (TIME_PLL_ENABLE*SYSCLK_VAL)= (0.013*38400)= 0d500 */
#define TIME_PLL_ENABLE_VAL					0x000001F4

/* Timeout definition for polling registers */
/* Time value used for PLL 32K is locked */
/* TIME_PLL32KLOCKP= (TIME_PLL32K_LOCKP*SYSCLK_VAL)= (8*38400)= 0d307200 */
#define TIME_PLL32KLOCKP					0x00050000 //0d327680
/* Time value used for PLL SOC0/SOC1 is locked */
/* TIME_PLLSOCLOCKP= (TIME_PLLSOC_LOCKP*SYSCLK_VAL)= (0.2133*38400)= 0d8191 */
#define TIME_PLLSOCLOCKP					0x00001FFF
/* Time value used for PLL ARM is locked */
/* #define TIME_PLLARMLOCKP= (TIME_PLLARM_LOCKP*SYSCLK_VAL)= (0.2133*38400)= 0d8191 */
#define TIME_PLLARMLOCKP					0x00001FFF
/* Time value used for PLL DDR is locked */
/* #define TIME_PLLDDRLOCKP= (TIME_PLLDDR_LOCKP*SYSCLK_VAL)= (0.2133*38400)= 0d8191 */
#define TIME_PLLDDRLOCKP					0x00001FFF
/* Time definition for enabling I2C access */
/* define TIME_I2C_VAL= (TIME_I2C*SYSCLK_VAL)= (0.008*38400)= 0d307 */
#define TIME_I2C_VAL						0x00000140	
/* Time definition for romcode_mb=ReadyToXp70Rst */
/* TIME_BOOT_VAL= (TIME_BOOT*SYSCLK_VAL)= (1*38400)= 0d38400 */
#define TIME_BOOT_VAL						0x20000000	 /* used for romcode simulation to be sure to not trigger timeout */
/* Time definition for romcode_mb=ReadyToXp70Rst */
#define TIME_ROMCODE_READY_VAL				0x20000001	 /* VALUE TO BE DEFINED BY ROMCODE TEAM */
/* SYSCLKOK_DELAY definition used by modem power management */
#define SYSCLKOK_DELAY_FOR_MODEM_PWR_MGT    0x00000006	 
/* TIME definition used by modem power management to have VMOD "ON" */
/* TIME_TO_VMOD_STABLE_VAL= (TIME_TO_VMOD_STABLE*CLK32_VAL)= (0.5*32)= 0d16 */
#define TIME_TO_VMOD_STABLE_VAL				0x00000010
/* TIME definition used by DDR to go in deepsleep mode */
/* TIME_DDRDEEPSLEEP_VAL= (TIME_DDRDEEPSLEEP*ULPCLK_VAL)= (0.5*38400)= 0d19200 */
#define TIME_DDRDEEPSLEEP_VAL				0x00004B00
/* Time value used by modem to answer to MOD_SWRESET_REQ*/
/* TIME_PLLSOCLOCKP= (TIME_MODSWRSTACK*SYSCLK_VAL)= (0.010*38400)= 0d384 */
#define TIME_MOD_SWRESET_ACK				0x00000180
/* Time value used to have FIRSidBusy bit available after reading SidFIRConf*/
/* TIME_PLLSOCLOCKP= (TIME_MODSWRSTACK*SYSCLK_VAL)= (1*38400)= 0d38400 */
#define TIME_FIRSIDBUSY_VAL					0x00009600


////////////////////////////////////////////////////////////////////
// 5 - Configuration of Adaptive Voltage Scaling (AVS) and Body Bias
////////////////////////////////////////////////////////////////////

// prcmu's nominal or standard clock, which is e.g. 
// the fequency the prcmu is running in apExecute state
#define STD_PRCMU_CLOCK_IN_MHZ   38.4

////// Transition Times

// Time used to switch arm from 50 OPP to retention
#define TIME_VARM_50OPP_TO_RET_IN_US    32  // applied: TIME_VARM_50OPP_TO_RET
// Time used to switch arm from 0.7 (retention) to 1.3625 with 9.4V/ms slope (maximum voltage = potentially MaxOPP)
#define TIME_VARM_RET_TO_MAXOPP_IN_US   67  // applied: TIME_VARM_RET_TO_MAXOPP
// Time used to switch arm from 1.3625 to 0.7 (retention) with 9.4V/ms slope (maximum voltage = potentially MaxOPP)
#define TIME_VARM_MAXOPP_TO_RET_IN_US   TIME_VARM_RET_TO_MAXOPP_IN_US  // applied: TIME_VARM_MAXOPP_TO_RET
// Time used to switch Vbbp from 0 to +/- 300mV with 11V/ms slope
#define TIME_VBBP_VARM_RET_TO_ON_IN_US  27  // applied: TIME_VBBP_VARM_RET_TO_ON
// Time used to switch Vbbp from +/- 300 mV to 0 mV with 11V/ms slope
#define TIME_VBBP_VARM_ON_TO_RET_IN_US  TIME_VBBP_VARM_RET_TO_ON_IN_US  // applied: TIME_VBBP_VARM_ON_TO_RET
// Time used to make Vbbn go from 0 to +300mV
#define TIME_VBBN_0_TO_300MV_IN_US      132 // applied: TIME_VBBN_0_TO_300MV

/////// Body Bias

// If activated, Values outside these boundaries are clamped to the nearest boundary.
//#define ACTIVATE_BIAS_VOLTAGES_BOUNDARIES_CHECK

// number of bits to code bias voltages
#define BIAS_VOLTAGES_NB_BITS           4

// Bias Voltage boundaries expressed in 100mV 
//
// maximum positive Vbbn voltage value
#define MAX_POS_VBBN_VOLTAGE_VALUE      3
// minimum negative Vbbn voltage value
#define MIN_NEG_VBBN_VOLTAGE_VALUE      -3  // applied: MAX_NEG_VBBN_VOLTAGE_VALUE
// maximum positive Vbbp voltage value
#define MAX_POS_VBBP_VOLTAGE_VALUE      3
// minimum negative Vbbp voltage value
#define MIN_NEG_VBBP_VOLTAGE_VALUE      -3

 
//////////////////////////
// PARAMETERS CALCULATIONS 
//////////////////////////

#define STD_PRCMU_CYCLE_IN_NS    (unsigned int)(1000 / STD_PRCMU_CLOCK_IN_MHZ)

#define TIME_VARM_50OPP_TO_RET   ((unsigned int)((TIME_VARM_50OPP_TO_RET_IN_US * 1000) / STD_PRCMU_CYCLE_IN_NS))
#define TIME_VARM_RET_TO_MAXOPP  ((unsigned int)((TIME_VARM_RET_TO_MAXOPP_IN_US * 1000) / STD_PRCMU_CYCLE_IN_NS))
#define TIME_VARM_MAXOPP_TO_RET  ((unsigned int)((TIME_VARM_MAXOPP_TO_RET_IN_US * 1000) / STD_PRCMU_CYCLE_IN_NS))
#define TIME_VBBP_VARM_RET_TO_ON ((unsigned int)((TIME_VBBP_VARM_RET_TO_ON_IN_US * 1000) / STD_PRCMU_CYCLE_IN_NS))
#define TIME_VBBP_VARM_ON_TO_RET ((unsigned int)((TIME_VBBP_VARM_ON_TO_RET_IN_US * 1000) / STD_PRCMU_CYCLE_IN_NS))
#define TIME_VBBN_0_TO_300MV     ((unsigned int)((TIME_VBBN_0_TO_300MV_IN_US * 1000) / STD_PRCMU_CYCLE_IN_NS))
 
// due to the fact that Vbbn is not coded in 2's complement, which is the case for Vbbp,
// this intermediate value must be computed.
#define MAX_NEG_VBBN_VOLTAGE_VALUE   ( -(1 << (BIAS_VOLTAGES_NB_BITS - 1)) - MIN_NEG_VBBN_VOLTAGE_VALUE )


#endif

/* end of file */
