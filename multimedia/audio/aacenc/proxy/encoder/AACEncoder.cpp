/*
 * Copyright (C) ST-Ericsson SA 2010. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 */
#include "AACEncoder.h"
#include "AACNmfHost_Encoder.h"
#include "AACEnc_BitstreamPort.h"

// UID top dictionnary (generated by trace compiler)
#include "AAC_HOST_ENC_top.h"


// TODO FIXME: manage buffers that are not 32-bit multiple (for Host proxy only)
#define SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES 4

AACEncoder_RDB::AACEncoder_RDB(OMX_U32 nbOfDomains) 
	: ENS_ResourcesDB(nbOfDomains)
{
    setNbOfMemoryPresets(5);
    setMemoryPreset(1); // ALL_DDR
    for (unsigned int i=0;i<nbOfDomains;i++) {
        setDefaultNMFDomainType(RM_NMFD_PROCSIA,i);
    }
}

OMX_ERRORTYPE AACEncoder::createResourcesDB() {
    mRMP = new AACEncoder_RDB(getPortCount());
    if (mRMP == 0) {
        return OMX_ErrorInsufficientResources;
    } 
    else {
        return OMX_ErrorNone;
    }
}
OMX_ERRORTYPE aachostencFactoryMethod(ENS_Component_p * ppENSComponent) {
    OMX_ERRORTYPE error  = OMX_ErrorNone;

    AACEncoder *aacenc = new AACEncoder(true);
    if (aacenc == 0) {
        return OMX_ErrorInsufficientResources;
    }

    error = aacenc->construct();

    if (error != OMX_ErrorNone) {
        delete aacenc;
        *ppENSComponent = 0;
        return OMX_ErrorInsufficientResources;
    } else {
        *ppENSComponent = aacenc;
    }

    AACNmfHost_Encoder *aacenc_ProcessingComp = new AACNmfHost_Encoder(*aacenc);

    if (aacenc_ProcessingComp == 0) {
        delete aacenc;
        return OMX_ErrorInsufficientResources;
    }

    aacenc->setProcessingComponent(aacenc_ProcessingComp);

    return error;
}



OMX_ERRORTYPE AACEncoder::createAACEncBitstreamPort(const OMX_AUDIO_PARAM_AACPROFILETYPE &defaultAacSettings)
{
  OMX_U32 supported_length = getMaxFrameSize()/8;

  if (mIsHost) {
    supported_length += (SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES - 1);
    supported_length &= ~(SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES - 1);
  }

    AACEnc_BitstreamPort *aacPort = 
      new AACEnc_BitstreamPort(1, OMX_DirOutput, supported_length, defaultAacSettings, *this);

    if (aacPort == 0) {
        return OMX_ErrorInsufficientResources;
    }

    addPort(aacPort);

   if (mIsHost) {
       aacPort->forceStandardTunneling();
   }

    return OMX_ErrorNone;
}

#define DEFAULT_CHANNELS_NB     2
#define DEFAULT_SAMPLING_RATE   48000

OMX_ERRORTYPE  AACEncoder::construct()
{
    OMX_ERRORTYPE error;
    OMX_AUDIO_PARAM_PCMMODETYPE defaultPcmSettings;
    OMX_AUDIO_PARAM_AACPROFILETYPE defaultAacSettings;

    defaultPcmSettings.nPortIndex     = 0;
    defaultPcmSettings.eNumData       = OMX_NumericalDataSigned;
    defaultPcmSettings.eEndian        = OMX_EndianLittle;
    defaultPcmSettings.bInterleaved   = OMX_TRUE;
    defaultPcmSettings.ePCMMode       = OMX_AUDIO_PCMModeLinear;
    defaultPcmSettings.nBitPerSample  = 16;
    defaultPcmSettings.nChannels      = 2;
    defaultPcmSettings.nSamplingRate  = DEFAULT_SAMPLING_RATE;
    defaultPcmSettings.eChannelMapping[0] = OMX_AUDIO_ChannelLF;
	  defaultPcmSettings.eChannelMapping[1] = OMX_AUDIO_ChannelRF;   
    
    
    
    defaultAacSettings.nSize            = sizeof(OMX_AUDIO_PARAM_AACPROFILETYPE);
    getOmxIlSpecVersion(&defaultAacSettings.nVersion);
    defaultAacSettings.nPortIndex       = 1;
    defaultAacSettings.nChannels        = 2;
    defaultAacSettings.nBitRate         = 128000; // let encoder to decide
    defaultAacSettings.nSampleRate      = DEFAULT_SAMPLING_RATE;
    defaultAacSettings.nFrameLength     = 0;
    defaultAacSettings.nAACtools        = OMX_AUDIO_AACToolAll;
    defaultAacSettings.nAACERtools      = OMX_AUDIO_AACERNone;
    defaultAacSettings.eAACProfile      = OMX_AUDIO_AACObjectLC;
    defaultAacSettings.eAACStreamFormat = OMX_AUDIO_AACStreamFormatADIF;
    defaultAacSettings.nAudioBandWidth  = 0;
    defaultAacSettings.eChannelMode     = OMX_AUDIO_ChannelModeStereo;



    error = AFM_Encoder::construct(
            OMX_AUDIO_CodingAAC, getSampleFrameSize()*getMaxChannels(), defaultPcmSettings);
    if (error != OMX_ErrorNone) return error;

    ENS_String<20> role = "audio_encoder.aacnb";
    role.put((OMX_STRING)mRoles[0]);
    setActiveRole(mRoles[0]);

    error = createAACEncBitstreamPort(defaultAacSettings);
    if (error != OMX_ErrorNone) return error;

    if (mIsHost) {
        AFM_PcmPort *pcmPort = static_cast<AFM_PcmPort *>(getPort(0));
        pcmPort->forceStandardTunneling();
    }

    return OMX_ErrorNone;
}


OMX_ERRORTYPE AACEncoder::getExtensionIndex(OMX_STRING cParameterName,
						     OMX_INDEXTYPE* pIndexType) const
{
    if (mIsHost) {
        if (ENS_String<ENS_COMPONENT_NAME_MAX_LENGTH>(cParameterName) 
                == "OMX.ST.AFM.proprietary_communication") {
            return OMX_ErrorNotImplemented;
        }
    }

    return AFM_Component::getExtensionIndex(cParameterName, pIndexType);
} 


OMX_U32 AACEncoder::getUidTopDictionnary(void)
{
    return KOstAAC_HOST_ENC_top_ID;
 }


