/*****************************************************************************/
/*
 * Copyright (C) ST-Ericsson SA 2009,2010. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 *
 */

/**
 * \file   TransducerEqualizer.cpp
 * \brief
 * \author ST-Ericsson
 */
/*****************************************************************************/
#include <string.h>
#include "TransducerEqualizer.h"
#ifndef HOST_ONLY
#include "TEQNmfMpc.h"
#endif /* !HOST_ONLY */
#include "TEQNmfHost.h"

// UID top dictionnary (generated by trace compiler)
#include "TEQ_top.h"



int TransducerEqualizer::instance = -1;


TransducerEqualizer_RDB::TransducerEqualizer_RDB(OMX_U32 nbOfDomains) : ENS_ResourcesDB(nbOfDomains)
{
    setNbOfMemoryPresets(6);
    setMemoryPreset(2); // ALL_DDR
    for(unsigned int i = 0; i < nbOfDomains; i++)
    {
        setDefaultNMFDomainType(RM_NMFD_PROCSIA,i);
    }
}


OMX_ERRORTYPE TransducerEqualizer::createResourcesDB(void)
{
    mRMP = new TransducerEqualizer_RDB(2);

    if(mRMP == 0)
    {
        return OMX_ErrorInsufficientResources;
    }
    else
    {
        return OMX_ErrorNone;
    }
}


#ifndef HOST_ONLY
OMX_ERRORTYPE transducer_equalizerFactoryMethod(ENS_Component_p *ppENSComponent)
{
    TransducerEqualizer *p_transducer_equalizer = new TransducerEqualizer(false);
    OMX_ERRORTYPE       error;

    if(p_transducer_equalizer == NULL)
    {
        return OMX_ErrorInsufficientResources;
    }

    error = p_transducer_equalizer->construct();
    if(error != OMX_ErrorNone)
    {
        delete p_transducer_equalizer;
        *ppENSComponent = 0;
        return OMX_ErrorInsufficientResources;
    }
    else
    {
        *ppENSComponent = p_transducer_equalizer;
    }

    TEQNmfMpc *TEQ_NmfProcessingComp = new TEQNmfMpc(*p_transducer_equalizer);
    if(TEQ_NmfProcessingComp == 0)
    {
        delete p_transducer_equalizer;
        return OMX_ErrorInsufficientResources;
    }
    p_transducer_equalizer->setProcessingComponent(TEQ_NmfProcessingComp);

    return error;
}
#endif /* !HOST_ONLY */


OMX_ERRORTYPE transducer_equalizer_host_FactoryMethod(ENS_Component_p *ppENSComponent)
{
    TransducerEqualizer *p_transducer_equalizer = new TransducerEqualizer(true);
    OMX_ERRORTYPE       error;

    if(p_transducer_equalizer == NULL)
    {
        return OMX_ErrorInsufficientResources;
    }

    error = p_transducer_equalizer->construct();
    if(error != OMX_ErrorNone)
    {
        delete p_transducer_equalizer;
        *ppENSComponent = 0;
        return OMX_ErrorInsufficientResources;
    }
    else
    {
        *ppENSComponent = p_transducer_equalizer;
    }

    TEQNmfHost *TEQ_NmfProcessingComp = new TEQNmfHost(*p_transducer_equalizer);
    if(TEQ_NmfProcessingComp == 0)
    {
        delete p_transducer_equalizer;
        return OMX_ErrorInsufficientResources;
    }
    p_transducer_equalizer->setProcessingComponent(TEQ_NmfProcessingComp);

    return error;
}


OMX_ERRORTYPE TransducerEqualizer::construct(void)
{
    OMX_AUDIO_PARAM_PCMMODETYPE defaultPcmSettingsIn, defaultPcmSettingsOut;
    OMX_ERRORTYPE               error;
    int                         i, channel;


    defaultPcmSettingsIn.nPortIndex                                                       = TREQ_IN_PORT;
    defaultPcmSettingsIn.eNumData                                                         = OMX_NumericalDataSigned;
    defaultPcmSettingsIn.eEndian                                                          = OMX_EndianLittle;
    defaultPcmSettingsIn.bInterleaved                                                     = OMX_TRUE;
    defaultPcmSettingsIn.ePCMMode                                                         = OMX_AUDIO_PCMModeLinear;
    defaultPcmSettingsIn.nBitPerSample                                                    = TREQ_DEFAULT_NB_BITS_PER_SAMPLE;
    defaultPcmSettingsIn.nChannels                                                        = TREQ_DEFAULT_NB_CHANNEL;
    defaultPcmSettingsIn.nSamplingRate                                                    = TREQ_DEFAULT_SAMPLING_FREQUENCY;
    defaultPcmSettingsIn.eChannelMapping[0]                                               = OMX_AUDIO_ChannelLF;
    defaultPcmSettingsIn.eChannelMapping[1]                                               = OMX_AUDIO_ChannelRF;

    defaultPcmSettingsOut.nPortIndex                                                      = TREQ_OUT_PORT;
    defaultPcmSettingsOut.eNumData                                                        = OMX_NumericalDataSigned;
    defaultPcmSettingsOut.eEndian                                                         = OMX_EndianLittle;
    defaultPcmSettingsOut.bInterleaved                                                    = OMX_TRUE;
    defaultPcmSettingsOut.ePCMMode                                                        = OMX_AUDIO_PCMModeLinear;
    defaultPcmSettingsOut.nBitPerSample                                                   = TREQ_DEFAULT_NB_BITS_PER_SAMPLE;
    defaultPcmSettingsOut.nChannels                                                       = TREQ_DEFAULT_NB_CHANNEL;
    defaultPcmSettingsOut.nSamplingRate                                                   = TREQ_DEFAULT_SAMPLING_FREQUENCY;
    defaultPcmSettingsOut.eChannelMapping[0]                                              = OMX_AUDIO_ChannelLF;
    defaultPcmSettingsOut.eChannelMapping[1]                                              = OMX_AUDIO_ChannelRF;

    //Default parameters
    mConfigUse                                                                            = USE_PROPRIETARY_CONFIG;
    for(channel = 0; channel < 2; channel++)
    {
        for(i = 0; i < NB_MAX_TRANSDUCER_EQUALIZER_BIQUAD_CELLS; i++)
        {
            ConfigAudioTransEqualizer_iireq_status[channel][i]                            = TEQ_BIQUAD_CELL_RESET;
        }
    }

    mTransducerEqualizerParams.nSize                                                      = sizeof(AFM_AUDIO_PARAM_TRANSDUCEREQUALIZERTYPE);
    getOmxIlSpecVersion(&mTransducerEqualizerParams.nVersion);
    mTransducerEqualizerParams.MemoryPreset                                               = MEM_PRESET_ALL_TCM;
    mTransducerEqualizerParams.stereo                                                     = (TREQ_DEFAULT_NB_CHANNEL == 2 ? OMX_TRUE : OMX_FALSE);
    mTransducerEqualizerParams.nb_alloc_biquad_cells_per_channel                          = NB_MAX_TRANSDUCER_EQUALIZER_BIQUAD_CELLS / TREQ_DEFAULT_NB_CHANNEL;
    mTransducerEqualizerParams.nb_alloc_FIR_coefs_per_channel                             = NB_MAX_TRANSDUCER_EQUALIZER_FIR_COEFS    / TREQ_DEFAULT_NB_CHANNEL;

    mTransducerEqualizerConfig.nSize                                                      = sizeof(AFM_AUDIO_CONFIG_TRANSDUCEREQUALIZERTYPE);
    getOmxIlSpecVersion(&mTransducerEqualizerConfig.nVersion);
    mTransducerEqualizerConfig.bEnable                                                    = OMX_TRUE;
    mTransducerEqualizerConfig.same_biquad_l_r                                            = OMX_TRUE;
    mTransducerEqualizerConfig.same_FIR_l_r                                               = OMX_TRUE;
    mTransducerEqualizerConfig.biquad_first                                               = OMX_TRUE;
    mTransducerEqualizerConfig.biquad_gain_exp_l                                          = 1;
    mTransducerEqualizerConfig.biquad_gain_mant_l                                         = 0x40000000;
    mTransducerEqualizerConfig.biquad_gain_exp_r                                          = 1;
    mTransducerEqualizerConfig.biquad_gain_mant_r                                         = 0x40000000;
    mTransducerEqualizerConfig.FIR_gain_exp_l                                             = 1;
    mTransducerEqualizerConfig.FIR_gain_mant_l                                            = 0x40000000;
    mTransducerEqualizerConfig.FIR_gain_exp_r                                             = 1;
    mTransducerEqualizerConfig.FIR_gain_mant_r                                            = 0x40000000;
    mTransducerEqualizerConfig.bAutomaticTransitionGain                                   = OMX_TRUE;
    mTransducerEqualizerConfig.smoothing_delay_ms                                         = 200;
    mTransducerEqualizerConfig.transition_gain_exp_l                                      = 1;
    mTransducerEqualizerConfig.transition_gain_mant_l                                     = 0x40000000;
    mTransducerEqualizerConfig.transition_gain_exp_r                                      = 1;
    mTransducerEqualizerConfig.transition_gain_mant_r                                     = 0x40000000;
    mTransducerEqualizerConfig.nb_biquad_cells_per_channel                                = 0;
    mTransducerEqualizerConfig.nb_FIR_coefs_per_channel                                   = 0;

    for(i = 0; i < NB_MAX_TRANSDUCER_EQUALIZER_BIQUAD_CELLS; i++)
    {
        mTransducerEqualizerConfig.biquad_cell[i].b_exp                                   = 0;
        mTransducerEqualizerConfig.biquad_cell[i].b0                                      = 0x7FFFFFFF;
        mTransducerEqualizerConfig.biquad_cell[i].b1                                      = 0;
        mTransducerEqualizerConfig.biquad_cell[i].b2                                      = 0;
        mTransducerEqualizerConfig.biquad_cell[i].a1                                      = 0;
        mTransducerEqualizerConfig.biquad_cell[i].a2                                      = 0;
    }

    mTransducerEqualizerConfig.FIR_coef[0]                                                = 0x7FFFFFFF;
    mTransducerEqualizerConfig.FIR_coef[1]                                                = 0x7FFFFFFF;
    for(i = 2; i < NB_MAX_TRANSDUCER_EQUALIZER_FIR_COEFS; i++)
    {
        mTransducerEqualizerConfig.FIR_coef[i]                                            = 0;
    }

    for(channel = 0; channel < 2; channel++)
    {
        mOMX_ConfigAudioTransEqualizer[channel].nSize                                     = sizeof(OMX_AUDIO_CONFIG_TRANSDUCEREQUALIZERTYPE);
        getOmxIlSpecVersion(&mOMX_ConfigAudioTransEqualizer[channel].nVersion);
        mOMX_ConfigAudioTransEqualizer[channel].nPortIndex                                = TREQ_OUT_PORT;
        mOMX_ConfigAudioTransEqualizer[channel].bEnableFir                                = OMX_FALSE;
        mOMX_ConfigAudioTransEqualizer[channel].bEnableIir                                = OMX_FALSE;
        mOMX_ConfigAudioTransEqualizer[channel].nChannel                                  = channel;
        mOMX_ConfigAudioTransEqualizer[channel].ePhaseResponseTargetFir                   = OMX_AUDIO_LinearPhase;
        mOMX_ConfigAudioTransEqualizer[channel].ePhaseResponseTargetIir                   = OMX_AUDIO_PhaseNotDefined;
        mOMX_ConfigAudioTransEqualizer[channel].nIIREqualizerBlocks                       = 0;
        mOMX_ConfigAudioTransEqualizer[channel].nIIREqualizerGain                         = 0;

        for(i = 0; i < NB_MAX_TRANSDUCER_EQUALIZER_BIQUAD_CELLS; i++)
        {
            mOMX_ConfigAudioTransEqualizer_iireq[channel][i].nSize                        = sizeof(OMX_AUDIO_CONFIG_IIR_EQUALIZER);
            getOmxIlSpecVersion(&mOMX_ConfigAudioTransEqualizer_iireq[channel][i].nVersion);
            mOMX_ConfigAudioTransEqualizer_iireq[channel][i].nPortIndex                   = TREQ_OUT_PORT;
            mOMX_ConfigAudioTransEqualizer_iireq[channel][i].nChannel                     = channel;
            mOMX_ConfigAudioTransEqualizer_iireq[channel][i].sBandIndex.nValue            = i;
            mOMX_ConfigAudioTransEqualizer_iireq[channel][i].sBandIndex.nMin              = 0;
            mOMX_ConfigAudioTransEqualizer_iireq[channel][i].sBandIndex.nMax              = NB_MAX_TRANSDUCER_EQUALIZER_BIQUAD_CELLS - 1;
            mOMX_ConfigAudioTransEqualizer_iireq[channel][i].eFilterType                  = OMX_AUDIO_NotDefined;
            mOMX_ConfigAudioTransEqualizer_iireq[channel][i].nFilterGain                  = 0;
            mOMX_ConfigAudioTransEqualizer_iireq[channel][i].nFilterCenterCutoffFrequency = 0;
            mOMX_ConfigAudioTransEqualizer_iireq[channel][i].nFilterBandwidth             = 0;
        }

        mOMX_ConfigAudioTransEqualizer_firresponse[channel].nSize                         = sizeof(OMX_AUDIO_CONFIG_FIR_RESPONSE);
        getOmxIlSpecVersion(&mOMX_ConfigAudioTransEqualizer_firresponse[channel].nVersion);
        mOMX_ConfigAudioTransEqualizer_firresponse[channel].nPortIndex                    = TREQ_OUT_PORT;
        mOMX_ConfigAudioTransEqualizer_firresponse[channel].nChannel                      = channel;
        mOMX_ConfigAudioTransEqualizer_firresponse[channel].nFrequencyPoints              = 0;
        for(i = 0; i < MAX_FIRRESPONSE_POINTS; i++)
        {
            mOMX_ConfigAudioTransEqualizer_firresponse[channel].nFrequencies[i]           = 0;
            mOMX_ConfigAudioTransEqualizer_firresponse[channel].nGains[i]                 = 0;
        }
        mOMX_ConfigAudioTransEqualizer_firresponse[channel].nFirLength                    = TREQ_SHAI_DEFAULT_FIR_ORDER;
    }

    //error = AFM_PcmProcessing::construct(defaultPcmSettingsIn, defaultPcmSettingsOut, 1, mIsHost);
    error = AFM_PcmProcessing::construct(defaultPcmSettingsIn, defaultPcmSettingsOut);
    if(error != OMX_ErrorNone)
    {
        return error;
    }

    if(mIsHost)
    {
        AFM_PcmPort *inPort  = static_cast<AFM_PcmPort*>(getPort(0));
        AFM_PcmPort *outPort = static_cast<AFM_PcmPort*>(getPort(1));

        inPort ->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);
        outPort->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);
    }

    ENS_String<40> role = "audio_processor.pcm.trans_equalizer";
    role.put((OMX_STRING)mRoles[0]);
    setActiveRole(mRoles[0]);

    return OMX_ErrorNone;
}


OMX_ERRORTYPE TransducerEqualizer::setParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure)
{
    switch(nParamIndex)
    {
        case AFM_IndexParamTransducerEqualizer:
        {
            CHECK_STRUCT_SIZE_AND_VERSION(pComponentParameterStructure, AFM_AUDIO_PARAM_TRANSDUCEREQUALIZERTYPE);
            AFM_AUDIO_PARAM_TRANSDUCEREQUALIZERTYPE *pTransducerEqualizer = (AFM_AUDIO_PARAM_TRANSDUCEREQUALIZERTYPE *) pComponentParameterStructure;
            int                                     nb_channels           = (pTransducerEqualizer->stereo != 0 ? 2 : 1);

            if(   (nb_channels * pTransducerEqualizer->nb_alloc_biquad_cells_per_channel > NB_MAX_TRANSDUCER_EQUALIZER_BIQUAD_CELLS)
               || (nb_channels * pTransducerEqualizer->nb_alloc_FIR_coefs_per_channel    > NB_MAX_TRANSDUCER_EQUALIZER_FIR_COEFS))
            {
                return OMX_ErrorBadParameter;
            }
            mConfigUse                 = USE_PROPRIETARY_CONFIG;
            mTransducerEqualizerParams = *pTransducerEqualizer;
            defaultParams              = false;
            return OMX_ErrorNone;
        }

        default:
            return AFM_PcmProcessing::setParameter(nParamIndex, pComponentParameterStructure);
    }
}


OMX_ERRORTYPE TransducerEqualizer::getParameter(OMX_INDEXTYPE nParamIndex, OMX_PTR pComponentParameterStructure) const
{
    switch(nParamIndex)
    {
        case AFM_IndexParamPcmLayout:
        {
            AFM_PARAM_PCMLAYOUTTYPE *pcmlayout = (AFM_PARAM_PCMLAYOUTTYPE *) pComponentParameterStructure;
            OMX_ERRORTYPE           error;

            error = AFM_PcmProcessing::getParameter(nParamIndex, pComponentParameterStructure);
            if(error != OMX_ErrorNone)
            {
                return error;
            }
            pcmlayout->nBitsPerSample = nb_bits_quantif;

            return OMX_ErrorNone;
        }

        case AFM_IndexParamTransducerEqualizer:
        {
            CHECK_STRUCT_SIZE_AND_VERSION(pComponentParameterStructure, AFM_AUDIO_PARAM_TRANSDUCEREQUALIZERTYPE);
            AFM_AUDIO_PARAM_TRANSDUCEREQUALIZERTYPE *pTransducerEqualizer = (AFM_AUDIO_PARAM_TRANSDUCEREQUALIZERTYPE *) pComponentParameterStructure;

            *pTransducerEqualizer = mTransducerEqualizerParams;
            return OMX_ErrorNone;
        }

        default:
            return AFM_PcmProcessing::getParameter(nParamIndex, pComponentParameterStructure);
    }
}


OMX_ERRORTYPE TransducerEqualizer::setConfig(OMX_INDEXTYPE nConfigIndex, OMX_PTR pComponentConfigStructure)
{
    switch(nConfigIndex)
    {
        case AFM_IndexConfigTransducerEqualizer:
        {
            CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure, AFM_AUDIO_CONFIG_TRANSDUCEREQUALIZERTYPE);
            AFM_AUDIO_CONFIG_TRANSDUCEREQUALIZERTYPE *pTransducerEqualizer = (AFM_AUDIO_CONFIG_TRANSDUCEREQUALIZERTYPE *) pComponentConfigStructure;

            if(   (pTransducerEqualizer->nb_FIR_coefs_per_channel    > mTransducerEqualizerParams.nb_alloc_FIR_coefs_per_channel)
               || (pTransducerEqualizer->nb_biquad_cells_per_channel > mTransducerEqualizerParams.nb_alloc_biquad_cells_per_channel))
            {
                return OMX_ErrorBadParameter;
            }

            mConfigUse                 = USE_PROPRIETARY_CONFIG;
            mTransducerEqualizerConfig = *pTransducerEqualizer;

            return OMX_ErrorNone;
        }

        case OMX_Symbian_IndexConfigAudioTransEqualizer:
        {
            CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure, OMX_AUDIO_CONFIG_TRANSDUCEREQUALIZERTYPE);
            OMX_AUDIO_CONFIG_TRANSDUCEREQUALIZERTYPE *pOmxTeqConfig = (OMX_AUDIO_CONFIG_TRANSDUCEREQUALIZERTYPE *) pComponentConfigStructure;
            int                                      channel_min, channel_max, channel;

            mConfigUse = USE_SHAI_CONFIG;
            if(pOmxTeqConfig->nPortIndex != TREQ_OUT_PORT)
            {
                return OMX_ErrorBadPortIndex;
            }
            if(mTransducerEqualizerParams.stereo == OMX_FALSE)
            {
                switch(pOmxTeqConfig->nChannel)
                {
                    case 0:
                    case OMX_ALL:
                        channel_min = 0;
                        channel_max = 0;
                        break;
                    default:
                        return OMX_ErrorBadParameter;
                }
            }
            else
            {
                switch(pOmxTeqConfig->nChannel)
                {
                    case 0:
                        channel_min = 0;
                        channel_max = 0;
                        break;
                    case 1:
                        channel_min = 1;
                        channel_max = 1;
                        break;
                    case OMX_ALL:
                        channel_min = 0;
                        channel_max = 1;
                        break;
                    default:
                        return OMX_ErrorBadParameter;
                }
            }

            if(pOmxTeqConfig->nIIREqualizerBlocks > NB_MAX_TRANSDUCER_EQUALIZER_BIQUAD_CELLS)
            {
                return OMX_ErrorBadParameter;
            }

            switch(pOmxTeqConfig->ePhaseResponseTargetFir)
            {
                case OMX_AUDIO_LinearPhase:
                case OMX_AUDIO_MinimumPhase:
                    break;
                default:
                    return OMX_ErrorBadParameter;
            }

            for(channel = channel_min; channel <= channel_max; channel++)
            {
                mOMX_ConfigAudioTransEqualizer[channel] = *pOmxTeqConfig;
            }

            return OMX_ErrorNone;
        }

        case OMX_Symbian_IndexConfigAudioTransEqualizer_iireq:
        {
            CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure, OMX_AUDIO_CONFIG_IIR_EQUALIZER);
            OMX_AUDIO_CONFIG_IIR_EQUALIZER *pOmxIirConfig = (OMX_AUDIO_CONFIG_IIR_EQUALIZER *) pComponentConfigStructure;
            int                            nb_channel, channel;

            mConfigUse = USE_SHAI_CONFIG;
            if(pOmxIirConfig->nPortIndex != TREQ_OUT_PORT)
            {
                return OMX_ErrorBadPortIndex;
            }
            if(mTransducerEqualizerParams.stereo == OMX_FALSE)
            {
                switch(pOmxIirConfig->nChannel)
                {
                    case 0:
                    case OMX_ALL:
                        nb_channel = 1;
                        break;
                    default:
                        return OMX_ErrorBadParameter;
                }
            }
            else
            {
                switch(pOmxIirConfig->nChannel)
                {
                    case 0:
                    case 1:
                    case OMX_ALL:
                        nb_channel = 2;
                        break;
                    default:
                        return OMX_ErrorBadParameter;
                }
            }
            if(pOmxIirConfig->sBandIndex.nValue * nb_channel >= NB_MAX_TRANSDUCER_EQUALIZER_BIQUAD_CELLS)
            {
                return OMX_ErrorBadParameter;
            }
            switch(pOmxIirConfig->eFilterType)
            {
                case OMX_AUDIO_Peaking:
                case OMX_AUDIO_Lowpass:
                case OMX_AUDIO_Highpass:
                case OMX_AUDIO_Lowshelf:
                case OMX_AUDIO_Highshelf:
                    break;
                default:
                    return OMX_ErrorBadParameter;
            }
            if(pOmxIirConfig->nChannel == OMX_ALL)
            {
                for(channel = 0; channel < nb_channel; channel++)
                {
                    mOMX_ConfigAudioTransEqualizer_iireq  [channel][pOmxIirConfig->sBandIndex.nValue] = *pOmxIirConfig;
                    ConfigAudioTransEqualizer_iireq_status[channel][pOmxIirConfig->sBandIndex.nValue] = TEQ_BIQUAD_CELL_CONFIG;
                }
            }
            else
            {
                mOMX_ConfigAudioTransEqualizer_iireq  [pOmxIirConfig->nChannel][pOmxIirConfig->sBandIndex.nValue] = *pOmxIirConfig;
                ConfigAudioTransEqualizer_iireq_status[pOmxIirConfig->nChannel][pOmxIirConfig->sBandIndex.nValue] = TEQ_BIQUAD_CELL_CONFIG;
            }
            return OMX_ErrorNone;
        }

        case OMX_Symbian_IndexConfigAudioTransEqualizer_firresponse:
        {
            CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure, OMX_AUDIO_CONFIG_FIR_RESPONSE);
            OMX_AUDIO_CONFIG_FIR_RESPONSE *pOmxFirConfig = (OMX_AUDIO_CONFIG_FIR_RESPONSE *) pComponentConfigStructure;
            int                           nb_channel, channel;

            mConfigUse = USE_SHAI_CONFIG;
            if(pOmxFirConfig->nPortIndex != TREQ_OUT_PORT)
            {
                return OMX_ErrorBadPortIndex;
            }
            if(mTransducerEqualizerParams.stereo == OMX_FALSE)
            {
                switch(pOmxFirConfig->nChannel)
                {
                    case 0:
                    case OMX_ALL:
                        nb_channel = 1;
                        break;
                    default:
                        return OMX_ErrorBadParameter;
                }
            }
            else
            {
                switch(pOmxFirConfig->nChannel)
                {
                    case 0:
                    case 1:
                    case OMX_ALL:
                        nb_channel = 2;
                        break;
                    default:
                        return OMX_ErrorBadParameter;
                }
            }
            if(pOmxFirConfig->nFrequencyPoints > MAX_FIRRESPONSE_POINTS)
            {
                return OMX_ErrorBadParameter;
            }
            if(pOmxFirConfig->nFirLength * nb_channel > NB_MAX_TRANSDUCER_EQUALIZER_FIR_COEFS)
            {
                return OMX_ErrorBadParameter;
            }
            if(pOmxFirConfig->nChannel == OMX_ALL)
            {
                for(channel = 0; channel < nb_channel; channel++)
                {
                    mOMX_ConfigAudioTransEqualizer_firresponse[channel] = *pOmxFirConfig;
                }
            }
            else
            {
                mOMX_ConfigAudioTransEqualizer_firresponse[pOmxFirConfig->nChannel] = *pOmxFirConfig;
            }
            return OMX_ErrorNone;
        }

        default:
            return AFM_PcmProcessing::setConfig(nConfigIndex, pComponentConfigStructure);
    }
}


OMX_ERRORTYPE TransducerEqualizer::getConfig(OMX_INDEXTYPE nConfigIndex, OMX_PTR pComponentConfigStructure) const
{
    switch(nConfigIndex)
    {
        case AFM_IndexConfigTransducerEqualizer:
        {
            CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure, AFM_AUDIO_CONFIG_TRANSDUCEREQUALIZERTYPE);
            AFM_AUDIO_CONFIG_TRANSDUCEREQUALIZERTYPE *pTransducerEqualizer = (AFM_AUDIO_CONFIG_TRANSDUCEREQUALIZERTYPE *) pComponentConfigStructure;

            *pTransducerEqualizer = mTransducerEqualizerConfig;
            return OMX_ErrorNone;
        }

        case OMX_Symbian_IndexConfigAudioTransEqualizer:
        {
            CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure, OMX_AUDIO_CONFIG_TRANSDUCEREQUALIZERTYPE);
            OMX_AUDIO_CONFIG_TRANSDUCEREQUALIZERTYPE *pOmxTeqConfig = (OMX_AUDIO_CONFIG_TRANSDUCEREQUALIZERTYPE *) pComponentConfigStructure;
            int                                      channel;

            if(pOmxTeqConfig->nPortIndex != TREQ_OUT_PORT)
            {
                return OMX_ErrorBadPortIndex;
            }
            if(mTransducerEqualizerParams.stereo == OMX_FALSE)
            {
                switch(pOmxTeqConfig->nChannel)
                {
                    case 0:
                    case OMX_ALL:
                        channel = 0;
                        break;
                    default:
                        return OMX_ErrorBadParameter;
                }
            }
            else
            {
                switch(pOmxTeqConfig->nChannel)
                {
                    case 0:
                    case OMX_ALL:
                        channel = 0;
                        break;
                    case 1:
                        channel = 1;
                        break;
                    default:
                        return OMX_ErrorBadParameter;
                }
            }
            *pOmxTeqConfig = mOMX_ConfigAudioTransEqualizer[channel];
            return OMX_ErrorNone;
        }

        case OMX_Symbian_IndexConfigAudioTransEqualizer_iireq:
        {
            CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure, OMX_AUDIO_CONFIG_IIR_EQUALIZER);
            OMX_AUDIO_CONFIG_IIR_EQUALIZER *pOmxIirConfig = (OMX_AUDIO_CONFIG_IIR_EQUALIZER *) pComponentConfigStructure;
            int                            nb_channel, channel;

            if(pOmxIirConfig->nPortIndex != TREQ_OUT_PORT)
            {
                return OMX_ErrorBadPortIndex;
            }
            if(mTransducerEqualizerParams.stereo == OMX_FALSE)
            {
                switch(pOmxIirConfig->nChannel)
                {
                    case 0:
                    case OMX_ALL:
                        nb_channel = 1;
                        channel    = 0;
                        break;
                    default:
                        return OMX_ErrorBadParameter;
                }
            }
            else
            {
                switch(pOmxIirConfig->nChannel)
                {
                    case 0:
                    case OMX_ALL:
                        nb_channel = 2;
                        channel    = 0;
                        break;
                    case 1:
                        nb_channel = 2;
                        channel    = 1;
                        break;
                    default:
                        return OMX_ErrorBadParameter;
                }
            }
            if(pOmxIirConfig->sBandIndex.nValue * nb_channel >= NB_MAX_TRANSDUCER_EQUALIZER_BIQUAD_CELLS)
            {
                return OMX_ErrorBadParameter;
            }
            *pOmxIirConfig = mOMX_ConfigAudioTransEqualizer_iireq[channel][pOmxIirConfig->sBandIndex.nValue];
            return OMX_ErrorNone;
        }

        case OMX_Symbian_IndexConfigAudioTransEqualizer_firresponse:
        {
            CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure, OMX_AUDIO_CONFIG_FIR_RESPONSE);
            OMX_AUDIO_CONFIG_FIR_RESPONSE *pOmxFirConfig = (OMX_AUDIO_CONFIG_FIR_RESPONSE *) pComponentConfigStructure;
            int                           channel;

            if(pOmxFirConfig->nPortIndex != TREQ_OUT_PORT)
            {
                return OMX_ErrorBadPortIndex;
            }
            if(mTransducerEqualizerParams.stereo == OMX_FALSE)
            {
                switch(pOmxFirConfig->nChannel)
                {
                    case 0:
                    case OMX_ALL:
                        channel = 0;
                        break;
                    default:
                        return OMX_ErrorBadParameter;
                }
            }
            else
            {
                switch(pOmxFirConfig->nChannel)
                {
                    case 0:
                    case OMX_ALL:
                        channel = 0;
                        break;
                    case 1:
                        channel = 1;
                        break;
                    default:
                        return OMX_ErrorBadParameter;
                }
            }
            *pOmxFirConfig = mOMX_ConfigAudioTransEqualizer_firresponse[channel];
            return OMX_ErrorNone;
        }

        default:
            return AFM_PcmProcessing::getConfig(nConfigIndex, pComponentConfigStructure);
    }
}


OMX_U32 TransducerEqualizer::getUidTopDictionnary(void)
{
    return KOstTEQ_top_ID;
}


OMX_ERRORTYPE TransducerEqualizer::getSamplingRateChannels(AFM_PcmPort *p_pcmport_in, AFM_PcmPort *p_pcmport_out, int *p_nSamplingRate, int *p_nChannels)
{
    OMX_AUDIO_PARAM_PCMMODETYPE &pcmSettings_in  = p_pcmport_in ->getPcmSettings();
    OMX_AUDIO_PARAM_PCMMODETYPE &pcmSettings_out = p_pcmport_out->getPcmSettings();


#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 1
    fprintf(debug_TEQ_SHAI_file[instance], "TransducerEqualizer::getSamplingRateChannels\n");
    fprintf(debug_TEQ_SHAI_file[instance], "pcmSettings_in.nSamplingRate  = %d\n", (int) pcmSettings_in.nSamplingRate);
    fprintf(debug_TEQ_SHAI_file[instance], "pcmSettings_out.nSamplingRate = %d\n", (int) pcmSettings_out.nSamplingRate);
    fprintf(debug_TEQ_SHAI_file[instance], "pcmSettings_in.nChannels      = %d\n", (int) pcmSettings_in.nChannels);
    fprintf(debug_TEQ_SHAI_file[instance], "pcmSettings_out.nChannels     = %d\n", (int) pcmSettings_out.nChannels);
    fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
    fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 1

    if(   (pcmSettings_in.nSamplingRate != pcmSettings_out.nSamplingRate)
       || (pcmSettings_in.nChannels     != pcmSettings_out.nChannels))
    {
        return OMX_ErrorPortsNotCompatible;
    }

    *p_nSamplingRate = (int) pcmSettings_in.nSamplingRate;
    *p_nChannels     = (int) pcmSettings_in.nChannels;

    return OMX_ErrorNone;
}


void TransducerEqualizer::checkSHAIFilterUpdate(int nChannels)
{
    if(mConfigUse == USE_SHAI_CONFIG)    // SHAI interface is used
    {
        // if sampling rate has changed, set to config all already valid or computed IIR config
        int channel, n, i;

        for(channel = 0; channel < nChannels; channel++)
        {
            n = (int) mOMX_ConfigAudioTransEqualizer[channel].nIIREqualizerBlocks;
            for(i = 0; i < n; i++)
            {
                switch(ConfigAudioTransEqualizer_iireq_status[channel][i])
                {
                    case TEQ_BIQUAD_CELL_VALID:
                    case TEQ_BIQUAD_CELL_COMPUTED:
                        ConfigAudioTransEqualizer_iireq_status[channel][i] = TEQ_BIQUAD_CELL_CONFIG;
                        break;
                    default:
                        break;
                }
            }
            for(; i < NB_MAX_TRANSDUCER_EQUALIZER_BIQUAD_CELLS; i++)
            {
                ConfigAudioTransEqualizer_iireq_status[channel][i] = TEQ_BIQUAD_CELL_RESET;
            }
        }
        for(; channel < 2; channel++)
        {
            for(i = 0; i < NB_MAX_TRANSDUCER_EQUALIZER_BIQUAD_CELLS; i++)
            {
                ConfigAudioTransEqualizer_iireq_status[channel][i] = TEQ_BIQUAD_CELL_RESET;
            }
        }
    }
}


OMX_ERRORTYPE TransducerEqualizer::getEffectParams(int nChannels, void *p_equalizerParams_void)
{
    TransducerEqualizerParams_t *p_equalizerParams = (TransducerEqualizerParams_t *) p_equalizerParams_void;
    bool                        stereo             = (nChannels > 1);
    int                         nb_alloc_biquad_cells_per_channel;
    int                         nb_alloc_FIR_coefs_per_channel;


#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 1
    fprintf(debug_TEQ_SHAI_file[instance], "TransducerEqualizer params :\n");
    fprintf(debug_TEQ_SHAI_file[instance], "nChannels                         = %d\n", nChannels);
    fprintf(debug_TEQ_SHAI_file[instance], "stereo                            = %d\n", (int) mTransducerEqualizerParams.stereo);
    fprintf(debug_TEQ_SHAI_file[instance], "nb_alloc_biquad_cells_per_channel = %d\n", (int) mTransducerEqualizerParams.nb_alloc_biquad_cells_per_channel);
    fprintf(debug_TEQ_SHAI_file[instance], "nb_alloc_FIR_coefs_per_channel    = %d\n", (int) mTransducerEqualizerParams.nb_alloc_FIR_coefs_per_channel);
    fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
    fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 1

    nb_alloc_biquad_cells_per_channel = (int) mTransducerEqualizerParams.nb_alloc_biquad_cells_per_channel;
    nb_alloc_FIR_coefs_per_channel    = (int) mTransducerEqualizerParams.nb_alloc_FIR_coefs_per_channel;
    switch(mConfigUse)
    {
        case USE_PROPRIETARY_CONFIG:
            if((mTransducerEqualizerParams.stereo != 0) != stereo)
            {
                return OMX_ErrorBadParameter;
            }
            break;

        case USE_SHAI_CONFIG:
            if(defaultParams)
            {
                if(stereo)
                {
                    nb_alloc_biquad_cells_per_channel = NB_MAX_TRANSDUCER_EQUALIZER_BIQUAD_CELLS / 2;
                    nb_alloc_FIR_coefs_per_channel    = NB_MAX_TRANSDUCER_EQUALIZER_FIR_COEFS    / 2;
                }
                else
                {
                    nb_alloc_biquad_cells_per_channel = NB_MAX_TRANSDUCER_EQUALIZER_BIQUAD_CELLS;
                    nb_alloc_FIR_coefs_per_channel    = NB_MAX_TRANSDUCER_EQUALIZER_FIR_COEFS;
                }
            }
            else
            {
                if((mTransducerEqualizerParams.stereo != 0) != stereo)
                {
                    return OMX_ErrorBadParameter;
                }
            }
            if((nb_alloc_FIR_coefs_per_channel > 0) && ((nb_alloc_FIR_coefs_per_channel & 1) == 0))
            {
                nb_alloc_FIR_coefs_per_channel--;
            }
            mTransducerEqualizerParams.stereo                            = (OMX_BOOL) stereo;
            mTransducerEqualizerParams.nb_alloc_biquad_cells_per_channel = (OMX_U16)  nb_alloc_biquad_cells_per_channel;
            mTransducerEqualizerParams.nb_alloc_FIR_coefs_per_channel    = (OMX_U16)  nb_alloc_FIR_coefs_per_channel;
            break;

        case USE_TUNING_DATA_CONFIG:
            if(defaultParams)
            {
                nb_alloc_biquad_cells_per_channel = (int) mTransducerEqualizerConfig.nb_biquad_cells_per_channel;
                nb_alloc_FIR_coefs_per_channel    = (int) mTransducerEqualizerConfig.nb_FIR_coefs_per_channel;
                if(   (nChannels * nb_alloc_biquad_cells_per_channel > NB_MAX_TRANSDUCER_EQUALIZER_BIQUAD_CELLS)
                   || (nChannels * nb_alloc_FIR_coefs_per_channel    > NB_MAX_TRANSDUCER_EQUALIZER_FIR_COEFS))
                {
                    return OMX_ErrorBadParameter;
                }
            }
            else
            {
                if((mTransducerEqualizerParams.stereo != 0) != stereo)
                {
                    return OMX_ErrorBadParameter;
                }
            }
            mTransducerEqualizerParams.stereo                            = (OMX_BOOL) stereo;
            mTransducerEqualizerParams.nb_alloc_biquad_cells_per_channel = (OMX_U16)  nb_alloc_biquad_cells_per_channel;
            mTransducerEqualizerParams.nb_alloc_FIR_coefs_per_channel    = (OMX_U16)  nb_alloc_FIR_coefs_per_channel;
            break;

        default:
            return OMX_ErrorUndefined;
    }

    p_equalizerParams->istereo                            = (t_uint16) stereo;
    p_equalizerParams->inb_alloc_biquad_cells_per_channel = (t_uint16) nb_alloc_biquad_cells_per_channel;
    p_equalizerParams->inb_alloc_FIR_coefs_per_channel    = (t_uint16) nb_alloc_FIR_coefs_per_channel;
    p_equalizerParams->ialert_on                          = (t_uint16) false;

    IIR_filter_float[0].p_biquad_cell_list = NULL;
    IIR_filter_float[1].p_biquad_cell_list = NULL;

    return OMX_ErrorNone;
}


OMX_ERRORTYPE TransducerEqualizer::getEffectConfig_IndexConfigTransducerEqualizer(int nChannels, int nSamplingRate, void *p_equalizerConfig_void)
{
    TransducerEqualizerConfig_t *p_equalizerConfig = (TransducerEqualizerConfig_t *) p_equalizerConfig_void;
    bool                        stereo             = (nChannels > 1);
    int                         i, nb_channels, nb_channels_biquad, nb_channels_FIR, smoothing_delay, FIR_smoothing_delay_granularity;
    t_float                     module_avg_l, module_avg_r, module_avg_biquad_l, module_avg_biquad_r, module_avg_FIR_l, module_avg_FIR_r;
    t_float                     *p_module2;
    int                         average_gain_mant_l, average_gain_mant_r, average_gain_exp_l, average_gain_exp_r;


#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
    fprintf(debug_TEQ_SHAI_file[instance], "TransducerEqualizer::getEffectConfig_IndexConfigTransducerEqualizer\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
    if(stereo)
    {
        nb_channels = nb_channels_biquad = nb_channels_FIR = 2;
        if(mTransducerEqualizerConfig.same_biquad_l_r)
        {
            nb_channels_biquad = 1;
        }
        if(mTransducerEqualizerConfig.same_FIR_l_r)
        {
            nb_channels_FIR = 1;
        }
    }
    else
    {
        nb_channels = nb_channels_biquad = nb_channels_FIR = 1;
    }

    if(mTransducerEqualizerConfig.bAutomaticTransitionGain)
    {
        if(mTransducerEqualizerConfig.nb_biquad_cells_per_channel > 0)
        {
            p_module2 = NULL;
            for(i = 0; i < mTransducerEqualizerConfig.nb_biquad_cells_per_channel; i++)
            {
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 5
                fprintf(debug_TEQ_SHAI_file[instance], "compute module_avg_biquad left cell %d\n", i);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 5
                module_avg_biquad(false,
                                  mTransducerEqualizerConfig.biquad_cell[nb_channels_biquad * i].b_exp,
                                  mTransducerEqualizerConfig.biquad_cell[nb_channels_biquad * i].b0,
                                  mTransducerEqualizerConfig.biquad_cell[nb_channels_biquad * i].b1,
                                  mTransducerEqualizerConfig.biquad_cell[nb_channels_biquad * i].b2,
                                  mTransducerEqualizerConfig.biquad_cell[nb_channels_biquad * i].a1,
                                  mTransducerEqualizerConfig.biquad_cell[nb_channels_biquad * i].a2,
                                  0,
                                  &p_module2,
                                  instance);
                if(p_module2 == NULL)
                {
                    return OMX_ErrorInsufficientResources;
                }
            }
            module_avg_biquad_l = module_avg_biquad_r = module_avg_biquad(true, 0, 0, 0, 0, 0, 0, nSamplingRate, &p_module2, instance);
        }
        else
        {
            module_avg_biquad_l = module_avg_biquad_r = 1.0;
        }
        module_avg_FIR_l = module_avg_FIR_r = module_avg_FIR(mTransducerEqualizerConfig.nb_FIR_coefs_per_channel, nb_channels_FIR, mTransducerEqualizerConfig.FIR_coef, nSamplingRate);
        module_avg_l = module_avg_biquad_l * module_avg_FIR_l * ((t_float) mTransducerEqualizerConfig.biquad_gain_mant_l) * ((t_float) mTransducerEqualizerConfig.FIR_gain_mant_l) * pow(2.0, mTransducerEqualizerConfig.biquad_gain_exp_l + mTransducerEqualizerConfig.FIR_gain_exp_l - 62);
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
        fprintf(debug_TEQ_SHAI_file[instance], "module_avg_biquad left  = %1.8f\n", module_avg_biquad_l);
        fprintf(debug_TEQ_SHAI_file[instance], "module_avg_FIR    left  = %1.8f\n", module_avg_FIR_l);
        fprintf(debug_TEQ_SHAI_file[instance], "module_avg        left  = %1.8f\n", module_avg_l);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
        module_avg_l = (module_avg_l < 0.0 ? -module_avg_l : module_avg_l) * 2147483648.0;
        if(module_avg_l == 0.0)
        {
            average_gain_mant_l = 0;
            average_gain_exp_l  = 0;
        }
        else
        {
            average_gain_exp_l = 0;
            while(module_avg_l > 2147483647.0)
            {
                average_gain_exp_l++;
                module_avg_l *= 0.5;
            }
            while(module_avg_l < 1073741823.0)
            {
                average_gain_exp_l--;
                module_avg_l *= 2.0;
            }
            average_gain_mant_l = (int) floor(module_avg_l);
        }
        if(stereo)
        {
            int biquad_gain_exp_r, biquad_gain_mant_r, FIR_gain_exp_r, FIR_gain_mant_r;

            if(mTransducerEqualizerConfig.same_biquad_l_r)
            {
                biquad_gain_exp_r  = mTransducerEqualizerConfig.biquad_gain_exp_l;
                biquad_gain_mant_r = mTransducerEqualizerConfig.biquad_gain_mant_l;
            }
            else
            {
                if(mTransducerEqualizerConfig.nb_biquad_cells_per_channel > 0)
                {
                    p_module2 = NULL;
                    for(i = 0; i < mTransducerEqualizerConfig.nb_biquad_cells_per_channel; i++)
                    {
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 5
                        fprintf(debug_TEQ_SHAI_file[instance], "compute module_avg_biquad right cell %d\n", i);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 5
                        module_avg_biquad(false,
                                          mTransducerEqualizerConfig.biquad_cell[nb_channels_biquad * i + 1].b_exp,
                                          mTransducerEqualizerConfig.biquad_cell[nb_channels_biquad * i + 1].b0,
                                          mTransducerEqualizerConfig.biquad_cell[nb_channels_biquad * i + 1].b1,
                                          mTransducerEqualizerConfig.biquad_cell[nb_channels_biquad * i + 1].b2,
                                          mTransducerEqualizerConfig.biquad_cell[nb_channels_biquad * i + 1].a1,
                                          mTransducerEqualizerConfig.biquad_cell[nb_channels_biquad * i + 1].a2,
                                          0,
                                          &p_module2,
                                          instance);
                        if(p_module2 == NULL)
                        {
                            return OMX_ErrorInsufficientResources;
                        }
                    }
                    module_avg_biquad_r = module_avg_biquad(true, 0, 0, 0, 0, 0, 0, nSamplingRate, &p_module2, instance);
                }
                else
                {
                    module_avg_biquad_r = 1.0;
                }
                biquad_gain_exp_r  = mTransducerEqualizerConfig.biquad_gain_exp_r;
                biquad_gain_mant_r = mTransducerEqualizerConfig.biquad_gain_mant_r;
            }
            if(mTransducerEqualizerConfig.same_FIR_l_r)
            {
                FIR_gain_exp_r   = mTransducerEqualizerConfig.FIR_gain_exp_l;
                FIR_gain_mant_r  = mTransducerEqualizerConfig.FIR_gain_mant_l;
            }
            else
            {
                module_avg_FIR_r = module_avg_FIR(mTransducerEqualizerConfig.nb_FIR_coefs_per_channel, nb_channels_FIR, &mTransducerEqualizerConfig.FIR_coef[1], nSamplingRate);
                FIR_gain_exp_r   = mTransducerEqualizerConfig.FIR_gain_exp_r;
                FIR_gain_mant_r  = mTransducerEqualizerConfig.FIR_gain_mant_r;
            }
            module_avg_r = module_avg_biquad_r * module_avg_FIR_r * ((t_float) biquad_gain_mant_r) * ((t_float) FIR_gain_mant_r) * pow(2.0, biquad_gain_exp_r + FIR_gain_exp_r - 62);
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
            fprintf(debug_TEQ_SHAI_file[instance], "module_avg_biquad right = %1.8f\n", module_avg_biquad_r);
            fprintf(debug_TEQ_SHAI_file[instance], "module_avg_FIR    right = %1.8f\n", module_avg_FIR_r);
            fprintf(debug_TEQ_SHAI_file[instance], "module_avg        right = %1.8f\n", module_avg_r);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 4
            module_avg_r = (module_avg_r < 0.0 ? -module_avg_r : module_avg_r) * 2147483648.0;
            if(module_avg_r == 0.0)
            {
                average_gain_mant_r = 0;
                average_gain_exp_r  = 0;
            }
            else
            {
                average_gain_exp_r = 0;
                while(module_avg_r > 2147483647.0)
                {
                    average_gain_exp_r++;
                    module_avg_r *= 0.5;
                }
                while(module_avg_r < 1073741823.0)
                {
                    average_gain_exp_r--;
                    module_avg_r *= 2.0;
                }
                average_gain_mant_r = (int) floor(module_avg_r);
            }
        }
        else
        {
            average_gain_mant_r = average_gain_mant_l;
            average_gain_exp_r  = average_gain_exp_l;
        }
    }
    else
    {
        average_gain_exp_l  = mTransducerEqualizerConfig.transition_gain_exp_l;
        average_gain_mant_l = mTransducerEqualizerConfig.transition_gain_mant_l;
        average_gain_exp_r  = mTransducerEqualizerConfig.transition_gain_exp_r;
        average_gain_mant_r = mTransducerEqualizerConfig.transition_gain_mant_r;
    }

    if(nSamplingRate > 0)
    {
        FIR_smoothing_delay_granularity = nSamplingRate / 200;  // 5 ms
        smoothing_delay                 = (nSamplingRate * mTransducerEqualizerConfig.smoothing_delay_ms) / 1000;
    }
    else
    {
        FIR_smoothing_delay_granularity = 0;
        smoothing_delay                 = 0;
    }

    p_equalizerConfig->iEnable                           = (t_uint16) (mTransducerEqualizerConfig.bEnable != 0);
    p_equalizerConfig->iautomatic_transition_gain        = (t_uint16) (mTransducerEqualizerConfig.bAutomaticTransitionGain != 0);
    p_equalizerConfig->iaverage_gain_exp_l               = (t_uint16)  average_gain_exp_l;
    p_equalizerConfig->iaverage_gain_mant_l_low          = (t_uint16)  average_gain_mant_l;
    p_equalizerConfig->iaverage_gain_mant_l_high         = (t_uint16) (average_gain_mant_l >> 16);
    p_equalizerConfig->iaverage_gain_exp_r               = (t_uint16)  average_gain_exp_r;
    p_equalizerConfig->iaverage_gain_mant_r_low          = (t_uint16)  average_gain_mant_r;
    p_equalizerConfig->iaverage_gain_mant_r_high         = (t_uint16) (average_gain_mant_r >> 16);
    p_equalizerConfig->itransition_gain_exp_l            = (t_uint16)  mTransducerEqualizerConfig.transition_gain_exp_l;
    p_equalizerConfig->itransition_gain_mant_l_low       = (t_uint16)  mTransducerEqualizerConfig.transition_gain_mant_l;
    p_equalizerConfig->itransition_gain_mant_l_high      = (t_uint16) (mTransducerEqualizerConfig.transition_gain_mant_l >> 16);
    p_equalizerConfig->itransition_gain_exp_r            = (t_uint16)  mTransducerEqualizerConfig.transition_gain_exp_r;
    p_equalizerConfig->itransition_gain_mant_r_low       = (t_uint16)  mTransducerEqualizerConfig.transition_gain_mant_r;
    p_equalizerConfig->itransition_gain_mant_r_high      = (t_uint16) (mTransducerEqualizerConfig.transition_gain_mant_r >> 16);
    p_equalizerConfig->ismoothing_delay_low              = (t_uint16)  smoothing_delay;
    p_equalizerConfig->ismoothing_delay_high             = (t_uint16) (smoothing_delay >> 16);
    p_equalizerConfig->iFIR_smoothing_delay_granularity  = (t_uint16)  FIR_smoothing_delay_granularity;
    p_equalizerConfig->isame_biquad_l_r                  = (t_uint16) (mTransducerEqualizerConfig.same_biquad_l_r != 0);
    p_equalizerConfig->isame_FIR_l_r                     = (t_uint16) (mTransducerEqualizerConfig.same_FIR_l_r    != 0);
    p_equalizerConfig->ibiquad_first                     = (t_uint16) (mTransducerEqualizerConfig.biquad_first    != 0);
    p_equalizerConfig->ibiquad_gain_exp_l                = (t_uint16)  mTransducerEqualizerConfig.biquad_gain_exp_l;
    p_equalizerConfig->ibiquad_gain_mant_l_low           = (t_uint16)  mTransducerEqualizerConfig.biquad_gain_mant_l;
    p_equalizerConfig->ibiquad_gain_mant_l_high          = (t_uint16) (mTransducerEqualizerConfig.biquad_gain_mant_l >> 16);
    p_equalizerConfig->ibiquad_gain_exp_r                = (t_uint16)  mTransducerEqualizerConfig.biquad_gain_exp_r;
    p_equalizerConfig->ibiquad_gain_mant_r_low           = (t_uint16)  mTransducerEqualizerConfig.biquad_gain_mant_r;
    p_equalizerConfig->ibiquad_gain_mant_r_high          = (t_uint16) (mTransducerEqualizerConfig.biquad_gain_mant_r >> 16);
    p_equalizerConfig->iFIR_gain_exp_l                   = (t_uint16)  mTransducerEqualizerConfig.FIR_gain_exp_l;
    p_equalizerConfig->iFIR_gain_mant_l_low              = (t_uint16)  mTransducerEqualizerConfig.FIR_gain_mant_l;
    p_equalizerConfig->iFIR_gain_mant_l_high             = (t_uint16) (mTransducerEqualizerConfig.FIR_gain_mant_l >> 16);
    p_equalizerConfig->iFIR_gain_exp_r                   = (t_uint16)  mTransducerEqualizerConfig.FIR_gain_exp_r;
    p_equalizerConfig->iFIR_gain_mant_r_low              = (t_uint16)  mTransducerEqualizerConfig.FIR_gain_mant_r;
    p_equalizerConfig->iFIR_gain_mant_r_high             = (t_uint16) (mTransducerEqualizerConfig.FIR_gain_mant_r >> 16);
    p_equalizerConfig->inb_biquad_cells_per_channel      = (t_uint16)  mTransducerEqualizerConfig.nb_biquad_cells_per_channel;
    p_equalizerConfig->inb_FIR_coefs_per_channel         = (t_uint16)  mTransducerEqualizerConfig.nb_FIR_coefs_per_channel;

    for(i = 0; i < NB_MAX_TRANSDUCER_EQUALIZER_BIQUAD_CELLS; i++)
    {
        p_equalizerConfig->ibiquad_cells[i].b_exp   = (t_uint16) 0;
        p_equalizerConfig->ibiquad_cells[i].b0_low  = (t_uint16) 0x7FFF;
        p_equalizerConfig->ibiquad_cells[i].b0_high = (t_uint16) 0xFFFF;
        p_equalizerConfig->ibiquad_cells[i].b1_low  = (t_uint16) 0;
        p_equalizerConfig->ibiquad_cells[i].b1_high = (t_uint16) 0;
        p_equalizerConfig->ibiquad_cells[i].b2_low  = (t_uint16) 0;
        p_equalizerConfig->ibiquad_cells[i].b2_high = (t_uint16) 0;
        p_equalizerConfig->ibiquad_cells[i].a1_low  = (t_uint16) 0;
        p_equalizerConfig->ibiquad_cells[i].a1_high = (t_uint16) 0;
        p_equalizerConfig->ibiquad_cells[i].a2_low  = (t_uint16) 0;
        p_equalizerConfig->ibiquad_cells[i].a2_high = (t_uint16) 0;
    }

    for(i = 0; i < nb_channels * mTransducerEqualizerParams.nb_alloc_biquad_cells_per_channel; i++)
    {
        p_equalizerConfig->ibiquad_cells[i].b_exp   = (t_uint16)  mTransducerEqualizerConfig.biquad_cell[i].b_exp;
        p_equalizerConfig->ibiquad_cells[i].b0_low  = (t_uint16)  mTransducerEqualizerConfig.biquad_cell[i].b0;
        p_equalizerConfig->ibiquad_cells[i].b0_high = (t_uint16) (mTransducerEqualizerConfig.biquad_cell[i].b0 >> 16);
        p_equalizerConfig->ibiquad_cells[i].b1_low  = (t_uint16)  mTransducerEqualizerConfig.biquad_cell[i].b1;
        p_equalizerConfig->ibiquad_cells[i].b1_high = (t_uint16) (mTransducerEqualizerConfig.biquad_cell[i].b1 >> 16);
        p_equalizerConfig->ibiquad_cells[i].b2_low  = (t_uint16)  mTransducerEqualizerConfig.biquad_cell[i].b2;
        p_equalizerConfig->ibiquad_cells[i].b2_high = (t_uint16) (mTransducerEqualizerConfig.biquad_cell[i].b2 >> 16);
        p_equalizerConfig->ibiquad_cells[i].a1_low  = (t_uint16)  mTransducerEqualizerConfig.biquad_cell[i].a1;
        p_equalizerConfig->ibiquad_cells[i].a1_high = (t_uint16) (mTransducerEqualizerConfig.biquad_cell[i].a1 >> 16);
        p_equalizerConfig->ibiquad_cells[i].a2_low  = (t_uint16)  mTransducerEqualizerConfig.biquad_cell[i].a2;
        p_equalizerConfig->ibiquad_cells[i].a2_high = (t_uint16) (mTransducerEqualizerConfig.biquad_cell[i].a2 >> 16);
    }

    for(i = 0; i < nb_channels_FIR; i++)
    {
        p_equalizerConfig->iFIR_coefs[i].coef_low  = (t_uint16) 0x7FFF;
        p_equalizerConfig->iFIR_coefs[i].coef_high = (t_uint16) 0xFFFF;
    }

    for(; i < NB_MAX_TRANSDUCER_EQUALIZER_FIR_COEFS; i++)
    {
        p_equalizerConfig->iFIR_coefs[i].coef_low  = (t_uint16) 0;
        p_equalizerConfig->iFIR_coefs[i].coef_high = (t_uint16) 0;
    }

    for(i = 0; i < nb_channels * mTransducerEqualizerParams.nb_alloc_FIR_coefs_per_channel; i++)
    {
        p_equalizerConfig->iFIR_coefs[i].coef_low  = (t_uint16)  mTransducerEqualizerConfig.FIR_coef[i];
        p_equalizerConfig->iFIR_coefs[i].coef_high = (t_uint16) (mTransducerEqualizerConfig.FIR_coef[i] >> 16);
    }

#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 1
    fprintf(debug_TEQ_SHAI_file[instance], "TransducerEqualizer config :\n");
    fprintf(debug_TEQ_SHAI_file[instance], "bEnable                           = %d\n",     (int) mTransducerEqualizerConfig.bEnable);
    fprintf(debug_TEQ_SHAI_file[instance], "bAutomaticTransitionGain          = %d\n",     (int) mTransducerEqualizerConfig.bAutomaticTransitionGain);
    fprintf(debug_TEQ_SHAI_file[instance], "average_gain_exp_l                = %d\n",     (int) average_gain_exp_l);
    fprintf(debug_TEQ_SHAI_file[instance], "average_gain_mant_l               = 0x%08X\n", (int) average_gain_mant_l);
    fprintf(debug_TEQ_SHAI_file[instance], "average_gain_exp_r                = %d\n",     (int) average_gain_exp_r);
    fprintf(debug_TEQ_SHAI_file[instance], "average_gain_mant_r               = 0x%08X\n", (int) average_gain_mant_r);
    fprintf(debug_TEQ_SHAI_file[instance], "transition_gain_exp_l             = %d\n",     (int) mTransducerEqualizerConfig.transition_gain_exp_l);
    fprintf(debug_TEQ_SHAI_file[instance], "transition_gain_mant_l            = 0x%08X\n", (int) mTransducerEqualizerConfig.transition_gain_mant_l);
    fprintf(debug_TEQ_SHAI_file[instance], "transition_gain_exp_r             = %d\n",     (int) mTransducerEqualizerConfig.transition_gain_exp_r);
    fprintf(debug_TEQ_SHAI_file[instance], "transition_gain_mant_r            = 0x%08X\n", (int) mTransducerEqualizerConfig.transition_gain_mant_r);
    fprintf(debug_TEQ_SHAI_file[instance], "smoothing_delay                   = %d\n",     (int) smoothing_delay);
    fprintf(debug_TEQ_SHAI_file[instance], "same_biquad_l_r                   = %d\n",     (int) mTransducerEqualizerConfig.same_biquad_l_r);
    fprintf(debug_TEQ_SHAI_file[instance], "same_FIR_l_r                      = %d\n",     (int) mTransducerEqualizerConfig.same_FIR_l_r);
    fprintf(debug_TEQ_SHAI_file[instance], "biquad_first                      = %d\n",     (int) mTransducerEqualizerConfig.biquad_first);
    fprintf(debug_TEQ_SHAI_file[instance], "biquad_gain_exp_l                 = %d\n",     (int) mTransducerEqualizerConfig.biquad_gain_exp_l);
    fprintf(debug_TEQ_SHAI_file[instance], "biquad_gain_mant_l                = 0x%08X\n", (int) mTransducerEqualizerConfig.biquad_gain_mant_l);
    fprintf(debug_TEQ_SHAI_file[instance], "biquad_gain_exp_r                 = %d\n",     (int) mTransducerEqualizerConfig.biquad_gain_exp_r);
    fprintf(debug_TEQ_SHAI_file[instance], "biquad_gain_mant_r                = 0x%08X\n", (int) mTransducerEqualizerConfig.biquad_gain_mant_r);
    fprintf(debug_TEQ_SHAI_file[instance], "FIR_gain_exp_l                    = %d\n",     (int) mTransducerEqualizerConfig.FIR_gain_exp_l);
    fprintf(debug_TEQ_SHAI_file[instance], "FIR_gain_mant_l                   = 0x%08X\n", (int) mTransducerEqualizerConfig.FIR_gain_mant_l);
    fprintf(debug_TEQ_SHAI_file[instance], "FIR_gain_exp_r                    = %d\n",     (int) mTransducerEqualizerConfig.FIR_gain_exp_r);
    fprintf(debug_TEQ_SHAI_file[instance], "FIR_gain_mant_r                   = 0x%08X\n", (int) mTransducerEqualizerConfig.FIR_gain_mant_r);
    fprintf(debug_TEQ_SHAI_file[instance], "nb_biquad_cells_per_channel       = %d\n",     (int) mTransducerEqualizerConfig.nb_biquad_cells_per_channel);
    fprintf(debug_TEQ_SHAI_file[instance], "nb_FIR_coefs_per_channel          = %d\n",     (int) mTransducerEqualizerConfig.nb_FIR_coefs_per_channel);
    fprintf(debug_TEQ_SHAI_file[instance], "biquad cells :\n");
    for(i = 0; i < (mTransducerEqualizerConfig.nb_biquad_cells_per_channel * (mTransducerEqualizerConfig.same_biquad_l_r ? 1 : 2)); i++)
    {
        fprintf(debug_TEQ_SHAI_file[instance],
                "  b_exp=%+2d - b0=0x%08X - b1=0x%08X - b2=0x%08X - a1=0x%08X - a2=0x%08X\n",
                (int) mTransducerEqualizerConfig.biquad_cell[i].b_exp,
                (int) mTransducerEqualizerConfig.biquad_cell[i].b0,
                (int) mTransducerEqualizerConfig.biquad_cell[i].b1,
                (int) mTransducerEqualizerConfig.biquad_cell[i].b2,
                (int) mTransducerEqualizerConfig.biquad_cell[i].a1,
                (int) mTransducerEqualizerConfig.biquad_cell[i].a2);
    }
    fprintf(debug_TEQ_SHAI_file[instance], "FIR coefs :\n");
    for(i = 0; i < (mTransducerEqualizerConfig.nb_FIR_coefs_per_channel * (mTransducerEqualizerConfig.same_FIR_l_r ? 1 : 2)); i++)
    {
        if((i % 8) == 0)
        {
            fprintf(debug_TEQ_SHAI_file[instance], " ");
        }
        fprintf(debug_TEQ_SHAI_file[instance], " 0x%08X", (int) mTransducerEqualizerConfig.FIR_coef[i]);
        if((i % 8) == 7)
        {
            fprintf(debug_TEQ_SHAI_file[instance], "\n");
        }
    }
    if(i % 8)
    {
        fprintf(debug_TEQ_SHAI_file[instance], "\n");
    }
    fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 1

    return OMX_ErrorNone;
}


OMX_ERRORTYPE TransducerEqualizer::getEffectConfig_OMX_IndexConfigAudioTransEqualizer(int nChannels)
{
    bool stereo = (nChannels > 1);
    int  i;


#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 1
    fprintf(debug_TEQ_SHAI_file[instance], "TransducerEqualizer SHAI config channel 0\n");
    fprintf(debug_TEQ_SHAI_file[instance], "bEnableFir              = %d\n", (int) mOMX_ConfigAudioTransEqualizer[0].bEnableFir);
    fprintf(debug_TEQ_SHAI_file[instance], "bEnableIir              = %d\n", (int) mOMX_ConfigAudioTransEqualizer[0].bEnableIir);
    fprintf(debug_TEQ_SHAI_file[instance], "ePhaseResponseTargetFir = ");
    switch(mOMX_ConfigAudioTransEqualizer[0].ePhaseResponseTargetFir)
    {
        case OMX_AUDIO_PhaseNotDefined:
            fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_PhaseNotDefined\n");
            break;
        case OMX_AUDIO_LinearPhase:
            fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_LinearPhase\n");
            break;
        case OMX_AUDIO_MinimumPhase:
            fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_MinimumPhase\n");
            break;
        default:
            fprintf(debug_TEQ_SHAI_file[instance], "%d\n", (int) mOMX_ConfigAudioTransEqualizer[0].ePhaseResponseTargetFir);
            break;
    }
    fprintf(debug_TEQ_SHAI_file[instance], "ePhaseResponseTargetIir = ");
    switch(mOMX_ConfigAudioTransEqualizer[0].ePhaseResponseTargetIir)
    {
        case OMX_AUDIO_PhaseNotDefined:
            fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_PhaseNotDefined\n");
            break;
        case OMX_AUDIO_LinearPhase:
            fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_LinearPhase\n");
            break;
        case OMX_AUDIO_MinimumPhase:
            fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_MinimumPhase\n");
            break;
        default:
            fprintf(debug_TEQ_SHAI_file[instance], "%d\n", (int) mOMX_ConfigAudioTransEqualizer[0].ePhaseResponseTargetIir);
            break;
    }
    fprintf(debug_TEQ_SHAI_file[instance], "nIIREqualizerBlocks     = %d\n", (int) mOMX_ConfigAudioTransEqualizer[0].nIIREqualizerBlocks);
    fprintf(debug_TEQ_SHAI_file[instance], "nIIREqualizerGain       = %d\n", (int) mOMX_ConfigAudioTransEqualizer[0].nIIREqualizerGain);
    fprintf(debug_TEQ_SHAI_file[instance], "---------------------------------\n");

    if(stereo)
    {
        fprintf(debug_TEQ_SHAI_file[instance], "TransducerEqualizer SHAI config channel 1\n");
        fprintf(debug_TEQ_SHAI_file[instance], "bEnableFir              = %d\n", (int) mOMX_ConfigAudioTransEqualizer[1].bEnableFir);
        fprintf(debug_TEQ_SHAI_file[instance], "bEnableIir              = %d\n", (int) mOMX_ConfigAudioTransEqualizer[1].bEnableIir);
        fprintf(debug_TEQ_SHAI_file[instance], "ePhaseResponseTargetFir = ");
        switch(mOMX_ConfigAudioTransEqualizer[1].ePhaseResponseTargetFir)
        {
            case OMX_AUDIO_PhaseNotDefined:
                fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_PhaseNotDefined\n");
                break;
            case OMX_AUDIO_LinearPhase:
                fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_LinearPhase\n");
                break;
            case OMX_AUDIO_MinimumPhase:
                fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_MinimumPhase\n");
                break;
            default:
                fprintf(debug_TEQ_SHAI_file[instance], "%d\n", (int) mOMX_ConfigAudioTransEqualizer[0].ePhaseResponseTargetFir);
                break;
        }
        fprintf(debug_TEQ_SHAI_file[instance], "ePhaseResponseTargetIir = ");
        switch(mOMX_ConfigAudioTransEqualizer[1].ePhaseResponseTargetIir)
        {
            case OMX_AUDIO_PhaseNotDefined:
                fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_PhaseNotDefined\n");
                break;
            case OMX_AUDIO_LinearPhase:
                fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_LinearPhase\n");
                break;
            case OMX_AUDIO_MinimumPhase:
                fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_MinimumPhase\n");
                break;
            default:
                fprintf(debug_TEQ_SHAI_file[instance], "%d\n", (int) mOMX_ConfigAudioTransEqualizer[0].ePhaseResponseTargetIir);
                break;
        }
        fprintf(debug_TEQ_SHAI_file[instance], "nIIREqualizerBlocks     = %d\n", (int) mOMX_ConfigAudioTransEqualizer[1].nIIREqualizerBlocks);
        fprintf(debug_TEQ_SHAI_file[instance], "nIIREqualizerGain       = %d\n", (int) mOMX_ConfigAudioTransEqualizer[1].nIIREqualizerGain);
        fprintf(debug_TEQ_SHAI_file[instance], "---------------------------------\n");
        fflush(debug_TEQ_SHAI_file[instance]);
    }
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 1

    mTransducerEqualizerConfig.bEnable = OMX_FALSE;
    if(mOMX_ConfigAudioTransEqualizer[0].bEnableIir)
    {
        mTransducerEqualizerConfig.bEnable                     = OMX_TRUE;
        mTransducerEqualizerConfig.nb_biquad_cells_per_channel = mOMX_ConfigAudioTransEqualizer[0].nIIREqualizerBlocks;
        mTransducerEqualizerConfig.biquad_gain_exp_l           = IIR_filter_quantified[0].gain_exp;
        mTransducerEqualizerConfig.biquad_gain_mant_l          = IIR_filter_quantified[0].gain_mant;
        mult_gains(&mTransducerEqualizerConfig.biquad_gain_mant_l, &mTransducerEqualizerConfig.biquad_gain_exp_l, mOMX_ConfigAudioTransEqualizer[0].nIIREqualizerGain, nb_bits_quantif);
    }
    else
    {
        mTransducerEqualizerConfig.nb_biquad_cells_per_channel = 0;
        mTransducerEqualizerConfig.biquad_gain_mant_l          = 0x40000000;
        mTransducerEqualizerConfig.biquad_gain_exp_l           = 1;
    }
    if(mOMX_ConfigAudioTransEqualizer[1].bEnableIir)
    {
        mTransducerEqualizerConfig.bEnable                     = OMX_TRUE;
        if(mOMX_ConfigAudioTransEqualizer[1].nIIREqualizerBlocks > mTransducerEqualizerConfig.nb_biquad_cells_per_channel)
        {
            mTransducerEqualizerConfig.nb_biquad_cells_per_channel = mOMX_ConfigAudioTransEqualizer[1].nIIREqualizerBlocks;
        }
        mTransducerEqualizerConfig.biquad_gain_exp_r           = IIR_filter_quantified[1].gain_exp;
        mTransducerEqualizerConfig.biquad_gain_mant_r          = IIR_filter_quantified[1].gain_mant;
        mult_gains(&mTransducerEqualizerConfig.biquad_gain_mant_r, &mTransducerEqualizerConfig.biquad_gain_exp_r, mOMX_ConfigAudioTransEqualizer[1].nIIREqualizerGain, nb_bits_quantif);
    }
    else
    {
        mTransducerEqualizerConfig.biquad_gain_mant_r          = 0x40000000;
        mTransducerEqualizerConfig.biquad_gain_exp_r           = 1;
    }

    if(mOMX_ConfigAudioTransEqualizer[0].bEnableFir)
    {
        mTransducerEqualizerConfig.bEnable                  = OMX_TRUE;
        mTransducerEqualizerConfig.nb_FIR_coefs_per_channel = mOMX_ConfigAudioTransEqualizer_firresponse[0].nFirLength;
        mTransducerEqualizerConfig.FIR_gain_exp_l           = FIR_filter_quantified[0].gain_exp;
        mTransducerEqualizerConfig.FIR_gain_mant_l          = FIR_filter_quantified[0].gain_mant;
    }
    else
    {
        mTransducerEqualizerConfig.nb_FIR_coefs_per_channel = 0;
        mTransducerEqualizerConfig.FIR_gain_mant_l          = 0x40000000;
        mTransducerEqualizerConfig.FIR_gain_exp_l           = 1;
    }
    if(mOMX_ConfigAudioTransEqualizer[1].bEnableFir)
    {
        mTransducerEqualizerConfig.bEnable                  = OMX_TRUE;
        if(mOMX_ConfigAudioTransEqualizer_firresponse[1].nFirLength > mTransducerEqualizerConfig.nb_FIR_coefs_per_channel)
        {
            mTransducerEqualizerConfig.nb_FIR_coefs_per_channel = mOMX_ConfigAudioTransEqualizer_firresponse[1].nFirLength;
        }
        mTransducerEqualizerConfig.FIR_gain_exp_r           = FIR_filter_quantified[1].gain_exp;
        mTransducerEqualizerConfig.FIR_gain_mant_r          = FIR_filter_quantified[1].gain_mant;
    }
    else
    {
        mTransducerEqualizerConfig.FIR_gain_mant_r          = 0x40000000;
        mTransducerEqualizerConfig.FIR_gain_exp_r           = 1;
    }

    mTransducerEqualizerConfig.biquad_first = OMX_FALSE;
    if(stereo)
    {
        if(   (mOMX_ConfigAudioTransEqualizer[0].bEnableIir == OMX_FALSE)
           && (mOMX_ConfigAudioTransEqualizer[1].bEnableIir == OMX_FALSE))
        {
            mTransducerEqualizerConfig.same_biquad_l_r = OMX_TRUE;
        }
        else if(   (mTransducerEqualizerConfig.biquad_gain_exp_l  != mTransducerEqualizerConfig.biquad_gain_exp_r)
                || (mTransducerEqualizerConfig.biquad_gain_mant_l != mTransducerEqualizerConfig.biquad_gain_mant_r))
        {
            mTransducerEqualizerConfig.same_biquad_l_r = OMX_FALSE;
        }
        else if(   (mOMX_ConfigAudioTransEqualizer[0].bEnableIir          == OMX_TRUE)
                && (mOMX_ConfigAudioTransEqualizer[1].bEnableIir          == OMX_TRUE)
                && (mOMX_ConfigAudioTransEqualizer[0].nIIREqualizerBlocks == mOMX_ConfigAudioTransEqualizer[1].nIIREqualizerBlocks))
        {
            mTransducerEqualizerConfig.same_biquad_l_r = OMX_TRUE;
            for(i = 0; i < (int) mOMX_ConfigAudioTransEqualizer[0].nIIREqualizerBlocks; i++)
            {
                if(   (IIR_filter_quantified[0].biquad_cell[i].b_exp != IIR_filter_quantified[1].biquad_cell[i].b_exp)
                   || (IIR_filter_quantified[0].biquad_cell[i].b0    != IIR_filter_quantified[1].biquad_cell[i].b0)
                   || (IIR_filter_quantified[0].biquad_cell[i].b1    != IIR_filter_quantified[1].biquad_cell[i].b1)
                   || (IIR_filter_quantified[0].biquad_cell[i].b2    != IIR_filter_quantified[1].biquad_cell[i].b2)
                   || (IIR_filter_quantified[0].biquad_cell[i].a1    != IIR_filter_quantified[1].biquad_cell[i].a1)
                   || (IIR_filter_quantified[0].biquad_cell[i].a2    != IIR_filter_quantified[1].biquad_cell[i].a2))
                {
                    mTransducerEqualizerConfig.same_biquad_l_r = OMX_FALSE;
                    break;
                }
            }
        }
        else
        {
            mTransducerEqualizerConfig.same_biquad_l_r = OMX_FALSE;
        }

        if(   (mOMX_ConfigAudioTransEqualizer[0].bEnableFir == OMX_FALSE)
           && (mOMX_ConfigAudioTransEqualizer[1].bEnableFir == OMX_FALSE))
        {
            mTransducerEqualizerConfig.same_FIR_l_r = OMX_TRUE;
        }
        else if(   (mTransducerEqualizerConfig.FIR_gain_exp_l  != mTransducerEqualizerConfig.FIR_gain_exp_r)
                || (mTransducerEqualizerConfig.FIR_gain_mant_l != mTransducerEqualizerConfig.FIR_gain_mant_r))
        {
            mTransducerEqualizerConfig.same_FIR_l_r = OMX_FALSE;
        }
        else if(   (mOMX_ConfigAudioTransEqualizer[0].bEnableFir == OMX_TRUE)
                && (mOMX_ConfigAudioTransEqualizer[1].bEnableFir == OMX_TRUE)
                && (mOMX_ConfigAudioTransEqualizer_firresponse[0].nFirLength  == mOMX_ConfigAudioTransEqualizer_firresponse[1].nFirLength))
        {
            mTransducerEqualizerConfig.same_FIR_l_r = OMX_TRUE;
            for(i = 0; i < (int) mOMX_ConfigAudioTransEqualizer_firresponse[0].nFirLength; i++)
            {
                if(FIR_filter_quantified[0].coef[i] != FIR_filter_quantified[1].coef[i])
                {
                    mTransducerEqualizerConfig.same_FIR_l_r = OMX_FALSE;
                    break;
                }
            }
        }
        else
        {
            mTransducerEqualizerConfig.same_FIR_l_r = OMX_FALSE;
        }
    }
    else
    {
        mTransducerEqualizerConfig.same_biquad_l_r = OMX_TRUE;
        mTransducerEqualizerConfig.same_FIR_l_r    = OMX_TRUE;
    }

    if(mTransducerEqualizerConfig.same_biquad_l_r == OMX_FALSE)
    {
        if(mOMX_ConfigAudioTransEqualizer[0].bEnableIir)
        {
            for(i = 0; i < (int) mOMX_ConfigAudioTransEqualizer[0].nIIREqualizerBlocks; i++)
            {
                mTransducerEqualizerConfig.biquad_cell[2 * i + 0].b_exp = IIR_filter_quantified[0].biquad_cell[i].b_exp;
                mTransducerEqualizerConfig.biquad_cell[2 * i + 0].b0    = IIR_filter_quantified[0].biquad_cell[i].b0;
                mTransducerEqualizerConfig.biquad_cell[2 * i + 0].b1    = IIR_filter_quantified[0].biquad_cell[i].b1;
                mTransducerEqualizerConfig.biquad_cell[2 * i + 0].b2    = IIR_filter_quantified[0].biquad_cell[i].b2;
                mTransducerEqualizerConfig.biquad_cell[2 * i + 0].a1    = IIR_filter_quantified[0].biquad_cell[i].a1;
                mTransducerEqualizerConfig.biquad_cell[2 * i + 0].a2    = IIR_filter_quantified[0].biquad_cell[i].a2;
            }
        }
        else
        {
            i = 0;
        }
        for(; i < (int) mTransducerEqualizerConfig.nb_biquad_cells_per_channel; i++)
        {
            mTransducerEqualizerConfig.biquad_cell[2 * i + 0].b_exp = 1;
            mTransducerEqualizerConfig.biquad_cell[2 * i + 0].b0    = 0x40000000;
            mTransducerEqualizerConfig.biquad_cell[2 * i + 0].b1    = 0;
            mTransducerEqualizerConfig.biquad_cell[2 * i + 0].b2    = 0;
            mTransducerEqualizerConfig.biquad_cell[2 * i + 0].a1    = 0;
            mTransducerEqualizerConfig.biquad_cell[2 * i + 0].a2    = 0;
        }
        if(mOMX_ConfigAudioTransEqualizer[1].bEnableIir)
        {
            for(i = 0; i < (int) mOMX_ConfigAudioTransEqualizer[1].nIIREqualizerBlocks; i++)
            {
                mTransducerEqualizerConfig.biquad_cell[2 * i + 1].b_exp = IIR_filter_quantified[1].biquad_cell[i].b_exp;
                mTransducerEqualizerConfig.biquad_cell[2 * i + 1].b0    = IIR_filter_quantified[1].biquad_cell[i].b0;
                mTransducerEqualizerConfig.biquad_cell[2 * i + 1].b1    = IIR_filter_quantified[1].biquad_cell[i].b1;
                mTransducerEqualizerConfig.biquad_cell[2 * i + 1].b2    = IIR_filter_quantified[1].biquad_cell[i].b2;
                mTransducerEqualizerConfig.biquad_cell[2 * i + 1].a1    = IIR_filter_quantified[1].biquad_cell[i].a1;
                mTransducerEqualizerConfig.biquad_cell[2 * i + 1].a2    = IIR_filter_quantified[1].biquad_cell[i].a2;
            }
        }
        else
        {
            i = 0;
        }
        for(; i < (int) mTransducerEqualizerConfig.nb_biquad_cells_per_channel; i++)
        {
            mTransducerEqualizerConfig.biquad_cell[2 * i + 1].b_exp = 1;
            mTransducerEqualizerConfig.biquad_cell[2 * i + 1].b0    = 0x40000000;
            mTransducerEqualizerConfig.biquad_cell[2 * i + 1].b1    = 0;
            mTransducerEqualizerConfig.biquad_cell[2 * i + 1].b2    = 0;
            mTransducerEqualizerConfig.biquad_cell[2 * i + 1].a1    = 0;
            mTransducerEqualizerConfig.biquad_cell[2 * i + 1].a2    = 0;
        }
    }
    else
    {
        for(i = 0; i < (int) mTransducerEqualizerConfig.nb_biquad_cells_per_channel; i++)
        {
            mTransducerEqualizerConfig.biquad_cell[i].b_exp = IIR_filter_quantified[0].biquad_cell[i].b_exp;
            mTransducerEqualizerConfig.biquad_cell[i].b0    = IIR_filter_quantified[0].biquad_cell[i].b0;
            mTransducerEqualizerConfig.biquad_cell[i].b1    = IIR_filter_quantified[0].biquad_cell[i].b1;
            mTransducerEqualizerConfig.biquad_cell[i].b2    = IIR_filter_quantified[0].biquad_cell[i].b2;
            mTransducerEqualizerConfig.biquad_cell[i].a1    = IIR_filter_quantified[0].biquad_cell[i].a1;
            mTransducerEqualizerConfig.biquad_cell[i].a2    = IIR_filter_quantified[0].biquad_cell[i].a2;
        }
    }

    if(mTransducerEqualizerConfig.same_FIR_l_r == OMX_FALSE)
    {
        if(mOMX_ConfigAudioTransEqualizer[0].bEnableFir)
        {
            for(i = 0; i < (int) mOMX_ConfigAudioTransEqualizer_firresponse[0].nFirLength; i++)
            {
                mTransducerEqualizerConfig.FIR_coef[2 * i + 0] = FIR_filter_quantified[0].coef[i];
            }
        }
        else if(mTransducerEqualizerConfig.nb_FIR_coefs_per_channel > 0)
        {
            mTransducerEqualizerConfig.FIR_coef[0] = 0x40000000;
            mTransducerEqualizerConfig.FIR_gain_exp_l++;
            i = 1;
        }
        for(; i < (int) mTransducerEqualizerConfig.nb_FIR_coefs_per_channel; i++)
        {
            mTransducerEqualizerConfig.FIR_coef[2 * i + 0] = 0;
        }
        if(mOMX_ConfigAudioTransEqualizer[1].bEnableFir)
        {
            for(i = 0; i < (int) mOMX_ConfigAudioTransEqualizer_firresponse[1].nFirLength; i++)
            {
                mTransducerEqualizerConfig.FIR_coef[2 * i + 1] = FIR_filter_quantified[1].coef[i];
            }
        }
        else if(mTransducerEqualizerConfig.nb_FIR_coefs_per_channel > 0)
        {
            mTransducerEqualizerConfig.FIR_coef[1] = 0x40000000;
            mTransducerEqualizerConfig.FIR_gain_exp_r++;
            i = 1;
        }
        for(; i < (int) mTransducerEqualizerConfig.nb_FIR_coefs_per_channel; i++)
        {
            mTransducerEqualizerConfig.FIR_coef[2 * i + 1] = 0;
        }
    }
    else
    {
        for(i = 0; i < (int) mTransducerEqualizerConfig.nb_FIR_coefs_per_channel; i++)
        {
            mTransducerEqualizerConfig.FIR_coef[i] = FIR_filter_quantified[0].coef[i];
        }
    }

    return OMX_ErrorNone;
}


OMX_ERRORTYPE TransducerEqualizer::getEffectConfig_OMX_IndexConfigAudioTransEqualizer_iireq(int nChannels, int nSamplingRate)
{
    bool stereo = (nChannels > 1);
    int  i, nb_channel, channel;

    if(stereo)
    {
        nb_channel = 2;
        if(mOMX_ConfigAudioTransEqualizer[0].nIIREqualizerBlocks == mOMX_ConfigAudioTransEqualizer[1].nIIREqualizerBlocks)
        {
            mTransducerEqualizerConfig.same_biquad_l_r = OMX_TRUE;
            for(i = 0; i < (int) mOMX_ConfigAudioTransEqualizer[0].nIIREqualizerBlocks; i++)
            {
                if(memcmp(&mOMX_ConfigAudioTransEqualizer_iireq[0][i], &mOMX_ConfigAudioTransEqualizer_iireq[1][i], sizeof(OMX_AUDIO_CONFIG_IIR_EQUALIZER)) != 0)
                {
                    mTransducerEqualizerConfig.same_biquad_l_r = OMX_FALSE;
                    break;
                }
            }
        }
        else
        {
            mTransducerEqualizerConfig.same_biquad_l_r = OMX_FALSE;
        }
    }
    else
    {
        nb_channel                                  = 1;
        mTransducerEqualizerConfig.same_biquad_l_r = OMX_TRUE;
    }

    for(channel = 0; channel < nb_channel; channel++)
    {
        OMX_ERRORTYPE ret;

        IIR_filter_quantified[channel].nb_max_cells = mTransducerEqualizerParams.nb_alloc_biquad_cells_per_channel;

        if(mOMX_ConfigAudioTransEqualizer[channel].nIIREqualizerBlocks > 0)
        {
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 1
            fprintf(debug_TEQ_SHAI_file[instance], "TransducerEqualizer SHAI IIR config channel %d\n", channel);
            fprintf(debug_TEQ_SHAI_file[instance], "nSamplingRate           = %d Hz\n", nSamplingRate);
            switch(mOMX_ConfigAudioTransEqualizer[channel].ePhaseResponseTargetIir)
            {
                case OMX_AUDIO_LinearPhase:
                    fprintf(debug_TEQ_SHAI_file[instance], "ePhaseResponseTargetIir = OMX_AUDIO_LinearPhase\n");
                    break;
                case OMX_AUDIO_MinimumPhase:
                    fprintf(debug_TEQ_SHAI_file[instance], "ePhaseResponseTargetIir = OMX_AUDIO_MinimumPhase\n");
                    break;
                case OMX_AUDIO_PhaseNotDefined:
                    fprintf(debug_TEQ_SHAI_file[instance], "ePhaseResponseTargetIir = OMX_AUDIO_PhaseNotDefined\n");
                    break;
                default:
                    fprintf(debug_TEQ_SHAI_file[instance], "ePhaseResponseTargetIir=%d\n", mOMX_ConfigAudioTransEqualizer[channel].ePhaseResponseTargetIir);
                    break;
            }
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 1

            for(i = 0; i < (int) mOMX_ConfigAudioTransEqualizer[channel].nIIREqualizerBlocks; i++)
            {
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 1
                fprintf(debug_TEQ_SHAI_file[instance], "sBandIndex = %d\n", (int) mOMX_ConfigAudioTransEqualizer_iireq[channel][i].sBandIndex.nValue);
                fprintf(debug_TEQ_SHAI_file[instance], "ConfigAudioTransEqualizer_iireq_status = ");
                switch(ConfigAudioTransEqualizer_iireq_status[channel][i])
                {
                    case TEQ_BIQUAD_CELL_RESET:
                        fprintf(debug_TEQ_SHAI_file[instance], "TEQ_BIQUAD_CELL_RESET\n");
                        break;
                    case TEQ_BIQUAD_CELL_CONFIG:
                        fprintf(debug_TEQ_SHAI_file[instance], "TEQ_BIQUAD_CELL_CONFIG\n");
                        break;
                    case TEQ_BIQUAD_CELL_VALID:
                        fprintf(debug_TEQ_SHAI_file[instance], "TEQ_BIQUAD_CELL_VALID\n");
                        break;
                    case TEQ_BIQUAD_CELL_COMPUTED:
                        fprintf(debug_TEQ_SHAI_file[instance], "TEQ_BIQUAD_CELL_COMPUTED\n");
                        break;
                    default:
                        fprintf(debug_TEQ_SHAI_file[instance], "%d\n", ConfigAudioTransEqualizer_iireq_status[channel][i]);
                        break;
                }
                fprintf(debug_TEQ_SHAI_file[instance], "eFilterType = ");
                switch(mOMX_ConfigAudioTransEqualizer_iireq[channel][i].eFilterType)
                {
                    case OMX_AUDIO_NotDefined:
                        fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_NotDefined\n");
                        break;
                    case OMX_AUDIO_Peaking:
                        fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_Peaking\n");
                        break;
                    case OMX_AUDIO_Lowpass:
                        fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_Lowpass\n");
                        break;
                    case OMX_AUDIO_Highpass:
                        fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_Highpass\n");
                        break;
                    case OMX_AUDIO_Lowshelf:
                        fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_Lowshelf\n");
                        break;
                    case OMX_AUDIO_Highshelf:
                        fprintf(debug_TEQ_SHAI_file[instance], "OMX_AUDIO_Highshelf\n");
                        break;
                    default:
                        fprintf(debug_TEQ_SHAI_file[instance], "%d\n", (int) mOMX_ConfigAudioTransEqualizer_iireq[channel][i].eFilterType);
                        break;
                }
                fprintf(debug_TEQ_SHAI_file[instance], "nFilterGain                  = %d mB\n", (int) mOMX_ConfigAudioTransEqualizer_iireq[channel][i].nFilterGain);
                fprintf(debug_TEQ_SHAI_file[instance], "nFilterCenterCutoffFrequency = %d Hz\n", (int) mOMX_ConfigAudioTransEqualizer_iireq[channel][i].nFilterCenterCutoffFrequency);
                fprintf(debug_TEQ_SHAI_file[instance], "nFilterBandwidth             = %d Hz\n", (int) mOMX_ConfigAudioTransEqualizer_iireq[channel][i].nFilterBandwidth);
                fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
                fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 1

                if((channel == 0) || !mTransducerEqualizerConfig.same_biquad_l_r)
                {
                    switch(ConfigAudioTransEqualizer_iireq_status[channel][i])
                    {
                        case TEQ_BIQUAD_CELL_CONFIG:
                        case TEQ_BIQUAD_CELL_VALID:
                            ret = TEQ_SHAI_compute_biquad(&mOMX_ConfigAudioTransEqualizer_iireq[channel][i],
                                                          nSamplingRate,
                                                          &IIR_filter_float[channel],
                                                          instance);
                            if(ret != OMX_ErrorNone)
                            {
                                ConfigAudioTransEqualizer_iireq_status[channel][i] = TEQ_BIQUAD_CELL_RESET;
                                return ret;
                            }
                            ConfigAudioTransEqualizer_iireq_status[channel][i] = TEQ_BIQUAD_CELL_COMPUTED;
                            break;

                        default:
                            break;
                    }
                }
            }

            if((channel == 0) || !mTransducerEqualizerConfig.same_biquad_l_r)
            {
                for(i = 0; i < (int) mOMX_ConfigAudioTransEqualizer[channel].nIIREqualizerBlocks; i++)
                {
                    if(ConfigAudioTransEqualizer_iireq_status[channel][i] != TEQ_BIQUAD_CELL_COMPUTED)
                    {
                        break;
                    }
                }

                if(i == (int) mOMX_ConfigAudioTransEqualizer[channel].nIIREqualizerBlocks)
                {
                    // all biquad cells have been set for current channel, so global IIR filter may be computed

#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 0
                    long long int start_time, end_time;

                    start_time = LOS_getSystemTime();
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 0

                    ret = TEQ_SHAI_compute_IIR((int) mOMX_ConfigAudioTransEqualizer[channel].nIIREqualizerBlocks,
                                               &IIR_filter_float[channel],
                                               &IIR_filter_quantified[channel],
                                               BIQUAD_DOWN_SORT,
                                               nb_bits_quantif,
                                               instance);

#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 0
                    end_time = LOS_getSystemTime();
                    fprintf(debug_TEQ_SHAI_file[instance], "**************************************************************************************\n");
                    fprintf(debug_TEQ_SHAI_file[instance], "TEQ_SHAI_compute_IIR duration = %lld micro-seconds\n", end_time - start_time);
                    fprintf(debug_TEQ_SHAI_file[instance], "**************************************************************************************\n");
                    fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 0

                    if(ret != OMX_ErrorNone)
                    {
                        for(i = 0; i < (int) mOMX_ConfigAudioTransEqualizer[channel].nIIREqualizerBlocks; i++)
                        {
                            ConfigAudioTransEqualizer_iireq_status[channel][i] = TEQ_BIQUAD_CELL_RESET;
                        }
                        return ret;
                    }

                    // if all is OK, set all biquad cells status to valid to reconstruct list (in TEQ_SHAI.C)
                    // when next setConfig will happen
                    for(i = 0; i < (int) mOMX_ConfigAudioTransEqualizer[channel].nIIREqualizerBlocks; i++)
                    {
                        ConfigAudioTransEqualizer_iireq_status[channel][i] = TEQ_BIQUAD_CELL_VALID;
                    }

                    // if same_biquad_l_r, copy result in other channels
                    if((channel == 0) && (nb_channel > 1) && mTransducerEqualizerConfig.same_biquad_l_r)
                    {
                        for(channel = 1; channel < nb_channel; channel++)
                        {
                            IIR_filter_quantified[channel] = IIR_filter_quantified[0];
                        }
                        channel = 0;
                    }
                }
            }
        }
    }

    return OMX_ErrorNone;
}


OMX_ERRORTYPE TransducerEqualizer::getEffectConfig_OMX_IndexConfigAudioTransEqualizer_firresponse(int nChannels, int nSamplingRate)
{
    bool stereo = (nChannels > 1);
    int  nb_channel, channel;


    if(stereo)
    {
        nb_channel = 2;
        if(memcmp(&mOMX_ConfigAudioTransEqualizer_firresponse[0],
                  &mOMX_ConfigAudioTransEqualizer_firresponse[1],
                  sizeof(OMX_AUDIO_CONFIG_FIR_RESPONSE)) == 0)
        {
            mTransducerEqualizerConfig.same_FIR_l_r = OMX_TRUE;
        }
        else
        {
            mTransducerEqualizerConfig.same_FIR_l_r = OMX_FALSE;
        }
    }
    else
    {
        nb_channel                               = 1;
        mTransducerEqualizerConfig.same_FIR_l_r = OMX_TRUE;
    }

    for(channel = 0; channel < nb_channel; channel++)
    {
        if(mOMX_ConfigAudioTransEqualizer_firresponse[channel].nFrequencyPoints > 0)
        {
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 1
            int i;

            fprintf(debug_TEQ_SHAI_file[instance], "TransducerEqualizer SHAI FIR config channel %d\n", channel);
            fprintf(debug_TEQ_SHAI_file[instance], "nSamplingRate           = %d Hz\n", nSamplingRate);
            switch(mOMX_ConfigAudioTransEqualizer[channel].ePhaseResponseTargetFir)
            {
                case OMX_AUDIO_LinearPhase:
                    fprintf(debug_TEQ_SHAI_file[instance], "ePhaseResponseTargetFir = OMX_AUDIO_LinearPhase\n");
                    break;
                case OMX_AUDIO_MinimumPhase:
                    fprintf(debug_TEQ_SHAI_file[instance], "ePhaseResponseTargetFir = OMX_AUDIO_MinimumPhase\n");
                    break;
                case OMX_AUDIO_PhaseNotDefined:
                    fprintf(debug_TEQ_SHAI_file[instance], "ePhaseResponseTargetFir = OMX_AUDIO_PhaseNotDefined\n");
                    break;
                default:
                    fprintf(debug_TEQ_SHAI_file[instance], "ePhaseResponseTargetFir=%d\n", mOMX_ConfigAudioTransEqualizer[channel].ePhaseResponseTargetFir);
                    break;
            }
            fprintf(debug_TEQ_SHAI_file[instance], "nFrequencyPoints = %d\n", (int) mOMX_ConfigAudioTransEqualizer_firresponse[channel].nFrequencyPoints);
            for(i = 0; i < (int) mOMX_ConfigAudioTransEqualizer_firresponse[channel].nFrequencyPoints; i ++)
            {
                fprintf(debug_TEQ_SHAI_file[instance],
                        "nFrequencies[%2d] = %5d Hz - nGains[%2d] = %5d mB\n",
                        i, (int) mOMX_ConfigAudioTransEqualizer_firresponse[channel].nFrequencies[i],
                        i, (int) mOMX_ConfigAudioTransEqualizer_firresponse[channel].nGains[i]);
            }
            fprintf(debug_TEQ_SHAI_file[instance], "nFirLength       = %d\n", (int) mOMX_ConfigAudioTransEqualizer_firresponse[channel].nFirLength);
            fprintf(debug_TEQ_SHAI_file[instance], "--------------------------------------------------\n");
            fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 1

            FIR_filter_quantified[channel].nb_max_coefs = mTransducerEqualizerParams.nb_alloc_FIR_coefs_per_channel;

            if((channel == 0) || !mTransducerEqualizerConfig.same_FIR_l_r)
            {
                OMX_ERRORTYPE ret;
#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 0
                long long int start_time, end_time;

                start_time = LOS_getSystemTime();
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 0

                ret = TEQ_SHAI_compute_FIR(mOMX_ConfigAudioTransEqualizer[channel].ePhaseResponseTargetFir,
                                           &mOMX_ConfigAudioTransEqualizer_firresponse[channel],
                                           nSamplingRate,
                                           &FIR_filter_quantified[channel],
                                           mOMX_ConfigAudioTransEqualizer_firresponse[channel].nFirLength,
                                           nb_bits_quantif,
                                           instance);

#if DEBUG_TEQ_SHAI_CONFIG_LEVEL > 0
                end_time = LOS_getSystemTime();
                fprintf(debug_TEQ_SHAI_file[instance], "**************************************************************************************\n");
                fprintf(debug_TEQ_SHAI_file[instance], "TEQ_SHAI_compute_FIR duration = %lld micro-seconds\n", end_time - start_time);
                fprintf(debug_TEQ_SHAI_file[instance], "**************************************************************************************\n");
                fflush(debug_TEQ_SHAI_file[instance]);
#endif // DEBUG_TEQ_SHAI_CONFIG_LEVEL > 0

                if(ret != OMX_ErrorNone)
                {
                    return ret;
                }

                // if same_FIR_l_r, copy result in other channels
                if((channel == 0) && (nb_channel > 1) && mTransducerEqualizerConfig.same_FIR_l_r)
                {
                    for(channel = 1; channel < nb_channel; channel++)
                    {
                        FIR_filter_quantified[channel] = FIR_filter_quantified[0];
                    }
                    channel = 0;
                }
            }
        }
    }

    return OMX_ErrorNone;
}
