/*
 * Copyright (C) ST-Ericsson SA 2010. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 */

#include "PcmSplitter.h"
#include "PcmSplitter_PcmPort.h"

#ifndef  MPC_ONLY
#include "NmfHostVolCtrl.h"
#include "PcmSplitterNmfHost.h"
#endif

#ifndef HOST_ONLY
#include "NmfMpcVolCtrl.h"
#include "PcmSplitterNmfMpc.h"
#endif

// UID top dictionnary (generated by trace compiler)
#include "PCM_SPLITTER_top.h"
#include "PCM_SPLITTER_host_top.h"

#ifndef HOST_ONLY
OMX_ERRORTYPE pcmsplitterFactoryMethod(ENS_Component_p * ppENSComponent) {
    OMX_ERRORTYPE error  = OMX_ErrorNone;

    PcmSplitter *pcmsplitter = new PcmSplitter(OMX_FALSE);
    if (pcmsplitter == 0) {
        return OMX_ErrorInsufficientResources;
    }

    error = pcmsplitter->construct();
    if (error != OMX_ErrorNone){
        delete pcmsplitter;
        *ppENSComponent = 0;
        return OMX_ErrorInsufficientResources;
    }
    else{
        *ppENSComponent = pcmsplitter;
    }

    PcmSplitterNmfMpc *pcmsplitter_ProcessingComp = new PcmSplitterNmfMpc(*pcmsplitter);
    if (pcmsplitter_ProcessingComp == 0) {
        delete pcmsplitter;
        return OMX_ErrorInsufficientResources;
    }

    pcmsplitter->setProcessingComponent(pcmsplitter_ProcessingComp);

    return error;
}

#endif //HOST_ONLY


#ifndef MPC_ONLY
OMX_ERRORTYPE pcmsplitterhostFactoryMethod(ENS_Component_p * ppENSComponent) {
    OMX_ERRORTYPE error  = OMX_ErrorNone;

    PcmSplitter *pcmsplitter = new PcmSplitter(OMX_TRUE);
    if (pcmsplitter == 0) {
        return OMX_ErrorInsufficientResources;
    }

    error = pcmsplitter->construct();
    if (error != OMX_ErrorNone){
        delete pcmsplitter;
        *ppENSComponent = 0;
        return OMX_ErrorInsufficientResources;
    }
    else{
        *ppENSComponent = pcmsplitter;
    }

    PcmSplitterNmfHost *pcmsplitter_ProcessingComp = new PcmSplitterNmfHost(*pcmsplitter);
    if (pcmsplitter_ProcessingComp == 0) {
        delete pcmsplitter;
        return OMX_ErrorInsufficientResources;
    }

    pcmsplitter->setProcessingComponent(pcmsplitter_ProcessingComp);

    return error;
}
#endif //MPC_ONLY

OMX_ERRORTYPE PcmSplitter::construct(void)
{
    OMX_ERRORTYPE error;
    OMX_U32 idx, nRoleCount=1;
    OMX_AUDIO_PARAM_PCMMODETYPE defaultPcmSettings;
    PcmSplitter_PcmPort *pcmsplitterPort;

    error = AFM_Component::construct(NB_OUTPUT_PORTS + NB_INPUT_PORTS, nRoleCount,mIsHost);
    if (error != OMX_ErrorNone) return error;

    ENS_String<25> role;
    // Same roles for ARM and DSP
    role = "audio_splitter.pcm";
    role.put((OMX_STRING)mRoles[0]);

    setActiveRole(mRoles[0]);

    mBlockSize = DEFAULT_PCM_BLOCKSIZE;
    defaultPcmSettings.nSize          = sizeof(OMX_AUDIO_PARAM_PCMMODETYPE);
    defaultPcmSettings.eNumData       = OMX_NumericalDataSigned;
    defaultPcmSettings.eEndian        = OMX_EndianLittle;
    defaultPcmSettings.bInterleaved   = OMX_TRUE;
    defaultPcmSettings.ePCMMode       = OMX_AUDIO_PCMModeLinear;
    defaultPcmSettings.nBitPerSample  = 16;

    defaultPcmSettings.nChannels      = 2;
    defaultPcmSettings.nSamplingRate  = 48000;
    defaultPcmSettings.nPortIndex     = 0;

    defaultPcmSettings.eChannelMapping[0] = OMX_AUDIO_ChannelLF;
    defaultPcmSettings.eChannelMapping[1] = OMX_AUDIO_ChannelRF;

    //Create PcmSplitter Input Port
    pcmsplitterPort =
        new PcmSplitter_PcmPort(0,
                OMX_DirInput,
                mBlockSize * defaultPcmSettings.nChannels * defaultPcmSettings.nBitPerSample/8,
                defaultPcmSettings,
                *this);

    if (pcmsplitterPort == 0) {
        return OMX_ErrorInsufficientResources;
    }

    addPort(pcmsplitterPort);
    if (mIsHost == OMX_TRUE) {
        pcmsplitterPort->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);
    } else {
        pcmsplitterPort->setSupportedProprietaryComm(AFM_MPC_PROPRIETARY_COMMUNICATION);;
    }

    //Create PcmSplitter Output Ports
    for (idx=1; idx<getPortCount(); idx++) {
        defaultPcmSettings.nPortIndex = idx;
        pcmsplitterPort = new PcmSplitter_PcmPort(
                idx,
                OMX_DirOutput,
                mBlockSize * defaultPcmSettings.nChannels * defaultPcmSettings.nBitPerSample/8,
                defaultPcmSettings,
                *this);

        if (pcmsplitterPort == 0) {
            return OMX_ErrorInsufficientResources;
        }

        addPort(pcmsplitterPort);
        if (mIsHost == OMX_TRUE) {
            pcmsplitterPort->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);
        } else {
            pcmsplitterPort->setSupportedProprietaryComm(AFM_MPC_PROPRIETARY_COMMUNICATION);;
        }
    }

    setDefaultSettings();

    return OMX_ErrorNone;
}

void PcmSplitter::setDefaultSettings()
{
    int portIndex;

    for (portIndex=0;portIndex< (int) getPortCount();portIndex++)
    {
        // Mute configuration
        mConfigMute[portIndex].nSize = sizeof(OMX_AUDIO_CONFIG_MUTETYPE);
        getOmxIlSpecVersion(&mConfigMute[portIndex].nVersion);
        mConfigMute[portIndex].nPortIndex = portIndex;
        mConfigMute[portIndex].bMute = OMX_FALSE;

        // Balance Configuration
        mConfigBalance[portIndex].nSize = sizeof(OMX_AUDIO_CONFIG_BALANCETYPE);
        getOmxIlSpecVersion(&mConfigBalance[portIndex].nVersion);
        mConfigBalance[portIndex].nPortIndex = portIndex;
        mConfigBalance[portIndex].nBalance = VOLCTRL_BALANCE_CENTER;


        // Volume Configuration
        mConfigVolume[portIndex].nSize = sizeof(OMX_AUDIO_CONFIG_VOLUMETYPE);
        getOmxIlSpecVersion(&mConfigVolume[portIndex].nVersion);
        mConfigVolume[portIndex].nPortIndex = portIndex;
        mConfigVolume[portIndex].bLinear  = OMX_FALSE;
        mConfigVolume[portIndex].sVolume.nValue = VOLCTRL_VOLUME_MAX;
        mConfigVolume[portIndex].sVolume.nMin   = VOLCTRL_VOLUME_MIN;
        mConfigVolume[portIndex].sVolume.nMax   = VOLCTRL_VOLUME_MAX;

        // VolumeRamp Configuration
        mConfigVolumeRamp[portIndex].nSize = sizeof(OMX_SYMBIAN_AUDIO_CONFIG_VOLUMERAMPTYPE);
        getOmxIlSpecVersion(&mConfigVolumeRamp[portIndex].nVersion);
        mConfigVolumeRamp[portIndex].nPortIndex             = portIndex;
        mConfigVolumeRamp[portIndex].nChannel               = 2; //Default is stereo
        mConfigVolumeRamp[portIndex].bLinear                = OMX_FALSE;
        mConfigVolumeRamp[portIndex].sStartVolume.nValue    = VOLCTRL_VOLUME_MAX;
        mConfigVolumeRamp[portIndex].sStartVolume.nMin      = VOLCTRL_VOLUME_MIN;
        mConfigVolumeRamp[portIndex].sStartVolume.nMax      = VOLCTRL_VOLUME_MAX;
        mConfigVolumeRamp[portIndex].sEndVolume.nValue      = VOLCTRL_VOLUME_MAX;
        mConfigVolumeRamp[portIndex].sEndVolume.nMin        = VOLCTRL_VOLUME_MIN;
        mConfigVolumeRamp[portIndex].sEndVolume.nMax        = VOLCTRL_VOLUME_MAX;
        mConfigVolumeRamp[portIndex].nRampDuration          = 0;
        mConfigVolumeRamp[portIndex].nRampMinDuration       = 1000;
        mConfigVolumeRamp[portIndex].nRampMaxDuration       = 1000000;
        mConfigVolumeRamp[portIndex].bRampTerminate         = OMX_FALSE;
        mConfigVolumeRamp[portIndex].sCurrentVolume.nValue  = VOLCTRL_VOLUME_MAX;
        mConfigVolumeRamp[portIndex].sCurrentVolume.nMin    = VOLCTRL_VOLUME_MIN;
        mConfigVolumeRamp[portIndex].sCurrentVolume.nMax    = VOLCTRL_VOLUME_MAX;
        mConfigVolumeRamp[portIndex].nRampCurrentTime       = 0;

    }
}

PcmSplitter::~PcmSplitter(void) {
}

bool 
PcmSplitter::lowLatencySrc(OMX_U32 sampleRateIn, OMX_U32 sampleRateOut) const{
    
        if ((sampleRateIn == 8000 || sampleRateIn == 16000 || sampleRateIn == 48000)
                && (sampleRateOut == 8000 || sampleRateOut == 16000 || sampleRateOut == 48000)) {
            return true;
        }
        return false;
    }

OMX_ERRORTYPE PcmSplitter::getParameter(
        OMX_INDEXTYPE nParamIndex,
        OMX_PTR pComponentParameterStructure) const
{
    switch (nParamIndex) {
        case AFM_IndexParamPcmLayout:
            {
                AFM_PARAM_PCMLAYOUTTYPE *pcmlayout = 
                    (AFM_PARAM_PCMLAYOUTTYPE *) pComponentParameterStructure;
                OMX_AUDIO_PARAM_PCMMODETYPE &pcmSettingsIn =  
                    ((AFM_PcmPort *) getPort(0))->getPcmSettings();
                OMX_AUDIO_PARAM_PCMMODETYPE &pcmSettingsOut =  
                    ((AFM_PcmPort *) getPort(pcmlayout->nPortIndex))->getPcmSettings();

                int granularityInMs;
                granularityInMs = (mIsHost == OMX_TRUE) ? 20 : MS_GRANULARITY;

                if (pcmlayout->nPortIndex == 0) { // Case input port
                    pcmlayout->nBlockSize     = granularityInMs * (pcmSettingsIn.nSamplingRate/1000);
                    pcmlayout->nChannels      = pcmSettingsIn.nChannels;
                    pcmlayout->nMaxChannels   = 2;
                    if (mIsHost == OMX_TRUE) {
                        pcmlayout->nBitsPerSample = pcmSettingsIn.nBitPerSample;
                    } else {
                        pcmlayout->nBitsPerSample = 24;
                    }
                    pcmlayout->nNbBuffers     = 1;
                } 
                else { // Case output port

                    if (lowLatencySrc(pcmSettingsIn.nSamplingRate, pcmSettingsOut.nSamplingRate)) {
                        // In low latency mode, input and output blocksize must correspond to the time granularity
                        // Hence input and output block sizes differ if input and output sampling frequencies differ
                        pcmlayout->nBlockSize     = granularityInMs * (pcmSettingsOut.nSamplingRate/1000);
                    } else {
                        // If we are not in low latency mode, block sizes are equivalent for input and outputs (fixin/fixout)
                        pcmlayout->nBlockSize     = granularityInMs * (pcmSettingsIn.nSamplingRate/1000);
                    }

                    pcmlayout->nChannels      = pcmSettingsOut.nChannels;
                    pcmlayout->nMaxChannels   = 2;
                    if (mIsHost == OMX_TRUE) {
                        pcmlayout->nBitsPerSample = pcmSettingsIn.nBitPerSample;
                    } else {
                        pcmlayout->nBitsPerSample = 24;
                    }
                    pcmlayout->nNbBuffers     = 1;
                }

                return OMX_ErrorNone;
            }

        default:
            return AFM_Component::getParameter(
                    nParamIndex, pComponentParameterStructure);
    }
}


OMX_ERRORTYPE PcmSplitter::setConfig(
        OMX_INDEXTYPE nConfigIndex,
        OMX_PTR pComponentConfigStructure)
{
    switch (nConfigIndex) {

        case OMX_IndexConfigAudioChannelSwitchBoard:
            {
                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_SYMBIAN_AUDIO_CONFIG_CHANNELSWITCHBOARDTYPE);
                OMX_SYMBIAN_AUDIO_CONFIG_CHANNELSWITCHBOARDTYPE * pConfig =
                    (OMX_SYMBIAN_AUDIO_CONFIG_CHANNELSWITCHBOARDTYPE *) pComponentConfigStructure;

                if ( pConfig->nPortIndex == 0 || pConfig->nPortIndex > getPortCount() ) {
                    return OMX_ErrorBadPortIndex;
                }

                PcmSplitter_PcmPort * port = static_cast<PcmSplitter_PcmPort *>(getPort(pConfig->nPortIndex));

                return port->setChannelSwitchBoard(pConfig->nOutputChannel);
            }

        case OMX_IndexConfigAudioPortpause:
            {
                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_SYMBIAN_AUDIO_CONFIG_PORTPAUSETYPE);
                OMX_SYMBIAN_AUDIO_CONFIG_PORTPAUSETYPE* pConfig =
                    (OMX_SYMBIAN_AUDIO_CONFIG_PORTPAUSETYPE*) pComponentConfigStructure;

                if ( pConfig->nPortIndex == 0 || pConfig->nPortIndex > getPortCount() ) {
                    return OMX_ErrorBadPortIndex;
                }

                ((PcmSplitter_PcmPort *)getPort(pConfig->nPortIndex-1))->setPause(pConfig->bIsPaused);

                return OMX_ErrorNone;
            }

        case OMX_IndexConfigAudioVolume:
            {
                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_AUDIO_CONFIG_VOLUMETYPE);
                OMX_AUDIO_CONFIG_VOLUMETYPE * pVolume =
                    (OMX_AUDIO_CONFIG_VOLUMETYPE *) pComponentConfigStructure;

                if (pVolume->nPortIndex > getPortCount()) {
                    return OMX_ErrorBadPortIndex;
                }

                if (pVolume->bLinear != OMX_FALSE) {
                    return OMX_ErrorBadParameter;
                }

                if (pVolume->sVolume.nValue < pVolume->sVolume.nMin ||
                        pVolume->sVolume.nValue > pVolume->sVolume.nMax) {
                    return OMX_ErrorBadParameter;
                }

                mConfigVolume[pVolume->nPortIndex] = *pVolume;

                return OMX_ErrorNone;
            }

        case OMX_IndexConfigAudioMute:
            {
                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_AUDIO_CONFIG_MUTETYPE);
                OMX_AUDIO_CONFIG_MUTETYPE * pMute =
                    (OMX_AUDIO_CONFIG_MUTETYPE *) pComponentConfigStructure;

                if (pMute->nPortIndex > getPortCount()) {
                    return OMX_ErrorBadPortIndex;
                }

                mConfigMute[pMute->nPortIndex] = *pMute;

                return OMX_ErrorNone;
            }

        case OMX_IndexConfigAudioBalance:
            {
                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_AUDIO_CONFIG_BALANCETYPE);
                OMX_AUDIO_CONFIG_BALANCETYPE * pBalance =
                    (OMX_AUDIO_CONFIG_BALANCETYPE *) pComponentConfigStructure;

                if (pBalance->nPortIndex > getPortCount()) {
                    return OMX_ErrorBadPortIndex;
                }

                if (pBalance->nBalance < VOLCTRL_BALANCE_ALLLEFT || pBalance->nBalance > VOLCTRL_BALANCE_ALLRIGHT) {
                    return OMX_ErrorBadParameter;
                }


                mConfigBalance[pBalance->nPortIndex] = *pBalance;
                return OMX_ErrorNone;
            }
        case OMX_IndexConfigAudioVolumeRamp:
            {
                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_SYMBIAN_AUDIO_CONFIG_VOLUMERAMPTYPE);

                OMX_SYMBIAN_AUDIO_CONFIG_VOLUMERAMPTYPE *pRampVolume =
                    (OMX_SYMBIAN_AUDIO_CONFIG_VOLUMERAMPTYPE*)pComponentConfigStructure;

                if (pRampVolume->nPortIndex > getPortCount()) {
                    return OMX_ErrorBadPortIndex;
                }


                if (pRampVolume->sStartVolume.nValue> pRampVolume->sStartVolume.nMax){
                    return OMX_ErrorBadParameter;
                }
                if (pRampVolume->sStartVolume.nValue< pRampVolume->sStartVolume.nMin){
                    return OMX_ErrorBadParameter;
                }

                if (pRampVolume->sEndVolume.nValue> pRampVolume->sEndVolume.nMax){
                    return OMX_ErrorBadParameter;
                }
                if (pRampVolume->sEndVolume.nValue< pRampVolume->sEndVolume.nMin){
                    return OMX_ErrorBadParameter;
                }

                if (pRampVolume->nRampDuration> pRampVolume->nRampMaxDuration){
                    return OMX_ErrorBadParameter;
                }
                if (pRampVolume->nRampDuration< pRampVolume->nRampMinDuration){
                    return OMX_ErrorBadParameter;
                }


                mConfigVolumeRamp[pRampVolume->nPortIndex].nChannel = pRampVolume->nChannel;
                mConfigVolumeRamp[pRampVolume->nPortIndex].bLinear  = pRampVolume->bLinear;
                mConfigVolumeRamp[pRampVolume->nPortIndex].sStartVolume.nValue = pRampVolume->sStartVolume.nValue;
                mConfigVolumeRamp[pRampVolume->nPortIndex].sEndVolume.nValue   = pRampVolume->sEndVolume.nValue;
                mConfigVolumeRamp[pRampVolume->nPortIndex].nRampDuration       = pRampVolume->nRampDuration;
                mConfigVolumeRamp[pRampVolume->nPortIndex].bRampTerminate      = pRampVolume->bRampTerminate;

                return OMX_ErrorUnsupportedIndex;
            }

        default:
            return AFM_Component::setConfig(
                    nConfigIndex, pComponentConfigStructure);
    }
}


OMX_ERRORTYPE PcmSplitter::getConfig(
        OMX_INDEXTYPE nConfigIndex,
        OMX_PTR pComponentConfigStructure) const
{
    switch (nConfigIndex) {

        case OMX_IndexConfigAudioChannelSwitchBoard:
            {
                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_SYMBIAN_AUDIO_CONFIG_CHANNELSWITCHBOARDTYPE);
                OMX_SYMBIAN_AUDIO_CONFIG_CHANNELSWITCHBOARDTYPE * pConfig =
                    (OMX_SYMBIAN_AUDIO_CONFIG_CHANNELSWITCHBOARDTYPE *) pComponentConfigStructure;

                if ( pConfig->nPortIndex == 0 || pConfig->nPortIndex > getPortCount() ) {
                    return OMX_ErrorBadPortIndex;
                }

                const PcmSplitter_PcmPort * port = static_cast<const PcmSplitter_PcmPort *>(getPort(pConfig->nPortIndex));

                port->getChannelSwitchBoard(pConfig->nOutputChannel);

                return OMX_ErrorNone;
            }

        case OMX_IndexConfigAudioPortpause:
            {
                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_SYMBIAN_AUDIO_CONFIG_PORTPAUSETYPE);
                OMX_SYMBIAN_AUDIO_CONFIG_PORTPAUSETYPE* pConfig =
                    (OMX_SYMBIAN_AUDIO_CONFIG_PORTPAUSETYPE*) pComponentConfigStructure;

                if ( pConfig->nPortIndex == 0 || pConfig->nPortIndex > getPortCount() ) {
                    return OMX_ErrorBadPortIndex;
                }

                pConfig->bIsPaused = ((PcmSplitter_PcmPort *)getPort(pConfig->nPortIndex))->isPaused();

                return OMX_ErrorNone;
            }

        case OMX_IndexConfigAudioVolume:
            {
                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_AUDIO_CONFIG_VOLUMETYPE);
                OMX_AUDIO_CONFIG_VOLUMETYPE * pVolume =
                    (OMX_AUDIO_CONFIG_VOLUMETYPE *) pComponentConfigStructure;

                if (pVolume->nPortIndex > getPortCount()) {
                    return OMX_ErrorBadPortIndex;
                }

                *pVolume = mConfigVolume[pVolume->nPortIndex];

                return OMX_ErrorNone;
            }

        case OMX_IndexConfigAudioMute:
            {
                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_AUDIO_CONFIG_MUTETYPE);
                OMX_AUDIO_CONFIG_MUTETYPE * pMute =
                    (OMX_AUDIO_CONFIG_MUTETYPE *) pComponentConfigStructure;

                if (pMute->nPortIndex > getPortCount()) {
                    return OMX_ErrorBadPortIndex;
                }

                *pMute = mConfigMute[pMute->nPortIndex];

                return OMX_ErrorNone;
            }

        case OMX_IndexConfigAudioBalance:
            {
                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_AUDIO_CONFIG_BALANCETYPE);
                OMX_AUDIO_CONFIG_BALANCETYPE * pBalance =
                    (OMX_AUDIO_CONFIG_BALANCETYPE *) pComponentConfigStructure;

                if (pBalance->nPortIndex > getPortCount()) {
                    return OMX_ErrorBadPortIndex;
                }

                *pBalance = mConfigBalance[pBalance->nPortIndex];

                return OMX_ErrorNone;
            }

        case OMX_IndexConfigAudioVolumeRamp:
            {

                CHECK_STRUCT_SIZE_AND_VERSION(pComponentConfigStructure,OMX_SYMBIAN_AUDIO_CONFIG_VOLUMERAMPTYPE);

                OMX_SYMBIAN_AUDIO_CONFIG_VOLUMERAMPTYPE *pRampVolume =
                    (OMX_SYMBIAN_AUDIO_CONFIG_VOLUMERAMPTYPE*)pComponentConfigStructure;

                if (pRampVolume->nPortIndex > getPortCount()) {
                    return OMX_ErrorBadPortIndex;
                }

                return OMX_ErrorUnsupportedIndex;
            }
        default:
            return AFM_Component::getConfig(
                    nConfigIndex, pComponentConfigStructure);
    }
}


OMX_U32 PcmSplitter::getUidTopDictionnary(void)
{
    if (mIsHost == OMX_TRUE) {
        return KOstPCM_SPLITTER_host_top_ID;
    } else {
        return KOstPCM_SPLITTER_top_ID;
    }
}


OMX_ERRORTYPE PcmSplitter::getExtensionIndex(OMX_STRING extension, OMX_INDEXTYPE* index) const 
{
    if (ENS_String<ENS_COMPONENT_NAME_MAX_LENGTH>(extension) == OMX_SYMBIAN_INDEX_CONFIG_AUDIO_VOLUMERAMP_NAME)
    {
        *index = (OMX_INDEXTYPE)OMX_IndexConfigAudioVolumeRamp; 
        return OMX_ErrorNone;
    }

    if (ENS_String<ENS_COMPONENT_NAME_MAX_LENGTH>(extension) == OMX_SYMBIAN_INDEX_CONFIG_AUDIO_PORTPAUSE_NAME)
    {
        *index = (OMX_INDEXTYPE)OMX_IndexConfigAudioPortpause; 
        return OMX_ErrorNone;
    }



    return AFM_Component::getExtensionIndex(extension,index);

}
