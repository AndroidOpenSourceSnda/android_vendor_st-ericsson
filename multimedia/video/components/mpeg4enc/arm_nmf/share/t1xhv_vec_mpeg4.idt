/*
 * Copyright (C) ST-Ericsson SA 2010. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 *
 * \brief   Common data structure and/or definition for MPEG4 encoder algorithm
 * \author  ST-Ericsson
 */

/** @addtogroup vecMpeg4Group MPEG4 Encoder NMF Component
 *  \brief This part shows a MPEG4 Encoder NMF Component description (in term
 *  of configuration and interfaces)
 *  @{
 *   
 * \image html algo-overview.jpg
 *  with <algo_name> = mpeg4_encoder \n
 *  and  <algo> = Mpeg4Encoder
 *   
 *
 * \section data_flow_sec Mpeg4 encoder dataflow description
 * \n
 * \n
 * \image html mpeg4_encoder_global_dataflow.jpg
 * \n
 * \section memory_desc_sec Memory needs description
 * \n
 * \n The following diagram shows the different needed buffers, their respective location and the way their
 * address is given as parameter to the algo component.
 * \image html mpeg4_encoder_dataflow.jpg
 */ 

/** @addtogroup vecMpeg4ConfigurationGroup NMF Configuration file
 *  \brief Source code of the configuration file of the component \ref vecMpeg4Group 
 *  @{
 *  \include mpeg4_encoder_algo.conf
 */ 
/** @} */ // end of vecMpeg4ConfigurationGroup


/** @addtogroup vecMpeg4ProvidedInterfaceGroup Provided interface(s)
 *  \brief Description of all provided interfaces of NMF component \ref vecMpeg4Group 
 *  @{
 */ 

/** @} */ // end of vecMpeg4ProvidedInterfaceGroup

/** @addtogroup vecMpeg4RequiredInterfaceGroup Required interface(s)
 *  \brief Description of all required interfaces of NMF component \ref vecMpeg4Group  
 *  @{
 */ 

/** @} */ // end of vecMpeg4RequiredInterfaceGroup

#ifndef	_t1xhv_vec_mpeg4_idt
#define _t1xhv_vec_mpeg4_idt

#include <t1xhv_vec.idt>
#include <t1xhv_common.idt>
#include <t1xhv_retarget.idt>


/** \brief This structure defines a MPEG4 Encode input parameter buffers. */
typedef struct {
    t_ushort_value picture_coding_type;       /**<\brief Picture type (i.e. type of the picture to be encoded for an MPEG4 or an H263 or an
                                                    H264 encode subtask. The type can be intra-coded (also called I-frame or Intra frame) or predictive-
                                                    coded (also called P-frame or Inter frame). The previous reconstructed frame, contained in the forward 
                                                    reference buffer, is used for motion estimation while encoding either Iframes or P-frames).
                                                    \n 0: Intra-coded
                                                    \n 1: Predictive-coded */
    t_ushort_value flag_short_header;         /**<\brief Short header flag (i.e. encoding mode for an MPEG4 encode subtask. It corresponds to the value of the
                                                    short_video_header field of the Video Object Layer in MPEG4 bitstreams. 
                                                    MPEG4 Short Header is equivalent to H263 Baseline).
                                                    \n 0: “normal” MPEG4 format (Simple Profile)
                                                    \n 1: “short header” MPEG4 format (equivalent to H263 Baseline) */
    t_ushort_value frame_width;               /**<\brief Source frame width (i.e. width of the source frame of the encode task. It is equal to the number
                                                    of luminance pixels contained in the horizontal dimension of the frame).
                                                    \n Contraints : [16,640] and Multiple of 16 */
    t_ushort_value frame_height;              /**<\brief Source frame height (i.e. height of the source frame of the encode task. It is equal to the
                                                    number of luminance pixels contained in the vertical dimension of the frame)
                                                    \n Contraints : [16,480] and Multiple of 16 */
    t_ushort_value window_width;              /**<\brief Source window width (i.e. width of the source window of the encode task. It is equal to the
                                                    number of luminance pixels contained in the horizontal dimension of the window).
                                                    \n Contraints : [16,frame_width] and Multiple of 16 */
    t_ushort_value window_height;             /**<\brief Source window height (i.e. height of the source window of the encode task. It is equal to the
                                                    number of luminance pixels contained in the vertical dimension of the window).
                                                    \n Contraints : [16,frame_height] and Multiple of 16 */
    t_ushort_value window_horizontal_offset;  /**<\brief Source window horizontal offset (i.e. horizontal offset of the source window of the encode task 
                                                    within the source frame. It is pixel-accurate).
                                                    \n Contraints : [0,frame_width[, window_horizontal_offset+window_width<frame_width and Multiple of 8 */
    t_ushort_value window_vertical_offset;    /**<\brief Source window vertical offset (i.e. vertical offset of the source window of the encode task within the
                                                    source frame. It is pixel-accurate).
                                                    \n Contraints : [0,frame_height[, window_horizontal_offset+window_height<frame_height and Multiple of 8 */
    t_ushort_value gob_header_freq;           /**<\brief GOB header frequency (i.e. enables the use of GOB headers and specifies their frequency. It is used 
                                                    only when flag_short_header=1).
                                                    \n 0: GOB headers disabled
                                                    \n x: GOB headers enabled and inserted every x macroblock
                                                    \n Contraints : [0,window_height/16] and Multiple of xx */
    t_ushort_value gob_frame_id;              /**<\brief GOB frame ID (i.e. specifies the gob_frame_id field of GOB headers. It is used only when gob_header_freq!=0 
                                                    and flag_short_header=1)*/
    t_ushort_value data_partitioned;          /**<\brief Data partitioning flag (i.e. enables data partitioning. It is used only when
                                                    flag_short_header=0).
                                                    \n 0: no data partitioning
                                                    \n 1: data partitioning (macroblock motion vector data are separated from texture data)
                                                    \n Contraints : 0 for frame bigger than CIF format. */
    t_ushort_value reversible_vlc;            /**<\brief Reversible VLC flag (i.e. enables the use of reversible codes. It is used
                                                    only when flag_short_header=0 and data_partitioned=1)
                                                    \n 0: standard VLC tables
                                                    \n 1: reversible VLC tables */
    t_ushort_value hec_freq;                  /**<\brief Header Extension Code frequency (i.e. enables the use of Header Extension Codes and associated 
                                                    information. It is used only when flag_short_header=0 and data_partitioned=1. When hec_freq=0, no HEC 
                                                    information is inserted. Otherwise, HEC information is inserted in video packet headers once every 
                                                    hec_freq video packets).
                                                    \n 0: HEC information disabled
                                                    \n x: HEC information inserted once every HFR video packets
                                                    \n Contraints : [0, window_width*window_height/256[ */
    t_ushort_value modulo_time_base;          /**<\brief Modulo Time Base (for HECs) (i.e. specifies the modulo_time_base field to be 
                                                    written in HEC information. It is used only when flag_short_header=0 and data_partitioned=1
                                                    and hec_freq!=0. It is given in seconds).*/
    t_ushort_value vop_time_increment;        /**<\brief VOP time increment (i.e. specifies the vop_time_increment field to be written in HEC information. 
                                                    It is used only when flag_short_header=0 and data_partitioned=1 and hec_freq!=0.)*/
    t_ushort_value vp_size_type;              /**<\brief Video packet size control (i.e. defines the control of the video packet size. It is used only when
                                                    flag_short_header=0 and data_partitioned=1. It enables the use of vp_bit_size and vp_mb_size parameters. 
                                                    A video packet is closed as soon as it reaches the corresponding limit or the vp_size_max limit. 
                                                    Note that the last macroblock of the video packet will be replaced by a “not coded” macroblock if the 
                                                    vp_size_max limit is reached).
                                                    \n 0: a video packet is closed as soon as the vp_bit_size limit or the vp_size_max limit is reached
                                                    \n 1: a video packet is closed as soon as the vp_mb_size limit or the vp_size_max limit is reached
                                                    \n 2 or 3: a video packet is closed as soon as either the vp_bit_size limit or the vp_mb_size limit 
                                                    or the vp_size_max limit is reached
                                                    \n Contraints : [0,3] */
    t_ushort_value vp_size_max;               /**<\brief Maximum video packet size (i.e. defines the maximum video packet size, in bits. It is used only when
                                                    flag_short_header=0 and data_partitioned=1. If the vp_size_max limit is reached, the last macroblock is 
                                                    replaced by a “not coded” macroblock and the video packet is closed, in order to respect the limit).
                                                    \n Contraints : 
                                                    \n   - [0,2048] for Simple Profile Level 0
                                                    \n   - [0,2048] for Simple Profile Level 1
                                                    \n   - [0,4096] for Simple Profile Level 2
                                                    \n   - [0,8192] for Simple Profile Level 3*/
    t_ushort_value vp_bit_size;               /**<\brief Video packet bit size (i.e. defines the minimum video packet size in bits. It is used only when
                                                    flag_short_header=0 and data_partitioned=1 and vp_size_type=0/2/3. A video packet is closed as soon 
                                                    as it reaches the corresponding limit or the vp_size_max limit. Note that the last macroblock of the 
                                                    video packet will be replaced by a “not coded” macroblock if the vp_size_max limit is reached).
                                                    \n 0:
                                                    \n 1:
                                                    \n Contraints : [0,vp_size_max] Some margin with respect to VSM should be used in order to avoid 
                                                    discarding the last macroblock of video packets, e.g. [0,vp_size_max/2) */
    t_ushort_value vp_mb_size;                /**<\brief Video packet macroblock size (i.e. defines the minimum video packet size in macroblocks. It is 
                                                    used only when flag_short_header=0 and data_partitioned=1 and vp_size_type=1/2/3. A video packet 
                                                    is closed as soon as it reaches the corresponding limit or the vp_size_max limit. Note that the last 
                                                    macroblock of the video packet will be replaced by a “not coded” macroblock if the vp_size_max limit is reached).
                                                    \n Contraints : [0,window_width*window_height/256]. Sufficiently small values should be used in order to 
                                                    avoid discarding the last macroblock of video packets, e.g. window_width/16 */
    t_ushort_value init_me;                   /**<\brief Motion estimation initialization (i.e. allows to initialize the motion estimation data - null motion vectors 
                                                    are used)  (e.g. after a scene change detection).
                                                    \n 0: continue motion estimation using previous encode data
                                                    \n 1: initialize motion estimation data */
    t_ushort_value me_type;                   /**<\brief Motion estimation type (i.e. defines the motion estimation algorithm. It can be used to improve quality at 
                                                    low resolution/frame rate, or improve performance at high resolution/frame rate).
                                                    \n 0 or 3: normal Slimpeg
                                                    \n 1: Slimpeg optimized for low resolution/frame rate (improved quality)
                                                    \n 2: Slimpeg optimized for high resolution/frame rate (improved performance)
                                                    \n Contraints : [xx,yyyy] and Multiple of xx */
    t_ushort_value vop_fcode_forward;         /**<\brief VOP FCode forward (i.e. defines the motion vector range (it corresponds to the vop_fcode_forward field of the
                                                    Video Object Plane in MPEG4 bitstreams). It also enables the use of the search window, to optimize data access
                                                    during motion estimation, if the search window buffer is large enough (otherwise, predictors are accessed directly
                                                    in the forward reference frame). It is used only when flag_short_header=0.
                                                    \n 1: [-16pel, +15.5pel] motion vector range
                                                    \n 2: [-32pel, +31.5pel] motion vector range
                                                    \n 3: [-64pel, +63.5pel] motion vector range
                                                    \n 4: [-128pel, +127.5pel] motion vector range
                                                    \n 5: [-256pel, +255.5pel] motion vector range
                                                    \n 6: [-512pel, +511.5pel] motion vector range
                                                    \n 7: [-1024pel, +1023.5pel] motion vector range
                                                    \n Contraints : [1,7] */
    t_ushort_value rounding_type;             /**<\brief Rounding type (i.e. defines the value of the rounding control parameter used for pixel value interpolation
                                                    in motion compensation for P-frames. It is not used if picture_coding_type=0).
                                                    \n Contraints : [0,1] */
    t_ushort_value intra_refresh_type;        /**<\brief Intra refresh type (i.e. enables the Adaptive Intra Refresh (AIR) and/or Cyclic Intra Refresh (CIR) algorithms).
                                                    \n 0: AIR and CIR disabled
                                                    \n 1: AIR enabled, CIR disabled
                                                    \n 2: AIR disabled, CIR enabled
                                                    \n 3: AIR and CIR enabled
                                                    \n Contraints : [0,3] */
    t_ushort_value air_mb_num;                /**<\brief Adaptive Intra Refresh macroblock number (i.e. defines the number of macroblocks per frame to be refreshed in 
                                                    the AIR algorithm. It is used only if intra_refresh_type=1 or 3).*/
    t_ushort_value cir_period_max;            /**<\brief Maximum Cyclic Intra Refresh period (i.e. defines the maximum macroblock refresh period in the CIR algorithm.
                                                    It is used only if intra_refresh_type=2 or 3).*/
    t_ushort_value quant;                     /**<\brief Quantizer (i.e. defines the quantization parameter. It is used only if brc_type=0/4/5/6/7).
                                                    \n Contraints : [2,31] */
    t_ushort_value brc_type;                  /**<\brief Bit Rate Control type (i.e. defines the bit rate control (BRC) algorithm. One of the following modes can be used:
                                                    \n - constant Quantization Parameter (QP)
                                                    \n - frame-based control, where the host computes the target size for each frame
                                                    \n - Constant Bit Rate control (CBR), with low-delay constraint for video-conferencing, or “See-What-I-See” (SWIS)
                                                    applications
                                                    \n - Variable Bit Rate control (VBR), for Multimedia Messaging (MMS) or Local Video Recording applications.
                                                    \n Several buffering models can be used, depending on the standard and the BRC algorithm: Video Buffer Verifier
                                                    (VBV) (typical of MPEG4 standard), Hypothetic Reference Decoder (HRD) (typical of H263 standard), 3GPP PSS Annex G
                                                    (for H263)).
                                                    \n 0: constant QP without buffering model
                                                    \n 1: frame-based control (no buffering model)
                                                    \n 2: CBR (with custom VBV for MPEG4 with flag_short_header=0, with HRD for H263 or MPEG4 with flag_short_header=1)
                                                    \n 3: VBR (with VBV for MPEG4 with flag_short_header=0, with Annex G for H263 or MPEG4 with flag_short_header=1)
                                                    \n 4 or 5: constant QP with VBV for MPEG4 with flag_short_header=0, with Annex G for H263 or MPEG4 with 
                                                    flag_short_header=1
                                                    \n 6 or 7: constant QP with VBV for MPEG4 with flag_short_header=0, with HRD for H263 or MPEG4 with
                                                    flag_short_header=1
                                                    \n Contraints : [0,7]*/
    t_ulong_value  brc_frame_target;          /**<\brief Frame size target (i.e. defines the target number of bits for the frame to be encoded. It is used only if
                                                    brc_type=1).*/
    t_ulong_value  brc_target_min_pred;       /**<\brief BRC predicted minimum target (i.e. defines the predicted minimum number of bits to avoid buffer underflow 
                                                    (on the encoder side). It is used only if brc_type=2/3/4/5/6/7).*/
    t_ulong_value  brc_target_max_pred;       /**<\brief BRC predicted maximum target (i.e. defines the predicted maximum number of bits to avoid buffer overflow 
                                                    (on the encoder side). It is used only if brc_type=2/3/4/5/6/7).*/
    t_ulong_value  skip_count;                /**<\brief Frame skip count (i.e. defines the number of frames that have been skipped consecutively right before the
                                                    current frame to be encoded. It is used to stretch motion vectors during motion estimation).*/
    t_ulong_value  bit_rate;                  /**<\brief Bitstream Bit Rate (i.e. defines the bit rate of the bitstream to be encoded. It's used for CBR and VBR).*/
    t_ushort_value framerate;                 /**<\brief Bitstream Frame Rate (i.e. defines the frame rate of the bitstream to be encoded. It's used for CBR and VBR).*/
    t_short_value  ts_modulo;                 /**<\brief Current timestamp (modulo) (i.e. current timestamp (modulo) parameter. It's used for CBR and VBR). */
    t_ushort_value ts_seconds;                /**<\brief Current timestamp (seconds) (i.e. current timestamp (seconds) parameter. It's used for CBR and VBR). */
    t_ushort_value air_thr;                   /**<\brief threshold for AIR (i.e. defines current timestamp (seconds) parameter. it's used for CBR and VBR). */
    t_ulong_value  delta_target;              /**<\brief Bitstream Delta Target (i.e. defines distance to target rate. It's used for CBR and VBR. This parameter is
                                                    signed).*/
    t_ushort_value minQp;                     /**<\brief Picture minimum Qp (i.e. defines picture minimum allowed quantization parameter. It's used for CBR and VBR).*/

    t_ushort_value maxQp;                     /**<\brief Picture maximum Qp (i.e. defines picture maximum allowed quantization parameter. It's used for CBR and VBR).*/
    t_ushort_value vop_time_increment_resolution; /**<\brief VOP time increment resolution (i.e. VOP time increment resolution. It's used for CBR, VBR and HEC
                                                    insertion).*/
    t_ushort_value fixed_vop_time_increment;  /**<\brief Fixed VOP time increment (i.e. defines fixed VOP time increment. It's used for CBR and VBR).*/
    t_ulong_value  Smax;                      /**<\brief Texture max size (i.e. defines texture max size. It's used for CBR and VBR).*/
    t_ushort_value min_base_quality;          /**<\brief Minimum base quality (i.e. defines minimum base quality parameter. It's used for VBR).*/
    t_ushort_value min_framerate;             /**<\brief Minimum frame rate (i.e. defines minimum frame rate. It's used for VBR).*/
    t_ulong_value  max_buff_level;            /**<\brief Maximum buffer level (i.e. defines maximum buffer level. It's used for CBR).*/
    t_ushort_value first_I_skipped_flag;      /**<\brief TBD !!! (i.e. TBD !!!)*/
    t_short_value init_ts_modulo_old;         /**<\brief Previous modulo timestamp (i.e. defines previous timestamp (modulo). It's used for CBR and VBR).*/
    t_ushort_value slice_loss_first_mb[8];    /**<\brief Slice loss first macroblock (i.e. defines the positions of the first macroblock of “slices” that have 
                                                    been concealed by the receiver and that need to be refreshed).*/
    t_ushort_value slice_loss_mb_num[8];      /**<\brief Slice loss macroblock number (i.e. defines the number of macroblocks of “slices” that have been concealed 
                                                    by the receiver and that need to be refreshed. It is equal to 0 when no slice refresh is needed).*/
    t_ulong_value yuvformat;				  /* 0-planar, 1-semiplanar */

	//for H263_P3 
	t_ushort_value adv_intra_coding;
	t_ushort_value mod_quant_mode;
	t_ushort_value slice_mode;
	t_ushort_value deblock_filter;
	t_ushort_value h263_p3;

	//t_ushort_value reserved[2]; //removed after introduction of yuvformat to fix alignment issue

} ts_t1xhv_vec_mpeg4_param_in;

typedef ts_t1xhv_vec_mpeg4_param_in *tps_t1xhv_vec_mpeg4_param_in;

/** \brief This structure defines a MPEG4 Encode input/output parameter buffers. */
typedef struct {
    t_ulong_value  bitstream_size;            /**<\brief Bitstream size (i.e. as an input, defines the size in bits of the bitstream that has been written 
                                                    by the previous encode, including the header but not the stuffing bits. As an output, it returns the size 
                                                    in bits of the bitstream that has been written by the current encode , including the header but not the 
                                                    stuffing bits. It is valid for all values of brc_type).*/
    t_ulong_value  stuffing_bits;             /**<\brief Number of stuffing bits (i.e. as an input, defines the number of stuffing bits added in the 
                                                    bitstream by the previous encode. As an output, it returns the number of stuffing bits added in the bitstream 
                                                    by the current encode. It is valid only if brc_type=2/3/4/5/6/7).*/
    t_ulong_value  pictCount;                 /**<\brief Picture Count (i.e. defines picture count for MPEG4 encode. It's used for CBR and VBR).*/
    t_ushort_value I_Qp;                      /**<\brief Initial quantization parameter for intra picture (i.e. initial quantization parameter for intra picture for
                                                    MPEG4 encode. it's used for CBR and VBR).*/
    t_ushort_value P_Qp;                      /**<\brief Initial quantization parameter for inter picture (i.e. initial quantization parameter for inter picture for
                                                    MPEG4 encode. It's used for CBR and VBR).*/
    t_ulong_value  last_I_Size;               /**<\brief Last intra picture size (i.e. defines last intra picture size for MPEG4 encode. It's used for CBR and VBR).*/
    t_ulong_value  comp_SUM;                  /**<\brief comp sum (i.e. defines comp sum parameter for MPEG4 encode. It's used for CBR and VBR).*/
    t_ulong_value  comp_count;                /**<\brief comp count (i.e. defines comp count parameter for MPEG4 encode. It's used for CBR and VBR).*/
    t_ulong_value  BUFFER_mod;                /**<\brief Buffer mod (i.e. defines buffer mod parameter for MPEG4 encode. It's used for CBR and VBR).*/
    t_ulong_value  ts_seconds_old;            /**<\brief Previous timestamp (seconds) (i.e. defines old timestamp (seconds) parameter for MPEG4 encode. It's used for
                                                    CBR and VBR).*/
    t_short_value  ts_modulo_old;             /**<\brief Previous timestamp (modulo) (i.e. defines previous timestamp (modulo) for MPEG4 encode. It's used for CBR and
                                                    VBR).*/
    t_ushort_value gov_flag;                  /**<\brief Internal flag used for fake timestamp in custom VBV (i.e. defines internal parameter for MPEG4 encode. It's
                                                    used for CBR with custom VBV).*/
    t_ulong_value  avgSAD;                    /**<\brief Average SAD (i.e. defines average SAD for MPEG4 encode. It's used for VBR).*/
    t_ulong_value  seqSAD;                    /**<\brief Sequential SAD (i.e. defines sequential SAD for MPEG4 encode. It's used for VBR).*/
    t_ushort_value min_pict_quality;          /**<\brief Minimum picture quality (i.e. defines minimum picture quality for MPEG4 encode. It's used for VBR).*/
    t_ushort_value diff_min_quality;          /**<\brief Difference minimum quality (i.e. defines difference minimum quality for MPEG4 encode. It's used for VBR.
                                                    This parameter is signed).*/
    t_ulong_value  TotSkip;                   /**<\brief Total skip (i.e. defines total skip for MPEG4 encode tasks. It's used for VBR).*/
    t_ulong_value  Skip_Current;              /**<\brief flag indicating that previous picture has been skipped (i.e. defines skip current flag for MPEG4 encode.
                                                    It's used for VBR and CBR).*/
    t_ushort_value Cprev;                     /**<\brief Previous header size (i.e. defines previous header size for MPEG4 encode. It's used for CBR).*/
    t_ushort_value BPPprev;                   /**<\brief Previous bit per pixel (i.e. defines previous bit per pixel parameter for MPEG4 encode. It's used for CBR).*/
    t_ulong_value  PictQpSum;                 /**<\brief Picture quantization parameter sum (i.e. defines picture quantization parameter sum for MPEG4 encode.
                                                    It's used for CBR).*/
    t_ulong_value  S_overhead;                /**<\brief Texture size overhead (i.e. defines texture size overhead for MPEG4 encode. It's used for CBR).*/
    t_long_value   ts_vector[6];              /**<\brief timestamps vector (i.e. defines timestamps vector for MPEG4 encode. It's used for VBR to compute real
                                                    framerate through moving average).*/
    t_long_value   buffer_fullness;           /**<\brief internal BRC variable for VBV/HRD buffer fullness (i.e. defines internal BRC variable for MPEG4 encode).*/
    t_long_value   buffer_fullness_fake_TS;   /**<\brief used for custom VBV in first GOV (i.e. defines internal BRC parameter for MPEG4 encode).*/
    t_ulong_value  BUFFER_depletion;          /**<\brief TBD !!! (i.e. defines TBD !!!)*/
    t_ushort_value buffer_saved;              /**<\brief TBD !!! (i.e. defines )*/
    t_ushort_value intra_Qp_flag;             /**<\brief TBD !!! (i.e. defines TBD !!!)*/
    t_ulong_value  BUFFER_depletion_fake_TS;  /**<\brief TBD !!! (i.e. defines TBD !!!)*/
    t_ushort_value old_P_Qp_vbr;              /**<\brief added for MAINVER2.5c.*/	
	t_ushort_value mv_field_index;  /**<\brief Added for IME to indicate the MV_field index */

    t_ulong_value  pictCount_prev;            /**<\brief TBD !!! (i.e. defines TBD !!!)*/
    t_ulong_value  PictQpSumIntra;             /**<\brief TBD !!! (i.e. defines TBD !!!) / added for segmented mode */


    t_ushort_value hec_count;                 /**<\brief Header Extension Code counter (i.e. as an input, defines the number of video packets to be written 
                                                    before the next HEC insertion. It is used only when flag_short_header=0 and data_partitioned=1 and hec_freq!=0.
                                                    It should be set to the same value as hec_freq at the beginning of the encode, and should be kept equal to the
                                                    output value of the previous encode afterwards. As an output, it returns the number of video packets to be written
                                                    before the next HEC insertion).*/
    t_ushort_value reserved_1;				/**<\brief Reserved to make a long */
    t_long_value reserved_2;				/**<\brief Reserved to make multiple for 4*16 */
    t_long_value reserved_3;				/**<\brief Reserved to make multiple for 4*16 */
    t_long_value reserved_4;				/**<\brief Reserved to make multiple for 4*16 */

	/* GT: enanched MB layer control for better Qp distribution, 02 Apr 07 */
    t_ushort_value BPPmbPrevAct;/**<\brief added for Enhanced MB quant control */
    t_ushort_value BPPmbPrevEst;/**<\brief added for Enhanced MB quant control */
    t_ushort_value CodedMB;/**<\brief added for Enhanced MB quant control */
    t_ushort_value CodedMB_flag;/**<\brief added for Enhanced MB quant control */
    t_long_value Lprev;/**<\brief added for Enhanced MB quant control */
    t_long_value BPPmbErr;/**<\brief added for Enhanced MB quant control */
	

} ts_t1xhv_vec_mpeg4_param_inout;

typedef ts_t1xhv_vec_mpeg4_param_inout *tps_t1xhv_vec_mpeg4_param_inout;

/** \brief This structure defines a MPEG4 Encode output parameter buffers. */
typedef struct {
    t_ushort_value  error_type;               /**<\brief Return bitstream error type (see t_t1xhv_encoder_info for details in \ref vecMpeg4endAlgoGroup) */
    t_ushort_value  vp_num;                   /**<\brief Video packet count (i.e. returns the number of video packets that have been written by an MPEG4
                                                  encode. It is used only when flag_short_header=0. Note that there is no video packet header for the first 
                                                  video packet).*/
    t_ushort_value  vp_pos[32];               /**<\brief Video packet positions (i.e. returns the positions of the first video packets (up to 32) that have 
                                                  been written by an MPEG4 encode. It is used only when flag_short_header=0. The positions are given in bytes,
                                                  relatively to the beginning of the bitstream that has been written, including the header).*/
    t_ushort_value  brc_skip_prev;            /**<\brief BRC previous frame skip (i.e. returns a flag indicating whether the encoded frame needs to be skipped 
                                                  or not (it corresponds to the BRC interrupt). It is used only if brc_type=2/3/4/5/6/7. This flag is not set 
                                                  if the skip decision has been taken before encoding the image (strategic skip)).
                                                    \n 0: no frame skip
                                                    \n 1: the encoded frame needs to be skipped
                                                    \n Contraints : [0,1] */
    t_ushort_value  reserved_1;               /**<\brief reserved  16  */
    t_ulong_value   reserved_2;               /**<\brief reserved  32  */
    t_ulong_value   reserved_3;               /**<\brief reserved  32  */

} ts_t1xhv_vec_mpeg4_param_out;

typedef ts_t1xhv_vec_mpeg4_param_out *tps_t1xhv_vec_mpeg4_param_out;

/** @} */ // end of vecMpeg4Group

/*******************************************************/
/* Global Structure definitions	  					   */
/*******************************************************/
struct Buffer {
  t_uint8 *buf;                    /* pointer to the temporary memory area were bits are stored */
  t_uint32   buffer_bits;            /* number of bits used in the current buffer                 */
  t_uint32   buffer;                 /* 8-bit buffer containing the current word                  */
  t_uint32   buf_length;             /* amount of bits available in the 8-bit buffer              */
  t_uint32   sl_buffer_bits;         /* Slice pre-analisys amount of bits used by current buffer  */
  t_uint32   marker_buffer_bits;     /* index of the amount of bits used by the previous mb       */
  t_uint32   first_vol_hdr_bits;     /* enzo: n. of bits used to write first vol header           */
};

struct BitStreamData 
{
  struct Buffer         bitstream;
  struct Buffer         Header_1;
  struct Buffer         Header_2;
  struct Buffer         Data_block;
  struct Buffer         *s_buffer;
  t_uint32				modality;	 /* WRITE = 0 (writes data on the bitstream); SIMULATE = 1 (writes only # of bits); */
  t_sint32				FrameStuffBits;
};


/*  HAMAC vars structure    */
typedef struct {
  t_uint16  picture_coding_type;  /*  picture coding type: Intra or Inter           */
  t_uint32  vp_bit_size;
  t_uint32  vp_size_max;

  /*  in-out vars       */
  t_uint32  stuffing_bits;

  t_uint32  PictQpSum;          /*  brc_stats_prev_12 */
  t_uint32  S_overhead;         /*  brc_stats_prev_13 */
  //t_uint16  gov_flag;			/*  brc_stats_prev_16 */ /* ADDED BY ENZO */
  t_sint32  buffer_fullness_fake_TS;  

  t_uint32  Tmin_UF;
  t_uint16  MBnum;
  t_uint16  MBcount;
  t_uint32  Smb;
  t_uint16  C;
  t_uint16  C1;
  t_uint16  Cmb;
  t_uint16  avgC;
  t_uint16  BPP;
  t_uint16  BPP1;
  t_uint16  BPPmb;
  t_uint16  avgBPP;
  t_sint32  B;
  t_uint16  Q;
  t_uint16  Qp;
  t_uint16  prevQp;
  t_uint32  HeaderCount;
  t_uint32  count;
  t_uint32  S_coeff;

//#ifdef _CBR_ENHANCED_MB_CONTROL
  /* GT: enanched MB layer control for better Qp distribution, 02 Apr 07 */
  t_uint16 BPPmbPrevAct;
  t_sint32 BPPmbErr;
  t_uint16 BPPmbPrevEst;
  t_sint32 Lprev;
  t_uint16 CodedMB;
  t_uint16 CodedMB_flag;
//#endif

/* segmented mode */
    t_uint16 avgPictQp;
    t_uint16 GOBmbsize;
    t_uint32 maxGOBbitsize;
    t_uint32 GOBQpsum;
    t_sint32 prevGOBcount;
    t_uint32 saved_PictQpSum;
    t_uint32 PictQpSumIntra;
    t_uint16 target_GOB_overflow;
    t_uint16 re_encode_MBskip;
    t_uint16 re_encode_GOB;  
} CBR_HAMAC_par;

/*  HAMAC vars structure    */
typedef struct {
  t_uint16  picture_coding_type;
  t_uint16  ts_modulo;
  t_uint32  ts_seconds;

  t_uint16  vop_time_increment_resolution;  /*  brc_stats_global_6  */
  t_uint32  Smax;							/*  brc_stats_global_8  */

  t_uint16  brc_skip_prev;

  t_uint32  bitstream_size;
  t_uint32  stuffing_bits;

  t_uint32  pictCount;          /*  brc_stats_prev_1  */
  t_uint16  P_Qp;				/*  brc_stats_prev_3  */
  t_uint32  last_I_Size;        /*  brc_stats_prev_4  */
  t_uint32  comp_SUM;			/*  brc_stats_prev_5  */
  t_uint32  comp_count;         /*  brc_stats_prev_6  */
  t_uint32  avgSAD;           /*  brc_stats_prev_10 */
  t_uint32  seqSAD;           /*  brc_stats_prev_11 */
  t_uint32  TotSkip;          /*  brc_stats_prev_14 */
  t_uint32  Skip_Current;

  /*  other HAMAC BRC vars  */
  t_uint32  P_PicTarget;
  t_uint16  MBnum;
  t_uint16  MBcount;
  t_uint32  skip_level;
  t_uint16  min_tot_quality;
  t_sint16  MB_QP_adj;
  t_uint32  TotSAD;
  t_uint16  real_framerate;
  
  t_sint32  ts_vector[6]; /*Enzo: last timestamps used for the computation
                 of the real framerate */

//#ifdef _VBR_IP_QP_CORRELATION
  /* GT: This variable signals that the previous frame 
         was I type in P to I Correlation mode, 02 Apr 07 */
  t_uint16 Intra_Qp_Flag; 
//#endif

} VBR_HAMAC_par;

/* Structure for Motion Vector */
typedef struct
{
    t_sint16    x;			/* Full per coordinates 	*/
    t_sint16    y;			/* Full per coordinates 	*/
    t_sint8     hx;     		/* Half pel coordinates 	*/
    t_sint8     hy;     		/* Half pel coordinates 	*/
    t_uint8   valid;	    /* Existence of vector          */
    t_uint32    sad;			/* SAD of the block associated to the vector */
    t_uint8   zerovector;	/* Set if zerovector is chosen  */
} motion_vector;

typedef motion_vector*	pmv_t;

struct mv {
  /* GT: MVs overflow avoidance 04/07/2006 */
  t_sint32 x;
  t_sint32 y;
};

typedef struct
{
/* D.F. : Starting grid amplitude for refinement process*/        
  t_sint16 complete_refinement;

/* These are the predictor spaces:
   the 'previous' space contains the temporal predictors
   the 'actual' space contains the spatial predictors */

  pmv_t amv_prev_space;
  pmv_t amv_actl_space;
  
  motion_vector apv_preds[13];

  t_sint32 RCONTROL; /* FP: implements the vop_rounding_type flag */
}Motion_Estimation_Data;


typedef struct
{
  struct mv MB_vects[320]; //max size of 720p
  t_sint32  index_macroblock;

  /* used by the Rate Control in the pre-analisys */

  struct mv prev_MB_vects[320];
  t_sint32  prev_index_macroblock;
}Generate_MV_Data;

typedef struct {

    /** computed values  */
    //t_uint16 frame_number;       /**<\brief Image number in sequence, for debug */
    t_uint16 mb_width;           /**<\brief Width and height in number of MB */
    t_uint16 mb_height;
    t_uint16 mb_number;
    t_uint16 header_size;        /**<\brief Size of the header in bits, used in constant_rate_control */

    /*  in vars */
    t_uint32 brc_frame_target;
    t_uint32 brc_target_min_pred; 
    t_uint32 brc_target_max_pred;

    /*    in-out vars    */
    t_uint32 bitstream_size;      /*  total number of bits to encode the current frame */
    t_uint32 stuffing_bits;
  
    /*    out vars */
    t_uint16 brc_skip_prev;

    /*    stats-global vars    */
    t_uint32 bit_rate;
    t_sint32 delta_target;
    t_uint32 Smax;
    t_uint32 max_buff_level;          /* used in CBR */

    /*    stats-prev vars */
    t_uint32 pictCount;               
    t_uint32 last_I_Size;             
    t_uint32 comp_SUM;               
    t_uint32 comp_count;              
    t_uint32 ts_seconds_old;    
    t_uint32 avgSAD;                  
    t_uint32 seqSAD;                  
    t_uint32 TotSkip;                 /* used in VBR */
    t_uint32 Skip_Current;            /* used in VBR and VBR */
    t_uint32 PictQpSum;               /* used in CBR */
    t_uint32 S_overhead;              /* used in CBR */

    /*    other HAMAC BRC vars    */
    t_uint32 BUFFER_depletion;
    t_uint32 BUFFER_mod;
    t_uint32 PicTarget;
    t_uint32 I_PicTarget;
    t_uint32 P_PicTarget;
    t_uint32 skip_level;
    t_uint32 Tmin;
    t_uint32 Tmin_UF;
    t_uint16 delta_T_stamp;
    t_uint32 last_size;
    t_sint32 buffer_fullness;
    t_uint16 brc_skip;


   //CBR parameters
    t_uint16 marker_bits; 
	/** <\brief added in FW to keep number of bits added
                           * for DM markers so as to remove it from Sm, value
                           * 0, 17 or 19, used in m4e_masa_cbr_overheade() 
                           */
  t_sint32 buffer_fullness_fake_TS;
  
  t_uint32 PictQpSumIntra;
  
  t_uint16 MBnum;

  /* GT: enanched MB layer control for better Qp distribution, 02 Apr 07 */
  t_uint16 BPPmbPrevAct ;
  t_sint32 BPPmbErr	;
  t_uint16 BPPmbPrevEst 	;
  t_sint32 Lprev 	;
  t_uint16 CodedMB 		;
  t_uint16 CodedMB_flag 		;

  //in params
  t_uint16 picture_coding_type;
  t_uint16 frame_width;              /**<\brief Width  in pixels from current frame         */
  t_uint16 frame_height;             /**<\brief Height in pixels from current frame         */
  t_uint16 vp_bit_size;          
  t_uint16 vp_size_max;       
  t_uint16 flag_short_header;        /**<\brief Short header mode if =1                     */
  t_uint16 brc_type;                 /**<\brief the bit rate control (BRC) algorithm       */
  t_uint16 first_I_skipped_flag;  /**<\brief from mainver24d */
  t_sint16  init_ts_modulo_old;      /**<\brief from mainver24d */
  t_uint16 I_Qp;              /**<\brief Initial quantization parameter for intra picture */
  t_uint16 P_Qp;              /**<\brief Initial quantization parameter for inter picture */
  t_uint16 Cprev;             /**<\brief Previous header size in CBR                */
  t_uint16 BPPprev;           /**<\brief Previous bit per pixel parameter in CBR    */
  t_sint16  ts_modulo_old;     /**<\brief Previous vop time increment, signed */

} ts_m4e_global_param;


typedef struct
{
  t_sint32 MBnum_x;
  t_sint32 MBnum_y;
  t_sint32 blk_num;
  t_sint32 A;
  t_sint32 E;
  t_sint32 ch_U_A;
  t_sint32 ch_U_B;
  t_sint32 ch_V_A;
  t_sint32 ch_V_B;
  t_sint32 video_packet_mb;
  t_sint32 prev_video_packet_mb;
  t_sint16 luma_previous_DC_coeff[162]; //maximum size for 1280x720p
  t_sint16 chroma_previous_DC_coeff[162];
  
  t_sint16 DC_coef[6];

/*data duplicated for CBRSL: BEGIN*/

  t_sint16 prea_luma_previous_DC_coeff[162];
  t_sint16 prea_chroma_previous_DC_coeff[162];

  t_sint32   prea_E;
  t_sint32   prea_ch_U_A;
  t_sint32   prea_ch_V_A;

}DC_Data;


typedef struct
{
  t_uint32 Bs; /*VB dimension; 30+12 bit length variable should be used, but for the SP@L3 32 bits are good enough*/
  t_uint32 vbv_occupancy;
  t_sint32 B;  /*istantaneous VB fullness (bits)*/
  t_uint32 Rp; /*bits to be removed from the buffer per picture*/
  t_uint32 Rp_frac;
  t_uint32 ui_StuffBits;
  t_uint8  b_vbv_panic_mode;
  t_uint32 ui_Tmin;
  t_uint32 ui_Tmax; /*minimum and maximum bits for the current frame*/
  t_uint32 ui_GLOBAL_Tmax; /*minimum and maximum bits for every frame*/
  //static t_uint32 ui_GLOBAL_minfullness; /*minimum fullness for the buffer*/
  t_uint32 VPsize;
  t_uint32 totalMBs;
  t_uint32 MBwidth;
  t_uint32 max_vp_size;
  t_uint8 vbv_useHRD_flag;
  t_uint8 firstframe;
  //static t_uint8 framerate;
}VBVData;


typedef struct
{
  t_uint32 vps;
  t_uint32 modality;
  t_uint32 MBnum_x;
  t_uint32 MBnum_y;
  t_uint32 hec;
  t_uint32 hec_count;
  t_uint32 max_vp_size;
  t_uint32 vp_mb_size;
  t_uint32 MBnum_codelen;           /* FP: the MB number code length, computed according to MP4 Table 6.23 */
  t_uint32 MB_into_VP;  /*used only when the VP are used*/
}Bitstream_Data;


typedef struct
{
  t_uint16        code;
  t_uint8         length;
} VLCtable;


struct VLCDATA
{
  t_uint32 modality;
  t_uint32 reversible_vlc;
  /* Table for the events - indexed by [last][run][level-1] */
 
  /* INTRA table:
     2 bytes each entry:
     2*21*27 = 567 bytes
  */

  t_uint32 index_ip_last[5];
  t_uint32 index_vlc[200];
  VLCtable table[500];
};


/*struct created to encapsulate the parameters*/
typedef struct 
{
  t_sint32            VOP_WIDTH;
  t_sint32            VOP_HEIGHT;
  t_sint32            VOP_WIDTH_ACTUAL;     /* *FP* store the original VOP size (not rounded to 16) */
  t_sint32            VOP_HEIGHT_ACTUAL;    /* *FP* store the original VOP size (not rounded to 16) */
  t_sint32            pframes;
  t_sint32            rc_enable;
  t_sint32            rc_method;
  t_sint32			  brc_type;
  t_sint16            bitrate;
  t_sint32            target_dur;
  t_sint16            buffer_type;
  t_sint16            spat_quality;
  t_sint16            min_framerate;
  t_sint32            frames;
  t_sint32            error_resilience;
  t_sint32            reversible_vlc;
  t_sint32            hec;
  t_sint16            format;
  t_sint32            shdr_flag;
  t_sint32            quant_type;
  t_sint32            framerate;
  t_sint32            skipped;
  t_sint16            I_quant;
  t_sint16            P_quant;
  t_sint32            motion_estimator;
  //float             rc_loc_coef, rc_int_coef; /*they should be deleted after statistical retrieving*/
  t_sint32            rc_skip;
  t_sint32            rempeg_flag;
  t_sint32            tnr;
  t_sint32            tnr_sigma_c;      /*it should be deleted after statistical retrieving*/
  t_sint32            tnr_sigma_l;      /*it should be deleted after statistical retrieving*/
  t_uint32			  fcode;
  t_uint32			  fcode_max;
  t_sint32            annexi_flag;
  t_sint32            umv;
  t_sint32            profile;
  t_sint32            level;
  t_sint32            ac_prediction_enable;
  t_sint32            rc_Qmin;
  t_uint8				  rc_Qmax;			/*they should be deleted after statistical retrieving*/
  t_uint8				  rc_Errmax;		/*they should be deleted after statistical retrieving*/
  t_sint32            tm_inc_res;
  t_sint32            tm_inc;
  t_sint32            delta_tm_inc;
  t_sint32            vbv_bufsize;
  t_sint32            vbv_occupancy;
  t_sint32            panic_flag;
  t_sint32            if_flag;
  t_sint32            mismatch_corr;
  t_sint32            vp_mb_size;
  t_sint32            sh_gob_hdr;
  /* segmented mode */
  t_uint32			  maxGOBbitsize;
    /* t_sint32RA MB REFRESH */
  t_sint32			 ir_period;
  t_sint32			 air_enable;
  t_sint32			 air_strength;
  t_sint32           vbv_forcing;
  t_sint32           low_delay;
  t_sint32           swis_buf_size;
  t_sint32           vop_rounding_type;
  t_sint32           rtype_mod;            /* FP: vop rounding type modulation, when 1 toggle vop_rounding_type */
  t_sint32           zero_rand_seed;       /* FP: use zero as mp4e_random seed  1=zero  0=time() */
  t_sint32           res_strength;         /* FP: resilience strength as from table in MM use cases */
  t_sint32			 vol_intra;			   /* FP: 1 = insert a VOL header before each INTRA frame */
  t_uint32			 encoder_mode;	       /* FP: bit-mask with enabled modes (pre-proc image-stabilization, encoder) */
  t_sint32			 pp_in_x;			   /* FP: Pre-Processing input sequence size */
  t_sint32	         pp_in_y;		
  t_sint32	         pp_crop_x;			   /* FP: Pre-Processing cropping window size */
  t_sint32	         pp_crop_y;	
  t_sint32	         pp_crop_orig_x;       /* FP: Pre-Processing cropping window upper-left position */
  t_sint32           pp_crop_orig_y;
  t_sint32           pp_res_x;             /* FP: Pre-Processing output sequence size (after re-sizing) */
  t_sint32           pp_res_y;
  t_sint16			 *mb_refresh_map;      /* FP: in MB scan order 0=no refresh 1=MB refresh needed (e.g. because slice-loss) */
  t_sint32			 fake_time_stamps;     /* FP: force time-stamps to recover initial delay */
  t_sint32			 bits_per_frame;       /* FP: the number of bits available for the current frame (rate-controller) */
  t_sint32			 grab_failure;	       /* FP: 1=grab failure at the current frame    0=grab ok (normal) */
  t_sint32			 next_grab_failures;   /* FP: contains the number of consecutive grab-failures from the next frame on */
  t_sint8			 time_stamps_fname[80];  /* FP: filename with time-stamps */
  t_sint32			 *time_stamps_vect;				/* FP: pot_sint32s to dynamically allocated array of time-stamps */
  t_sint32			 time_stamps_vect_size;			/* FP: its size */
  t_sint32           max_vp_size;					/* FP: the maximum video packet size according to profile-level */
  t_sint32 			 prev_time_stamp;				/*EL: timestamp of previous frame */
  t_sint32			 curr_time_stamp;
  t_sint32           flag_pkt_nodp;
  t_sint32           total_bitcount;
  t_sint32           last_gob_bitstream_position;
  t_sint32			 U_OFFSET;
  t_sint32			 V_OFFSET;
  t_sint32			 U_OFFSET_ACTUAL;
  t_sint32			 V_OFFSET_ACTUAL;
//for h263_p3
  t_sint32			 slice_str_mode;
  t_sint32			 mod_quant_mode;  
  t_sint32			 deblock_filter;
  t_sint32			 rtype;
  t_sint32			 custom_pcf;
  t_sint32			 par;
  t_sint32			 aic_dc_only;
  t_sint32			 check_iq_values;
  t_sint32			 pc_tm_inc_res;
  t_sint32			 pc_tm_inc;
  t_sint32			 slice_len;
  t_sint32			 slice_len_mb;
  t_sint32			 adv_intra_coding;
  t_sint32			 h263_p3;

} mp4_parameters;


/*******************************************************/


typedef struct {
	struct BitStreamData   WriteBits;
	CBR_HAMAC_par		   CBR_hamac;
	VBR_HAMAC_par		   VBR_hamac;
	Motion_Estimation_Data Motion_Estimation; //predictors for temporal & spatial prediction
	Generate_MV_Data       Generate_MV; //array for MV pred
	ts_m4e_global_param    Gs_m4e_global_param;
	DC_Data				   DC;
	VBVData				   VBV; 
	Bitstream_Data         Bitstream;
    struct VLCDATA		   VLC;
}ts_t1xhv_vec_mp4e_global;

typedef ts_t1xhv_vec_mp4e_global *tps_t1xhv_vec_mp4e_global;


typedef struct
{
	tps_t1xhv_vec_mpeg4_param_out	Gps_vec_mpeg4_param_out;
	tps_t1xhv_vec_mpeg4_param_inout	Gps_vec_mpeg4_param_inout;
	tps_t1xhv_vec_mpeg4_param_in	Gps_vec_mpeg4_param_in;

	tps_t1xhv_bitstream_buf_pos		Gps_bitstream_buf_pos_out;
	tps_t1xhv_bitstream_buf_pos		Gps_bitstream_buf_pos;
	tps_t1xhv_vec_header_buf		Gps_bitstream_buf_header;
	tps_t1xhv_vec_internal_buf		Gps_vec_internal_buf;
	tps_t1xhv_vec_frame_buf_out		Gps_vec_frame_buf_out;
	tps_t1xhv_vec_frame_buf_in		Gps_vec_frame_buf_in;
	ts_t1xhv_vec_mp4e_global        Gs_vec_mp4e_global;

	t_uint32						G_addr_out_parameters;
	t_uint32						G_addr_out_frame_parameters;

	t_uint16						QP[7200];
	t_uint16						not_coded_P3[7200];
	t_uint16						slice_num[7200];
	t_sint16						mb_refresh_map[3600]; //720p resolution
}ts_t1xhv_vec_mp4e_session;

typedef ts_t1xhv_vec_mp4e_session *tps_t1xhv_vec_mp4e_session;


#endif /* _t1xhv_vec_mpeg4_idt */
