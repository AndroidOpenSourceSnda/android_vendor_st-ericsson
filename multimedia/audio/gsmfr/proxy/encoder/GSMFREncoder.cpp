/*
 * Copyright (C) ST-Ericsson SA 2010. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 */


#include "GSMFREncoder.h"

#include "GSMFRNmfHost_Encoder.h"
#include "GSMFREnc_BitStreamPort.h"
#include "GSMFREnc_PcmPort.h"
// UID top dictionnary (generated by trace compiler)
#include "GSMFR_HOST_ENC_top.h"
// TODO FIXME: manage buffers that are not 32-bit multiple (for Host proxy only)
#define SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES 4

OMX_ERRORTYPE gsmfrhostencFactoryMethod(ENS_Component_p * ppENSComponent) {
	OMX_ERRORTYPE error  = OMX_ErrorNone;
	GSMFREncoder *gsmfrenc = new GSMFREncoder(true);
	if (gsmfrenc == 0) {
		return OMX_ErrorInsufficientResources;
	}
	error = gsmfrenc->construct();
	if (error != OMX_ErrorNone){
		delete gsmfrenc;
		*ppENSComponent = 0;
        return OMX_ErrorInsufficientResources;
	}else{
		*ppENSComponent = gsmfrenc;
	}
	
    GSMFRNmfHost_Encoder *gsmfrenc_ProcessingComp = new GSMFRNmfHost_Encoder(*gsmfrenc);

    if (gsmfrenc_ProcessingComp == 0) {
        delete gsmfrenc;
        return OMX_ErrorInsufficientResources;
    }

    gsmfrenc->setProcessingComponent(gsmfrenc_ProcessingComp);

	return error;
}


OMX_ERRORTYPE GSMFREncoder::createGSMFRBitstreamPort(const OMX_AUDIO_PARAM_GSMFRTYPE &defaultAmrSettings) 
{
  OMX_U32 supported_length = getMaxFrameSize()/8;

  if (mIsHost) {
    supported_length += (SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES - 1);
    supported_length &= ~(SUPPORTED_BUFFER_SIZE_MULTIPLE_IN_BYTES - 1);
  }

        GSMFREnc_BitstreamPort *gsmfrPort = 
            new GSMFREnc_BitstreamPort(1, OMX_DirOutput, supported_length, defaultAmrSettings, *this);
                    
        if (gsmfrPort == 0) {
            return OMX_ErrorInsufficientResources;
        }
        
    addPort(gsmfrPort);

   if (mIsHost) {
        gsmfrPort->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);

   }
        return OMX_ErrorNone;
}

OMX_ERRORTYPE  GSMFREncoder::construct()
{
	OMX_ERRORTYPE error;
	OMX_AUDIO_PARAM_PCMMODETYPE defaultPcmSettings;
    OMX_AUDIO_PARAM_GSMFRTYPE defaultGsmfrSettings;

	defaultPcmSettings.nPortIndex     = 0;
	defaultPcmSettings.eNumData       = OMX_NumericalDataSigned;
    defaultPcmSettings.eEndian        = OMX_EndianBig;
	defaultPcmSettings.bInterleaved   = OMX_TRUE;
	defaultPcmSettings.ePCMMode       = OMX_AUDIO_PCMModeLinear;
	defaultPcmSettings.nBitPerSample  = 16;

	defaultPcmSettings.nChannels      = 1;
	defaultPcmSettings.nSamplingRate  = 8000;

	defaultPcmSettings.eChannelMapping[0] = OMX_AUDIO_ChannelCF;
	
	defaultGsmfrSettings.nSize         = sizeof(OMX_AUDIO_PARAM_GSMFRTYPE);
    getOmxIlSpecVersion(&defaultGsmfrSettings.nVersion);
    defaultGsmfrSettings.nPortIndex      = 0;
    defaultGsmfrSettings.bDTX            = OMX_FALSE;
    defaultGsmfrSettings.bHiPassFilter   = OMX_TRUE;
    
	error = AFM_Encoder::construct(
			OMX_AUDIO_CodingGSMFR, getSampleFrameSize()*getMaxChannels(), defaultPcmSettings, 1);
	if (error != OMX_ErrorNone) return error;
	
	ENS_String<16> role = "audio_encoder.gsmfr";
  role.put((OMX_STRING)mRoles[0]);
  setActiveRole(mRoles[0]);

	error = createGSMFRBitstreamPort(defaultGsmfrSettings);
    if (error != OMX_ErrorNone) return error;
    if (mIsHost) {
        AFM_PcmPort *pcmPort = static_cast<AFM_PcmPort *>(getPort(0));
    pcmPort->setSupportedProprietaryComm(AFM_HOST_PROPRIETARY_COMMUNICATION);
    }
    return OMX_ErrorNone;
}

OMX_ERRORTYPE GSMFREncoder::getExtensionIndex(OMX_STRING cParameterName,
						     OMX_INDEXTYPE* pIndexType) const
{
    if (mIsHost) {
        if (ENS_String<ENS_COMPONENT_NAME_MAX_LENGTH>(cParameterName) 
                == "OMX.ST.AFM.proprietary_communication") {
            return OMX_ErrorNotImplemented;
        }
    }

    return AFM_Component::getExtensionIndex(cParameterName, pIndexType);
}

OMX_ERRORTYPE GSMFREncoder::createPcmPort(
        OMX_U32 nIndex,
        OMX_DIRTYPE eDir,
        OMX_U32 nBufferSizeMin,
        const OMX_AUDIO_PARAM_PCMMODETYPE &defaultPcmSettings)
{
    ENS_Port * port = new GSMFREnc_PcmPort(
                nIndex, eDir, nBufferSizeMin, defaultPcmSettings, *this);
    if (port == 0) {
        return OMX_ErrorInsufficientResources;
    }

    addPort(port);

    return OMX_ErrorNone;
}
OMX_U32 GSMFREncoder::getUidTopDictionnary(void)
{

        return KOstGSMFR_HOST_ENC_top_ID;

}
