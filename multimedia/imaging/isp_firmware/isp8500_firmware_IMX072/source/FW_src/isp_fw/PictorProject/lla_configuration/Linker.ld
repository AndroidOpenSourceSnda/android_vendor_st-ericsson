/******************************************************************************
 *                                                                            *
 * This file contains basic link script for SX cores.                         *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *      Copyright 2004, STMicroelectronics, Incorporated.                     *
 *      All rights reserved.                                                  *
 *                                                                            *
 *        STMICROELECTRONICS, INCORPORATED PROPRIETARY INFORMATION            *
 * This software is supplied under the terms of a license agreement           *
 * or nondisclosure agreement with STMicroelectronics and may not be          *
 * copied or disclosed except in accordance with the terms of that            *
 * agreement.                                                                 *
 *                                                                            *
 ******************************************************************************/
/*
 * Copyright (C) ST-Ericsson SA 2010. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 */

OUTPUT_FORMAT("elf32-stxp70v3","elf32-stxp70v3","elf32-stxp70v3")
OUTPUT_ARCH(stxp70v3)

MEMORY
{
  IDM   (rw!x)     : org = 0x00000004, len = 8K-68     /* Internal Data Memory of 8K  */
                                                       /* IDM-@0 reserved for NULL   */
  FIXED_ADD_2 (rw!x) : org = 0x00001FC0, len = 32        /* For Fixed Address Variables */                                                       
  FIXED_ADD (rw!x) : org = 0x00001FE0, len = 32        /* For Fixed Address Variables */
  IPM   (rx)       : org = 0x00400000, len = 64K       /* Internal Program Memory of 64K: TCM  */
  EXT_IPM(rx)      : org = 0x10001000, len = 48K       /* External Program Memory of 64K, the memory is PA access and can not be used as data; first 4KB reserved */
  EXT_IDM(rw!x)    : org = 0x1000D000, len = 12K       /* External Data Memory of 12K inside eSRAM for accessing data */
  EXT_IPM2(rx)     : org = 0x20000000, len = 256K      /* External Program Memory inside the DDR memory, the memory is PA access and can not be used as data */
  INTIO (rw!x)     : org = 0xF0000000, len = 16K       /* INT MEM IO SPACE, contains 3D registers also for V2 */
  ISPMEM (rw!x)    : org = 0x90000000, len = 189K      /* ISP MEM SPACE   */

}

/*
 * It is very important that one section (and only one) uses the
 * CREATE_SECINFO_TABLE linker's macro. The default startup provided with
 * the compiler relies on the following symbols that are generated by
 * the linker when this macro is used:
 *   - __stm_binfo_clear
 *   - __stm_einfo_clear
 *   - __stm_binfo_copy
 *   - __stm_einfo_copy
 */

ENTRY(__START_POINT)
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  .startup 0x400000     : { __START_POINT = .; *(.startup) }          > IPM
  .ivtable 0x400020     : { __IVBR_BASE = .; *(.ivtable)   }          > IPM
  .syscall              : { *(.syscall)    }                          > IPM
  .thandlers            : { *(.thandlers)  }                          > IPM
  .ithandlers           : { *(.ithandlers) }                          > IPM
  .text                 : { *(.text)       }                          > IPM
  .exttext              : { *(.exttext)    }                          > EXT_IPM
  .extdata              : { *(.extdata)    }                          > EXT_IDM
  .fixedadd_2			: { *(.fixedadd_2) }						  > FIXED_ADD_2	
  .exttext2             : { *(.exttext2)   }                          > EXT_IPM2

  .secinfo              : { CREATE_SECINFO_TABLE }                    > IPM

  /* Data with Fixed Address section */
  .fixedadd             : { *(.fixedadd)  }                           > FIXED_ADD

  /* Tiny Data Area (tda) starts at 0 and is 32 Kbytes maximum */
  .tda_data MAX_ENDADDRESS(32768) : { *(.tda_data) }                  > IDM
  .tda      MAX_ENDADDRESS(32768) : { *(.tda) }                       > IDM
  .tda_bss  MAX_ENDADDRESS(32768) : { *(.tda_bss) }                   > IDM
  .tbss     MAX_ENDADDRESS(32768) : { *(.tbss) }                      > IDM
  .tda_ro   MAX_ENDADDRESS(32768) : { *(.tda_ro) }                    > IDM
  .rotda    MAX_ENDADDRESS(32768) : { *(.rotda) }                     > IDM

  /* stack1 is stack dedicated to context 1 */
  .stack1 ALIGN(16) PAD(1904) NOINIT : {}                             > IDM

  .gpbase    ALIGN(8) : { __GP_BASE = .; }                            > IDM
  .sda_data1_p ALIGN(4) : {} > IPM

  .sda_data1 ALIGN(4) MAX_ENDADDRESS(absolute(__GP_BASE)+4096)   : { *(.sda_data1) } > IDM AT > IPM

  .sda_bss1  ALIGN(4) MAX_ENDADDRESS(absolute(__GP_BASE)+4096)   NOINIT : { *(.sda_bss1) }  > IDM

  .sda_ro1_p ALIGN(4) : {} > IPM
  .sda_ro1   ALIGN(4) MAX_ENDADDRESS(absolute(__GP_BASE)+4096)   : { *(.sda_ro1) }   > IDM AT > IPM

  .sda_data2_p ALIGN(4) : {} > IPM
  .sda_data2 ALIGN(4) MAX_ENDADDRESS(absolute(__GP_BASE)+4096*2) : { *(.sda_data2) } > IDM AT > IPM

  .sda_bss2  ALIGN(4) MAX_ENDADDRESS(absolute(__GP_BASE)+4096*2) NOINIT : { *(.sda_bss2) }  > IDM

  .sda_ro2_p ALIGN(4) : {} > IPM
  .sda_ro2   ALIGN(4) MAX_ENDADDRESS(absolute(__GP_BASE)+4096*2) : { *(.sda_ro2) }   > IDM AT > IPM

  .sda_data4_p ALIGN(4) : {} > IPM
  .sda_data4 MAX_ENDADDRESS(absolute(__GP_BASE)+4096*4) : { *(.sda_data4) } > IDM AT > IPM

  .sda_bss4  MAX_ENDADDRESS(absolute(__GP_BASE)+4096*4) NOINIT : { *(.sda_bss4) }  > IDM

  .sda_ro4_p ALIGN(4) : {} > IPM
  .sda_ro4   MAX_ENDADDRESS(absolute(__GP_BASE)+4096*4) : { *(.sda_ro4) }   > IDM AT > IPM

  .sda_data8 MAX_ENDADDRESS(absolute(__GP_BASE)+4096*8) : { *(.sda_data8) } > IDM

  .sda_bss8  MAX_ENDADDRESS(absolute(__GP_BASE)+4096*8) : { *(.sda_bss8) }  > IDM

  .sda_ro8   MAX_ENDADDRESS(absolute(__GP_BASE)+4096*8) : { *(.sda_ro8) }   > IDM


  .data                 : { *(.data)         }                        > IDM
  /*AT > IPM*/
  .rodata               : { *(.rodata)       }                        > EXT_IPM
  .bss NOINIT           : { *(.bss COMMON) }                          > IDM
  .heap      ALIGN(4) PAD(4) NOINIT : {}                              > IDM

  /* DWARF debug sections.
   * Symbols in the DWARF debugging sections are relative to the beginning
   * of the section so we begin them at 0.
 */
  /* DWARF 1 */
  .debug 0x0            : { *(.debug)           }
  .line 0x0             : { *(.line)            }
  /* GNU DWARF 1 extensions */
  .debug_srcinfo  0x0   : { *(.debug_srcinfo)   }
  .debug_sfnames  0x0   : { *(.debug_sfnames)   }
  /* DWARF 1.1 and DWARF 2 */
  .debug_aranges  0x0   : { *(.debug_aranges)   }
  .debug_pubnames 0x0   : { *(.debug_pubnames)  }
  /* DWARF 2 */
  .debug_info     0x0   : { *(.debug_info)      }
  .debug_abbrev   0x0   : { *(.debug_abbrev)    }
  .debug_line     0x0   : { *(.debug_line)      }
  .debug_frame    0x0   : { *(.debug_frame)     }
  .debug_str      0x0   : { *(.debug_str)       }
  .debug_loc      0x0   : { *(.debug_loc)       }
  .debug_macinfo  0x0   : { *(.debug_macinfo)   }
  /* SGI/MIPS DWARF 2 extensions */
  .debug_weaknames 0x0  : { *(.debug_weaknames) }
  .debug_funcnames 0x0  : { *(.debug_funcnames) }
  .debug_typenames 0x0  : { *(.debug_typenames) }
  .debug_varnames  0x0  : { *(.debug_varnames)  }
  /* DWARF 3 */
  .debug_ranges    0x0 : { *(.debug_ranges)    }
}
