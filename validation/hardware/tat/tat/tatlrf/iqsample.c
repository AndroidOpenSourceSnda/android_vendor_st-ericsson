/*****************************************************************************/
/**
*  Â© ST-Ericsson, 2011 - All rights reserved
*  Reproduction and Communication of this document is strictly prohibited
*  unless specifically authorized in writing by ST-Ericsson
*
* \file	   iqsample.c
* \brief   declare 2G/3G IQ samples DTH routines
* \author  ST-Ericsson
*
* \test STUB_RX_IQSAMPLES: use hardcoded response with data instead of
* requesting the modem.
*
* \test STUB_RX_IQSAMPLES and STUB_RX_IQSAMPLES_FAILED: hardcoded case for
* message returning C_TEST_FAILED.
*
* \test STUB_RX_IQSAMPLES and STUB_RX_IQSAMPLES_SB_FAILED: hardcoded case for
* message returning C_TEST_OK and subblock with C_TEST_FAILED status and no 
* data.
*/
/*****************************************************************************/

#include "rfdef.h"
#include "iqsample.h"

#include "misc.h"
#include "rx2g.h"
#include "rx3g.h"
#include "isimsg.h"

#include <sys/types.h>
#include <sys/stat.h>

#include <fcntl.h>
#include <unistd.h>		/* close */
#include <time.h>		/* time, strftime */

/* Function tide to RX IQ sample reading */
/*********************************/
int DthRf_IQSample_exec(struct dth_element *elem)
{
	return tatl16_01IQSample_exec(elem);
}

int DthRf_IQSample_get(struct dth_element *elem, void *value)
{
	return tatl16_03IQSample_get(elem, value);
}

int DthRf_IQSample_set(struct dth_element *elem, void *value)
{
	return tatl16_02IQSample_set(elem, value);
}

/*Global variables */

/* this argument is used in WCDMA */
u8  v_tatlrf_iq_samples_path         = CTRL_RF_PATH1;
u16 v_tatlrf_iq_samples_status       = 0xFF;
u16 v_tatlrf_iq_samples_sample_freq  = 0;
u16 v_tatlrf_iq_samples_rx_gain      = 0;
u16 v_tatlrf_iq_samples_nb_data      = 0;
/* 0=new message, 1=continue. WCDMA only */
u32 v_tatlrf_iq_samples_is_new       = C_TEST_TRUE;

void add_iq_sample_record(FILE *fp, C_TEST_SB_RECEIVED_RX_IQ_SAMPLES_STR * sb,
			  u32 new_message);

int tatl16_readIQSamples(struct dth_element *elem, u32 new_message)
{
	struct tatrf_isi_msg_t vl_msg_info;
	int vl_Error = TAT_ERROR_OFF;

	tatrf_isi_init(&vl_msg_info);

	/* create message */
	C_TEST_TUNING_REQ_STR *pl_req;
	pl_req =
	    tatrf_isi_msg_begin(&vl_msg_info, PN_DSP_COMMON_TEST,
				C_TEST_TUNING_REQ, numberOfSubBlocks);
	if (NULL == pl_req) {
		return TAT_ISI_HANDLER_ERROR;
	}

	pl_req->fill1 = ISIFILLER8;
	pl_req->fill2 = ISIFILLER8;

	/* add a subblock */
	C_TEST_SB_READ_RX_IQ_SAMPLES_STR *pl_sb =
	    tatrf_isi_msg_add_sb(&vl_msg_info, C_TEST_SB_READ_RX_IQ_SAMPLES);
	if (NULL == pl_sb) {
		return TAT_ISI_HANDLER_ERROR;
	}

	if (ACT_RX2G5_IQSAMPLE == elem->user_data) {
		pl_sb->system_info = C_TEST_GSM;
		v_tatlrf_iq_samples_path = CTRL_RF_PATH1;
	} else {
		pl_sb->system_info = C_TEST_WCDMA;
	}

	pl_sb->is_new_samples_rx_path =
	    SetU8InU16(LSB_POSS, 0, v_tatlrf_iq_samples_path);
	pl_sb->is_new_samples_rx_path =
	    SetU8InU16(MSB_POSS, pl_sb->is_new_samples_rx_path, new_message);

#ifndef STUB_RX_IQSAMPLES

	/* send ISI message - blocking function */
	vl_Error = tatrf_isi_send(&vl_msg_info, "Read IQ samples");
	if (!TAT_OK(vl_Error)) {
		return vl_Error;
	}

	/* message successfully sent. waiting for response */
	C_TEST_TUNING_RESP_STR *pl_resp =
	    tatrf_isi_read(&vl_msg_info, C_TEST_TUNING_RESP, numerOfSubBlocks,
			   "Read IQ samples response", &vl_Error);
	if (NULL == pl_resp) {
		/* this what we expected */
		return TAT_ISI_HANDLER_ERROR;
	}
#else
	tatrf_isi_init(&vl_msg_info);

	C_TEST_TUNING_RESP_STR *pl_resp = tatrf_isi_msg_begin(&vl_msg_info,
							      PN_DSP_COMMON_TEST,
							      C_TEST_TUNING_RESP,
							      numerOfSubBlocks);
#ifndef STUB_RX_IQSAMPLES_FAILED
	pl_resp->status = C_TEST_OK;

#ifndef STUB_RX_IQSAMPLES_SB_FAILED
	static unsigned char IQsampleRespBytes[] = {
		0xb9, 0x00, 0xf4, 0x04, 0x00, 0xAA, 0x01, 0x00,
		0x01, 0xAA, 0x1e, 0x02, 0xff, 0xff, 0x00, 0x00,
		0x00, 0x00, 0x38, 0x01, 0x84, 0x00, 0x34, 0x00,
		0x3b, 0x00, 0x7c, 0x00, 0xd1, 0xff, 0x82, 0x00,
		0x8a, 0xff, 0x3b, 0x00, 0x89, 0xff, 0xcf, 0xff,
		0xc4, 0xff, 0x8a, 0xff, 0x27, 0x00, 0x86, 0xff,
		0x7b, 0x00, 0xc0, 0xff, 0x88, 0x00, 0x2a, 0x00,
		0x40, 0x00, 0x81, 0x00, 0xde, 0xff, 0x7f, 0x00,
		0x8e, 0xff, 0x39, 0x00, 0x82, 0xff, 0xdb, 0xff,
		0xc4, 0xff, 0x8d, 0xff, 0x27, 0x00, 0x7f, 0xff,
		0x74, 0x00, 0xc3, 0xff, 0x82, 0x00, 0x29, 0x00,
		0x47, 0x00, 0x72, 0x00, 0xde, 0xff, 0x83, 0x00,
		0x8f, 0xff, 0x51, 0x00, 0x7f, 0xff, 0xeb, 0xff,
		0xb6, 0xff, 0x8d, 0xff, 0x1e, 0x00, 0x7f, 0xff,
		0x75, 0x00, 0xbd, 0xff, 0x82, 0x00, 0x18, 0x00,
		0x4a, 0x00, 0x6d, 0x00, 0xe9, 0xff, 0x8e, 0x00,
		0x8c, 0xff, 0x51, 0x00, 0x77, 0xff, 0xe6, 0xff,
		0xb4, 0xff, 0x99, 0xff, 0x13, 0x00, 0x80, 0xff,
		0x68, 0x00, 0xaa, 0xff, 0x84, 0x00, 0x0f, 0x00,
		0x50, 0x00, 0x6b, 0x00, 0xe9, 0xff, 0x87, 0x00,
		0x8e, 0xff, 0x50, 0x00, 0x71, 0xff, 0xed, 0xff,
		0xab, 0xff, 0x97, 0xff, 0x0d, 0x00, 0x7c, 0xff,
		0x64, 0x00, 0xa7, 0xff, 0x84, 0x00, 0x08, 0x00,
		0x58, 0x00, 0x66, 0x00, 0xf5, 0xff, 0x86, 0x00,
		0x9c, 0xff, 0x53, 0x00, 0x7d, 0xff, 0xf3, 0xff,
		0xa0, 0xff, 0x9a, 0xff, 0x04, 0x00, 0x76, 0xff,
		0x65, 0x00, 0xa1, 0xff, 0x88, 0x00, 0x02, 0x00,
		0x5e, 0x00, 0x5a, 0x00, 0x04, 0x00, 0x7e, 0x00,
		0xa2, 0xff, 0x61, 0x00, 0x77, 0xff, 0x09, 0x00,
		0xa3, 0xff, 0xa0, 0xff, 0xff, 0xff, 0x74, 0xff,
		0x5e, 0x00, 0xa0, 0xff, 0x89, 0x00, 0xfc, 0xff,
		0x65, 0x00, 0x56, 0x00, 0x04, 0x00, 0x84, 0x00,
		0xa9, 0xff, 0x63, 0x00, 0x7f, 0xff, 0x06, 0x00,
		0x98, 0xff, 0xab, 0xff, 0xf4, 0xff, 0x7e, 0xff,
		0x59, 0x00, 0x96, 0xff, 0x8e, 0x00, 0xf0, 0xff,
		0x6d, 0x00, 0x57, 0x00, 0x16, 0x00, 0x86, 0x00,
		0xb1, 0xff, 0x68, 0x00, 0x81, 0xff, 0x12, 0x00,
		0x9d, 0xff, 0xaf, 0xff, 0xf1, 0xff, 0x7a, 0xff,
		0x52, 0x00, 0x95, 0xff, 0x8a, 0x00, 0xee, 0xff,
		0x74, 0x00, 0x4f, 0x00, 0x12, 0x00, 0x86, 0x00,
		0xb0, 0xff, 0x70, 0x00, 0x7c, 0xff, 0x13, 0x00,
		0x93, 0xff, 0xae, 0xff, 0xea, 0xff, 0x7f, 0xff,
		0x4d, 0x00, 0x94, 0xff, 0x84, 0x00, 0xe6, 0xff,
		0x75, 0x00, 0x4d, 0x00, 0x26, 0x00, 0x88, 0x00,
		0xb8, 0xff, 0x75, 0x00, 0x7b, 0xff, 0x23, 0x00,
		0x91, 0xff, 0xb9, 0xff, 0xe1, 0xff, 0x7a, 0xff,
		0x3f, 0x00, 0x8d, 0xff, 0x7d, 0x00, 0xdc, 0xff,
		0x73, 0x00, 0x40, 0x00, 0x22, 0x00, 0x84, 0x00,
		0xbf, 0xff, 0x7b, 0x00, 0x80, 0xff, 0x24, 0x00,
		0x89, 0xff, 0xc2, 0xff, 0xd5, 0xff, 0x82, 0xff,
		0x3d, 0x00, 0x88, 0xff, 0x7e, 0x00, 0xd3, 0xff,
		0x76, 0x00, 0x38, 0x00, 0x2c, 0x00, 0x82, 0x00,
		0xc9, 0xff, 0x7e, 0x00, 0x83, 0xff, 0x2f, 0x00,
		0x80, 0xff, 0xc2, 0xff, 0xc9, 0xff, 0x83, 0xff,
		0x35, 0x00, 0x87, 0xff, 0x7d, 0x00, 0xd1, 0xff,
		0x7a, 0x00, 0x35, 0x00, 0x32, 0x00, 0x7b, 0x00,
		0xcf, 0xff, 0x79, 0x00, 0x87, 0xff, 0x31, 0x00,
		0x84, 0xff, 0xc9, 0xff, 0xc8, 0xff, 0x7d, 0xff,
		0x2d, 0x00, 0x7b, 0xff, 0x7d, 0x00, 0xc7, 0xff,
		0x7e, 0x00, 0x31, 0x00, 0x37, 0x00, 0x7a, 0x00,
		0xd5, 0xff, 0x80, 0x00, 0x8b, 0xff, 0x45, 0x00,
		0x7e, 0xff, 0xdf, 0xff, 0xbd, 0xff, 0x86, 0xff,
		0x2b, 0x00, 0x7a, 0xff, 0x7c, 0x00, 0xc3, 0xff,
		0x81, 0x00, 0x26, 0x00, 0x46, 0x00, 0x71, 0x00,
		0xe6, 0xff, 0x7f, 0x00, 0x8c, 0xff, 0x3f, 0x00,
		0x80, 0xff, 0xe0, 0xff, 0xc4, 0xff, 0x9b, 0xff,
		0x23, 0x00, 0x82, 0xff, 0x71, 0x00, 0xb1, 0xff,
		0x8a, 0x00, 0x1f, 0x00, 0x4d, 0x00, 0x7a, 0x00,
		0xe1, 0xff, 0x83, 0x00, 0x90, 0xff, 0x48, 0x00,
		0x7f, 0xff, 0xe9, 0xff, 0xb4, 0xff, 0x93, 0xff,
		0x18, 0x00, 0x7d, 0xff, 0x70, 0x00, 0xb8, 0xff,
		0x86, 0x00, 0x22, 0x00, 0x4c, 0x00, 0x76, 0x00,
		0xe8, 0xff, 0x8a, 0x00, 0x97, 0xff, 0x53, 0x00,
		0x80, 0xff, 0xf0, 0xff, 0xb1, 0xff, 0x94, 0xff,
		0x16, 0x00, 0x7c, 0xff, 0x6a, 0x00, 0xb4, 0xff,
		0x82, 0x00, 0x15, 0x00, 0x54, 0x00, 0x69, 0x00,
		0xfa, 0xff, 0x8a, 0x00, 0x96, 0xff, 0x5e, 0x00,
		0x7b, 0xff, 0xf8, 0xff, 0xad, 0xff, 0xa0, 0xff,
		0x12, 0x00, 0x81, 0xff, 0x68, 0x00, 0xa7, 0xff,
		0x87, 0x00, 0x03, 0x00, 0x5f, 0x00, 0x62, 0x00,
		0x01, 0x00, 0x87, 0x00, 0x9c, 0xff, 0x5a, 0x00,
		0x72, 0xff, 0xf8, 0xff, 0xa1, 0xff, 0x9d, 0xff,
		0x01, 0x00, 0x7d, 0xff, 0x5f, 0x00, 0xa4, 0xff,
		0x85, 0x00, 0xff, 0xff, 0x60, 0x00, 0x5d, 0x00,
		0x06, 0x00, 0x84, 0x00, 0xa4, 0xff, 0x5e, 0x00,
		0x74, 0xff, 0x06, 0x00, 0x9b, 0xff, 0xa1, 0xff,
		0xf4, 0xff, 0x70, 0xff, 0x56, 0x00, 0x9a, 0xff,
		0x87, 0x00, 0xfe, 0xff, 0x68, 0x00, 0x58, 0x00,
		0x09, 0x00, 0x82, 0x00, 0xab, 0xff, 0x69, 0x00,
		0x7f, 0xff, 0x11, 0x00, 0x96, 0xff, 0xa7, 0xff,
		0xf0, 0xff, 0x6f, 0xff, 0x5f, 0x00, 0x93, 0xff,
		0x90, 0x00, 0xf1, 0xff, 0x6b, 0x00, 0x53, 0x00,
		0x13, 0x00, 0x89, 0x00, 0xb1, 0xff, 0x6e, 0x00,
		0x79, 0xff, 0x14, 0x00, 0x95, 0xff, 0xb3, 0xff,
		0xed, 0xff, 0x7d, 0xff, 0x52, 0x00, 0x8c, 0xff,
		0x8e, 0x00, 0xe3, 0xff, 0x79, 0x00, 0x4f, 0x00,
		0x1b, 0x00, 0x87, 0x00, 0xb4, 0xff, 0x70, 0x00,
		0x7b, 0xff, 0x1d, 0x00, 0x8e, 0xff, 0xbb, 0xff,
		0xe7, 0xff, 0x80, 0xff, 0x4b, 0x00, 0x90, 0xff,
		0x82, 0x00, 0xe3, 0xff, 0x73, 0x00, 0x4a, 0x00,
		0x2b, 0x00, 0x85, 0x00, 0xbe, 0xff, 0x74, 0x00,
		0x7b, 0xff, 0x1f, 0x00, 0x8e, 0xff, 0xbc, 0xff,
		0xdd, 0xff, 0x82, 0xff, 0x3c, 0x00, 0x8e, 0xff,
		0x82, 0x00, 0xdc, 0xff, 0x7d, 0x00, 0x45, 0x00,
		0x27, 0x00, 0x86, 0x00, 0xc2, 0xff, 0x7b, 0x00,
		0x81, 0xff, 0x32, 0x00, 0x84, 0xff, 0xca, 0xff,
		0xd6, 0xff, 0x85, 0xff, 0x40, 0x00, 0x8e, 0xff,
		0x81, 0x00, 0xd8, 0xff, 0x7b, 0x00, 0x37, 0x00,
		0x2e, 0x00, 0x82, 0x00, 0xc7, 0xff, 0x83, 0x00,
		0x82, 0xff, 0x30, 0x00, 0x88, 0xff, 0xca, 0xff,
		0xcd, 0xff, 0x8a, 0xff, 0x32, 0x00, 0x85, 0xff,
		0x7a, 0x00, 0xc8, 0xff, 0x7b, 0x00, 0x34, 0x00,
		0x32, 0x00, 0x7e, 0x00, 0xcb, 0xff, 0x7c, 0x00,
		0x82, 0xff, 0x37, 0x00, 0x83, 0xff, 0xd0, 0xff,
		0xcd, 0xff, 0x82, 0xff, 0x2f, 0x00, 0x84, 0xff,
		0x77, 0x00, 0xc7, 0xff, 0x7f, 0x00, 0x27, 0x00,
		0x42, 0x00, 0x76, 0x00, 0xdf, 0xff, 0x81, 0x00,
		0x8d, 0xff, 0x3e, 0x00, 0x7c, 0xff, 0xd8, 0xff,
		0xbe, 0xff, 0x82, 0xff, 0x26, 0x00, 0x73, 0xff,
		0x72, 0x00, 0xbb, 0xff, 0x7f, 0x00, 0x23, 0x00,
		0x48, 0x00, 0x70, 0x00, 0xe5, 0xff, 0x80, 0x00,
		0x8d, 0xff, 0x4a, 0x00, 0x7f, 0xff, 0xe4, 0xff,
		0xc0, 0xff, 0x8b, 0xff, 0x1f, 0x00, 0x77, 0xff,
		0x71, 0x00, 0xb4, 0xff, 0x8a, 0x00, 0x19, 0x00,
		0x4f, 0x00, 0x6f, 0x00, 0xe6, 0xff, 0x85, 0x00,
		0x96, 0xff, 0x4a, 0x00, 0x7f, 0xff, 0xe3, 0xff,
		0xaf, 0xff, 0x92, 0xff, 0x17, 0x00, 0x7b, 0xff,
		0x76, 0x00, 0xa9, 0xff, 0x8a, 0x00, 0x18, 0x00,
		0x53, 0x00, 0x74, 0x00, 0xf4, 0xff, 0x85, 0x00,
		0x9a, 0xff, 0x4a, 0x00, 0x7c, 0xff, 0xee, 0xff,
		0xb1, 0xff, 0x97, 0xff, 0x10, 0x00, 0x7a, 0xff,
		0x69, 0x00, 0xb0, 0xff, 0x8b, 0x00, 0x13, 0x00,
		0x57, 0x00, 0x6c, 0x00, 0xef, 0xff, 0x84, 0x00,
		0x98, 0xff, 0x55, 0x00, 0x7a, 0xff, 0xf4, 0xff,
		0xa8, 0xff, 0x9d, 0xff, 0x09, 0x00, 0x7d, 0xff,
		0x60, 0x00, 0xa5, 0xff, 0x82, 0x00, 0x00, 0x00,
		0x60, 0x00, 0x5f, 0x00, 0x02, 0x00, 0x85, 0x00,
		0x9f, 0xff, 0x62, 0x00, 0x77, 0xff, 0x07, 0x00,
		0xa1, 0xff, 0xa2, 0xff, 0xfd, 0xff, 0x79, 0xff,
		0x58, 0x00, 0xa6, 0xff, 0x82, 0x00, 0x00, 0x00,
		0x64, 0x00, 0x59, 0x00, 0x08, 0x00, 0x8a, 0x00,
		0xa2, 0xff, 0x67, 0x00, 0x73, 0xff, 0x05, 0x00,
		0x9a, 0xff, 0xa6, 0xff, 0xf8, 0xff, 0x7c, 0xff,
		0x56, 0x00, 0x99, 0xff, 0x85, 0x00, 0xf4, 0xff,
		0x67, 0x00, 0x58, 0x00, 0x07, 0x00, 0x88, 0x00,
		0xa8, 0xff, 0x69, 0x00, 0x7b, 0xff, 0x0b, 0x00,
		0x8f, 0xff, 0xac, 0xff, 0xe8, 0xff, 0x7a, 0xff,
		0x57, 0x00, 0x95, 0xff, 0x85, 0x00, 0xf0, 0xff,
		0x65, 0x00, 0x55, 0x00, 0x16, 0x00, 0x84, 0x00,
		0xb5, 0xff, 0x6b, 0x00, 0x79, 0xff, 0x16, 0x00,
		0x93, 0xff, 0xb0, 0xff, 0xed, 0xff, 0x72, 0xff,
		0x4d, 0x00, 0x8f, 0xff, 0x87, 0x00, 0xea, 0xff,
		0x74, 0x00, 0x49, 0x00, 0x1a, 0x00, 0x7f, 0x00,
		0xb6, 0xff, 0x71, 0x00, 0x7e, 0xff, 0x24, 0x00,
		0x8b, 0xff, 0xbc, 0xff, 0xe2, 0xff, 0x7b, 0xff,
		0x4c, 0x00, 0x88, 0xff, 0x87, 0x00, 0xdd, 0xff,
		0x73, 0x00, 0x3f, 0x00, 0x26, 0x00, 0x82, 0x00,
		0xbf, 0xff, 0x77, 0x00, 0xbf, 0xff, 0x77, 0x00,
		0x55, 0x55, 0x55, 0x55,
	};

	C_TEST_SB_RECEIVED_RX_IQ_SAMPLES_STR *pl_sbra =
	    tatrf_isi_msg_add_sb_copy(&vl_msg_info,
				      C_TEST_SB_RECEIVED_RX_IQ_SAMPLES,
				      IQsampleRespBytes,
				      sizeof(IQsampleRespBytes));
	pl_sbra->status = C_TEST_OK;
#else
	C_TEST_SB_RECEIVED_RX_IQ_SAMPLES_STR *pl_sbra =
	    tatrf_isi_msg_add_sb(&vl_msg_info,
				 C_TEST_SB_RECEIVED_RX_IQ_SAMPLES);
	pl_sbra->status = C_TEST_FAILED;
	pl_sbra->system_info = C_TEST_GSM;
	pl_sbra->fill2_rx_path = MAKE16(0xAA, CTRL_RF_PATH1);
	pl_sbra->sample_freq = 970;
	pl_sbra->rx_gain = 1;
	pl_sbra->nbr_of_data = 0;
#endif /* STUB_RX_IQSAMPLES_SB_FAILED */

#else
	pl_resp->status = C_TEST_FAILED;
#endif /* STUB_RX_IQSAMPLES_FAILED */
#endif /* STUB_RX_IQSAMPLES */

	v_tatlrf_iq_samples_status = GetU8InU16(LSB_POSS, pl_resp->status);
	v_tatlrf_iq_samples_sample_freq = 0;
	v_tatlrf_iq_samples_rx_gain = 0;
	v_tatlrf_iq_samples_nb_data = 0;

	if (C_TEST_OK == LOWBYTE(pl_resp->status)) {
		/* response should have returned a C_TEST_SB_RECEIVED_RX_IQ_SAMPLES subblock */
		C_TEST_SB_RECEIVED_RX_IQ_SAMPLES_STR *pl_sbr =
		    tatrf_isi_find_sb(&vl_msg_info,
				      C_TEST_SB_RECEIVED_RX_IQ_SAMPLES, NULL);
		if (NULL != pl_sbr) {
			v_tatlrf_iq_samples_sample_freq = pl_sbr->sample_freq;
			v_tatlrf_iq_samples_rx_gain = pl_sbr->rx_gain;
			v_tatlrf_iq_samples_nb_data = pl_sbr->nbr_of_data;

			if (new_message == C_TEST_FALSE) {
				char vl_syscmd[256];
				snprintf(vl_syscmd, 256, "%s %s %d",
					 RX_IQ_SAMPLES_SCRIPT,
					 RX_IQ_SAMPLES_FILE,
					 v_tatlrf_iq_samples_nb_data);
				system(vl_syscmd);
			}

			/* append an IQ sample record to file. File is different for each system */
			FILE *fp = fopen(RX_IQ_SAMPLES_FILE, "a+t");
			if (fp) {
				add_iq_sample_record(fp, pl_sbr, new_message);
				fclose(fp);
			} else {
				SYSLOG(LOG_ERR,
				       "fail to open IQ sample file '%s'",
				       RX_IQ_SAMPLES_FILE);
				vl_Error = TAT_ERROR_FILE_OPEN;
			}
		} else {
			vl_Error = TAT_ERROR_NOT_MATCHING_MSG;
		}
	} else {
		SYSLOG(LOG_WARNING, "Read IQ samples status failed");
		vl_Error = TAT_ERROR_OFF;
	}

	return vl_Error;
}

int tatl16_01IQSample_exec(struct dth_element *elem)
{
	int vl_Error = TAT_ERROR_OFF;
	SYSLOG(LOG_DEBUG, "executing %s (%d)", elem->path, elem->user_data);

	switch (elem->user_data) {
	case ACT_RX2G5_IQSAMPLE:
	case ACT_RX3G_IQSAMPLE:
		{
			if (ACT_RX3G_IQSAMPLE == elem->user_data) {
				vl_Error =
				    tatl16_readIQSamples(elem,
							 v_tatlrf_iq_samples_is_new);
			} else {
				vl_Error =
				    tatl16_readIQSamples(elem, C_TEST_TRUE);
			}
		}
		break;

	default:
		/* Invalid request code */
		vl_Error = TAT_BAD_REQ;
	}

	return vl_Error;
}

int tatl16_02IQSample_set(struct dth_element *elem, void *value)
{
	int vl_Error = TAT_ERROR_OFF;

	SYSLOG(LOG_DEBUG, "setting IQSample data %s (%d)", elem->path,
	       elem->user_data);

	switch (elem->user_data) {
	case ACT_RX_IQSAMPLE_IS_NEW_MSG:

		if (DEREF_PTR(value, u32) == ACT_IQ_SAMPLE_IS_NEW) {
			v_tatlrf_iq_samples_is_new = C_TEST_TRUE;
		} else {
			v_tatlrf_iq_samples_is_new = C_TEST_FALSE;
		}
		break;

	case ACT_RX_IQSAMPLE_PATH:

		/* WCDMA path */
		switch (*(u32 *) value) {
		case RF_IQSAMPLE_PATH1:

			SYSLOG(LOG_INFO, "WCDMA path set to PATH1");
			v_tatlrf_iq_samples_path = CTRL_RF_PATH1;
			break;

		case RF_IQSAMPLE_PATH2:

			SYSLOG(LOG_INFO, "WCDMA path set to PATH2");
			v_tatlrf_iq_samples_path = CTRL_RF_PATH2;
			break;

		default:
			SYSLOG(LOG_ERR, "invalid WCDMA path code");
			vl_Error = TAT_BAD_REQ;
		}
		break;

	default:
		SYSLOG(LOG_ERR, "invalid input code");
		vl_Error = TAT_BAD_REQ;
	}

	return vl_Error;
}

int tatl16_03IQSample_get(struct dth_element *elem, void *Value)
{
	int vl_Error = TAT_ERROR_OFF;
	SYSLOG(LOG_DEBUG, "getting IQSample data %s (%d)", elem->path,
	       elem->user_data);

	switch (elem->user_data) {
	case ACT_RX_IQSAMPLE_FREQ:

		/* sample frequency in KHz */
		*((u16 *) Value) = v_tatlrf_iq_samples_sample_freq;
		SYSLOG(LOG_INFO, "sample freq. = %u KHz", *((u16 *) Value));
		break;

	case ACT_RX_IQSAMPLE_GAIN_INDEX:

		/* RX gain index */
		*((u16 *) Value) = v_tatlrf_iq_samples_rx_gain;
		SYSLOG(LOG_INFO, "rx gain = %u", *((u16 *) Value));
		break;

	case ACT_RX_IQSAMPLE_NB_DATA:

		/* number of IQ samples data */
		*((u16 *) Value) = v_tatlrf_iq_samples_nb_data;
		SYSLOG(LOG_INFO, "nb data = %u", *((u16 *) Value));
		break;

	case ACT_RX_IQSAMPLE_STATUS:

		/* status */
		*((u16 *) Value) = v_tatlrf_iq_samples_status;
		SYSLOG(LOG_INFO, "status = 0x%4X", *((u16 *) Value));
		break;

	default:
		SYSLOG(LOG_ERR, "invalid output code");
		vl_Error = TAT_BAD_REQ;
	}

	return vl_Error;
}

void add_iq_sample_record(FILE * fp, C_TEST_SB_RECEIVED_RX_IQ_SAMPLES_STR * sb,
			  u32 new_message)
{
	time_t vl_t;
	struct tm *vl_tm;
	int i;
	char vl_str[64];
	int max_data = sb->nbr_of_data - 1;
	if (max_data < 0)
		max_data = 0;

	if (C_TEST_TRUE == new_message) {
		/* add local date and time */
		vl_t = time(NULL);
		vl_tm = localtime(&vl_t);
		if (vl_tm != NULL) {
			if (strftime(vl_str, sizeof(vl_str), "%D %T", vl_tm) !=
			    0) {
				/* start by a new line */
				fputc('\n', fp);

				/* date and time */
				fputs(vl_str, fp);

				/* system info in hexa */
				fputc(',', fp);
				fprintf(fp, "0x%X", sb->system_info);

				/* path */
				fputc(',', fp);
				switch (sb->system_info) {
				case C_TEST_GSM:
					fputs("2G", fp);
					break;

				case C_TEST_WCDMA:
					switch (GetU8InU16
						(LSB_POSS, sb->fill2_rx_path)) {
					case CTRL_RF_PATH1:
						fputs("3G:main", fp);
						break;

					case CTRL_RF_PATH2:
						fputs("3G:diversity", fp);
						break;

					default:
						fputs("3G", fp);
					}
					break;

				case C_TEST_EUTRAN:
					fputs("EUTRAN", fp);
					break;

					/* no default */
				}

				/* band info and channel number */
				fputc(',', fp);
				switch (sb->system_info) {
				case C_TEST_GSM:
					{
						const
						    C_HAL_SB_GSM_RX_CONTROL_STR
						    *pl_rx2GInfo =
						    tatl1_06GetRx2GInfo();
						if (NULL != pl_rx2GInfo) {
							int vl_bandNbr =
							    tatl3_10GetGsmBandNumber
							    (pl_rx2GInfo->
							     gsm_band_info);
							fprintf(fp, "%d",
								vl_bandNbr);
						}

						/* channel number */
						fputc(',', fp);
						if (NULL != pl_rx2GInfo) {
							fprintf(fp, "%u",
								pl_rx2GInfo->
								rx_channel);
						}
					}
					break;

				case C_TEST_WCDMA:
					{
						const
						    C_HAL_SB_WCDMA_RX_CONTROL_STR
						    *pl_rx3GInfo =
						    tatl1_06GetRx3GInfo();
						if (NULL != pl_rx3GInfo) {
							int vl_bandNbr =
							    tatl3_11GetWcdmaBandNumber
							    (pl_rx3GInfo->
							     band_info);
							fprintf(fp, "%d",
								vl_bandNbr);
						}

						/* channel number */
						fputc(',', fp);
						if (NULL != pl_rx3GInfo) {
							fprintf(fp, "%u",
								pl_rx3GInfo->
								dl_uarfcn);
						}
					}
					break;

				default:
					/* error: no TAT interface for EUTRAN */
					SYSLOG(LOG_ERR,
					       "no TAT interface for system_info 0x%X",
					       sb->system_info);

					/* channel number */
					fputc(',', fp);
				}

				/* status in hexa */
				fputc(',', fp);
				fprintf(fp, "0x%X", sb->status);

				/* frequency in KHz */
				fputc(',', fp);
				fprintf(fp, "%u", sb->sample_freq);

				/* RX gain index */
				fputc(',', fp);
				fprintf(fp, "%u", sb->rx_gain);

				/* amount of data */
				fputc(',', fp);
				fprintf(fp, "%u", sb->nbr_of_data);

				/* data i/q pairs */
				for (i = 0; i < max_data; i++) {
					fputc(',', fp);
					fprintf(fp, "%d,%d",
						sb->rx_iq_data[i].i_data,
						sb->rx_iq_data[i].q_data);
				}
			} else {
				SYSLOG(LOG_WARNING, "strftime returned 0");
			}
		} else {
			perror("localtime");
		}
	} else {
		/* continuing previous serie */

		/* append IQ pairs (next cell) at end of line */
		for (i = 0; i < max_data; i++) {
			fputc(',', fp);
			fprintf(fp, "%d,%d", sb->rx_iq_data[i].i_data,
				sb->rx_iq_data[i].q_data);
		}
	}
}
