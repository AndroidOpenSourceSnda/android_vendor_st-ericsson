/*
 * Copyright (C) ST-Ericsson SA 2012. All rights reserved.
 * This code is ST-Ericsson proprietary and confidential.
 * Any use of the code for whatever purpose is subject to
 * specific written permission of ST-Ericsson SA.
 */

#include <stdint.h>
#include <stdio.h>
#include <bass_app.h>
#include <bass_app_test.h>
#include <debug.h>

/* Offset of where to find the size of the signed header. */
#define SIZE_OF_SIGNED_HEADER_OFFSET 4

/* Offset of where to find the size of the payload. */
#define SIZE_OF_PAYLOAD_OFFSET 28

/* Typedef to the test case function pointer. */
typedef int (*test_case)(uint32_t data);

/* Signed with sign package U8500_STE_R1E. */
static const uint8_t signed_payload_xloader_8500[] = {
    0x52, 0x44, 0x48, 0x53, 0xd0, 0x00, 0x80, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x56, 0x02, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0d, 0x9f, 0xb2, 0x74, 0xce, 0xbb, 0x14, 0xad,
    0x3c, 0x7a, 0x46, 0xd1, 0xd0, 0xd0, 0x46, 0x41,
    0x3a, 0x64, 0x6b, 0x47, 0xf2, 0x53, 0xa7, 0x39,
    0xd8, 0x01, 0xb3, 0xd5, 0x55, 0xef, 0x4e, 0x25,
    0x6b, 0x0e, 0x3f, 0x64, 0xda, 0xb7, 0x7f, 0x86,
    0xe4, 0x10, 0x5e, 0xc5, 0x25, 0x65, 0xbf, 0x9c,
    0x45, 0x8a, 0x6d, 0xcb, 0x69, 0x34, 0x75, 0x8a,
    0x0d, 0xba, 0xd9, 0x48, 0xf7, 0xad, 0x51, 0xc1,
    0xe1, 0xf0, 0x1f, 0x91, 0xfe, 0x04, 0x25, 0x12,
    0x5c, 0xed, 0x14, 0x09, 0x49, 0x27, 0x98, 0x55,
    0xea, 0xc8, 0xad, 0x18, 0x02, 0xe0, 0x50, 0xb3,
    0x55, 0x4a, 0x60, 0x1d, 0x9e, 0xb6, 0x6b, 0x1a,
    0x44, 0x26, 0x9d, 0x5e, 0xf5, 0x88, 0xe1, 0x74,
    0x04, 0xd3, 0x72, 0x52, 0x9b, 0x31, 0xcf, 0xe7,
    0x33, 0xb0, 0x54, 0x13, 0xa0, 0x11, 0x96, 0xc6,
    0xee, 0xf0, 0x09, 0xdf, 0x40, 0x57, 0xc6, 0x1f,
    0x28, 0x79, 0x71, 0x78, 0x36, 0xea, 0x6f, 0x0e,
    0x95, 0x97, 0x6f, 0x1d, 0x08, 0x38, 0xf4, 0xf7,
    0xd8, 0x3b, 0x4c, 0x33, 0x1b, 0x0f, 0x1b, 0x13,
    0x13, 0x07, 0x11, 0xb0, 0x4f, 0x88, 0xa7, 0x3e,
    0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,
    0x61, 0x20, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x20,
    0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x20,
    0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20,
    0x6d, 0x61, 0x6b, 0x65, 0x20, 0x74, 0x65, 0x73,
    0x74, 0x20, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61,
    0x64, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6f,
    0x75, 0x72, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20,
    0x73, 0x75, 0x69, 0x74, 0x65, 0x2e, 0x20, 0x53,
    0x69, 0x6d, 0x70, 0x6c, 0x79, 0x0a, 0x67, 0x65,
    0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x61,
    0x20, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x20,
    0x73, 0x6f, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65,
    0x20, 0x62, 0x79, 0x20, 0x72, 0x75, 0x6e, 0x6e,
    0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x73,
    0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e,
    0x64, 0x73, 0x2e, 0x20, 0x0a, 0x0a, 0x20, 0x20,
    0x63, 0x64, 0x20, 0x3c, 0x73, 0x65, 0x63, 0x5f,
    0x67, 0x69, 0x74, 0x73, 0x3e, 0x0a, 0x20, 0x20,
    0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x4c,
    0x4f, 0x43, 0x41, 0x4c, 0x5f, 0x53, 0x49, 0x47,
    0x4e, 0x50, 0x41, 0x43, 0x4b, 0x41, 0x47, 0x45,
    0x52, 0x4f, 0x4f, 0x54, 0x3d, 0x60, 0x70, 0x77,
    0x64, 0x60, 0x2f, 0x6b, 0x65, 0x79, 0x73, 0x2f,
    0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x72, 0x6f, 0x6f,
    0x74, 0x2f, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67,
    0x65, 0x73, 0x0a, 0x20, 0x20, 0x65, 0x78, 0x70,
    0x6f, 0x72, 0x74, 0x20, 0x4c, 0x4f, 0x43, 0x41,
    0x4c, 0x5f, 0x4b, 0x45, 0x59, 0x52, 0x4f, 0x4f,
    0x54, 0x3d, 0x60, 0x70, 0x77, 0x64, 0x60, 0x2f,
    0x6b, 0x65, 0x79, 0x73, 0x2f, 0x6c, 0x6f, 0x63,
    0x61, 0x6c, 0x72, 0x6f, 0x6f, 0x74, 0x2f, 0x6b,
    0x65, 0x79, 0x73, 0x0a, 0x20, 0x20, 0x63, 0x64,
    0x20, 0x73, 0x69, 0x67, 0x6e, 0x74, 0x6f, 0x6f,
    0x6c, 0x2f, 0x73, 0x69, 0x67, 0x6e, 0x2d, 0x74,
    0x6f, 0x6f, 0x6c, 0x2d, 0x63, 0x6c, 0x69, 0x0a,
    0x20, 0x20, 0x2e, 0x2f, 0x73, 0x69, 0x67, 0x6e,
    0x2d, 0x74, 0x6f, 0x6f, 0x6c, 0x2d, 0x75, 0x35,
    0x35, 0x30, 0x30, 0x2e, 0x73, 0x68, 0x20, 0x2d,
    0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x2d, 0x70,
    0x20, 0x55, 0x38, 0x35, 0x30, 0x30, 0x5f, 0x53,
    0x54, 0x45, 0x5f, 0x52, 0x31, 0x45, 0x20, 0x2d,
    0x73, 0x20, 0x78, 0x6c, 0x6f, 0x61, 0x64, 0x65,
    0x72, 0x20, 0x69, 0x6e, 0x64, 0x61, 0x74, 0x61,
    0x2e, 0x62, 0x69, 0x6e, 0x20, 0x6f, 0x75, 0x74,
    0x64, 0x61, 0x74, 0x61, 0x2e, 0x73, 0x73, 0x77,
    0x0a, 0x0a, 0x20, 0x20, 0x4e, 0x6f, 0x74, 0x65,
    0x21, 0x0a, 0x20, 0x20, 0x31, 0x29, 0x20, 0x49,
    0x74, 0x20, 0x73, 0x65, 0x65, 0x6d, 0x73, 0x20,
    0x6c, 0x69, 0x6b, 0x65, 0x20, 0x79, 0x6f, 0x75,
    0x20, 0x61, 0x6c, 0x77, 0x61, 0x79, 0x73, 0x20,
    0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x75,
    0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
    0x69, 0x67, 0x6e, 0x2d, 0x74, 0x6f, 0x6f, 0x6c,
    0x2d, 0x75, 0x35, 0x35, 0x30, 0x30, 0x2e, 0x73,
    0x68, 0x20, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
    0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65,
    0x67, 0x61, 0x72, 0x64, 0x6c, 0x65, 0x73, 0x73,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x6c, 0x61,
    0x74, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x79, 0x6f,
    0x75, 0x20, 0x61, 0x72, 0x65, 0x20, 0x75, 0x73,
    0x69, 0x6e, 0x67, 0x2e, 0x0a, 0x0a, 0x20, 0x20,
    0x32, 0x29, 0x20, 0x2d, 0x70, 0x20, 0x28, 0x73,
    0x69, 0x67, 0x6e, 0x2d, 0x70, 0x61, 0x63, 0x6b,
    0x61, 0x67, 0x65, 0x29, 0x20, 0x6e, 0x65, 0x65,
    0x64, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65,
    0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64,
    0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d,
    0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x79, 0x6f,
    0x75, 0x20, 0x61, 0x72, 0x65, 0x20, 0x73, 0x69,
    0x67, 0x6e, 0x69, 0x6e, 0x67, 0x0a, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x28,
    0x75, 0x73, 0x65, 0x20, 0x78, 0x6c, 0x6f, 0x61,
    0x64, 0x65, 0x72, 0x29, 0x2e, 0x0a
};

#if defined(STE_PLATFORM_U8500)
static const size_t signed_payload_size = sizeof(signed_payload_xloader_8500);
static const uint8_t *signed_payload = signed_payload_xloader_8500;
#else
#warning There is no support for these test cases for the platform you are \
    trying to build.
static const size_t signed_payload_size = 0;
static const uint8_t *signed_payload = NULL;
#endif

static bass_return_code get_ehash(const uint8_t *const header,
                                  const uint32_t hdr_length,
                                  enum payload_type_t pl_type,
                                  uint8_t *ehash)
{
    bass_return_code result = BASS_RC_FAILURE;
    bass_signed_header_info_t header_info;

    result = verify_signedheader(header, hdr_length, pl_type, &header_info);

    if (BASS_RC_SUCCESS == result) {
        memcpy(ehash, header_info.ehash.value, SHA256_HASH_SIZE);
    }

    return result;
}

static uint32_t get_header_size(const uint8_t *signed_pl)
{
    const uint8_t *size_of_signed_header = signed_pl +
        SIZE_OF_SIGNED_HEADER_OFFSET;

    return *(size_of_signed_header + 1) << 8 | *size_of_signed_header;
}

static uint32_t get_payload_size(const uint8_t *signed_pl)
{
    const uint8_t *size_of_payload = signed_pl +
        SIZE_OF_PAYLOAD_OFFSET;

    return *(size_of_payload + 3) << 24 |
        *(size_of_payload + 2) << 16 |
        *(size_of_payload + 1) << 8 |
        *size_of_payload;
}

static int test_01_normal_payload_check(uint32_t data)
{
    bass_return_code result = BASS_RC_ERROR_UNKNOWN;
    bass_payload_type_t payload_type = BASS_PL_TYPE_X_LOADER;
    bass_hash_type_t hashtype = BASS_APP_SHA256_HASH;

    size_t ehash_size = SHA256_HASH_SIZE;
    uint8_t ehash[SHA256_HASH_SIZE];
    uint32_t payload_size = 0;
    uint32_t payload_offset = 0;

    (void)data;

    dprintf(INFO, "Starting test\n");
    memset(&ehash, 0, sizeof(ehash));

    result = get_ehash(signed_payload, signed_payload_size, payload_type,
                       ehash);
    if (result != BASS_RC_SUCCESS) {
        dprintf(ERROR, "failed to getting ehash\n");
        return result;
    }

    payload_offset = get_header_size(signed_payload);
    payload_size = get_payload_size(signed_payload);

    result = bass_check_payload_hash(&hashtype,
                                     &payload_type,
                                     (void *)(signed_payload + payload_offset),
                                     payload_size,
                                     ehash,
                                     ehash_size);

    if (result != BASS_RC_SUCCESS) {
        dprintf(ERROR, "failed checking payload hash\n");
        return result;
    }

    return result;
}

static int test_02_incorrect_payload_type(uint32_t data)
{
    bool failed = false;
    bass_return_code result = BASS_RC_ERROR_UNKNOWN;
    bass_payload_type_t correct_payload_type = BASS_PL_TYPE_X_LOADER;
    bass_payload_type_t payload_type = BASS_PL_TYPE_TAPP;
    bass_hash_type_t hashtype = BASS_APP_SHA256_HASH;
    size_t i = 0;
    size_t ehash_size = SHA256_HASH_SIZE;
    uint8_t ehash[SHA256_HASH_SIZE];
    uint32_t payload_size = 0;
    uint32_t payload_offset = 0;

    (void)data;

    dprintf(INFO, "Starting test\n");
    memset(&ehash, 0, sizeof(ehash));

    /*
     * We use the correct payload_type when getting the expected hash from
     * verify signed header, since the purpose of this test case is to test if
     * bass_app_test_check_payload_hash is working as it should.
     */
    result = get_ehash(signed_payload, signed_payload_size,
                       correct_payload_type, ehash);
    if (result != BASS_RC_SUCCESS) {
        dprintf(ERROR, "failed to getting ehash\n");
        return result;
    }

    payload_offset = get_header_size(signed_payload);
    payload_size = get_payload_size(signed_payload);

    for (i = payload_type;
         (i <= BASS_PL_TYPE_FRAC) && (i != correct_payload_type);
         ++i) {
        result = bass_check_payload_hash(&hashtype,
                                     &payload_type,
                                     (void *)(signed_payload + payload_offset),
                                     payload_size,
                                     ehash,
                                     ehash_size);

        if (result == BASS_RC_SUCCESS) {
            dprintf(ERROR, "incorrectly got a successfull result when "
                    "checking payload hash using payload_type: %d\n", i);
            failed = true;
        }
    }

    return failed ? BASS_RC_FAILURE : BASS_RC_SUCCESS;
}

static int test_03_modified_payload(uint32_t data)
{
    bool failed = false;
    bass_return_code result = BASS_RC_ERROR_UNKNOWN;
    bass_payload_type_t payload_type = BASS_PL_TYPE_X_LOADER;
    bass_hash_type_t hashtype = BASS_APP_SHA256_HASH;
    size_t ehash_size = SHA256_HASH_SIZE;
    uint8_t ehash[SHA256_HASH_SIZE];
    uint8_t *modified_payload = NULL;
    uint32_t payload_size = 0;
    uint32_t payload_offset = 0;

    (void)data;

    dprintf(INFO, "Starting test\n");
    memset(&ehash, 0, sizeof(ehash));

    result = get_ehash(signed_payload, signed_payload_size, payload_type,
                       ehash);
    if (result != BASS_RC_SUCCESS) {
        dprintf(ERROR, "failed to getting ehash\n");
        return result;
    }

    payload_offset = get_header_size(signed_payload);
    payload_size = get_payload_size(signed_payload);

    modified_payload = malloc(sizeof(uint8_t) * payload_size);
    if (!modified_payload) {
        return BASS_RC_FAILURE;
    }

    memcpy(modified_payload, signed_payload + payload_offset, payload_size);

    /*
     * Set the first 48 bytes to 0xFF (which is ok in in the payloads used in
     * this file, any number is good as long as it isn't greater than payload
     * size).
     * */
    memset(modified_payload, 0xFF, 48);

    result = bass_check_payload_hash(&hashtype,
                                 &payload_type,
                                 (void *)(modified_payload),
                                 payload_size,
                                 ehash,
                                 ehash_size);

    if (result == BASS_RC_SUCCESS) {
        dump_buffer("Expected hash", ehash, ehash_size);
        dump_buffer("Correct payload", signed_payload + payload_offset,
                    payload_size);
        dump_buffer("modified_payload", modified_payload, payload_size);

        dprintf(ERROR, "incorrectly got a successfull result when checking "
                "payload hash using modified payload\n");
        failed = true;
    }

    free(modified_payload);
    /*
     * Not that we expect this to fail internally, but to the function calling
     * this function it should be BASS_RC_SUCCESS test case went as expected.
     */
    return failed ? BASS_RC_FAILURE : BASS_RC_SUCCESS;
}

/*
 * Array of function pointers to test functions.
 *
 * We put the ifdef around the function pointers so that the test suite don't
 * crash on an unsupported platform.
 *
 * Be aware that you can only use 32 test case functions here since we are using
 * a 32 bits unsigned int to store the outcome of the test cases.
 */
static test_case test_cases[] = {
#if defined(STE_PLATFORM_U8500)
    &test_01_normal_payload_check,
#ifdef ER411685
    &test_02_incorrect_payload_type,
#endif
    &test_03_modified_payload
#endif
};

/*
 * Main test function for testing "check payload hash". A word of warning, if
 * you add more tests to this file you should be aware of how thing is working
 * in secure world. If for example the ME is not in a production state, then
 * some payloads are not checked fully and as a result you could get a "success"
 * from the function bass_check_payload_hash even though you might have modified
 * the payload. This is the reason why we have signed the test payloads in this
 * file with software type "xloader". That type is fully checked in a non
 * production ME also.
 *
 * @return 0 if no test case fails, otherwise any other value.
 */
uint32_t bass_app_test_check_payload_hash(void)
{
    size_t i = 0;
    uint32_t failing_test_cases = 0;

    for (i = 0; i < sizeof(test_cases) / sizeof(test_case); i++) {
        if (test_cases[i](0)) {
            failing_test_cases |= (1 << i);
        }
    }

    if (failing_test_cases) {
        for (i = 0; i < sizeof(test_cases) / sizeof(test_case); i++) {
            if (failing_test_cases & (i << 1)) {
                /* Increase with one since the array is zero indexed. */
                dprintf(ERROR, "Test case %d failed\n", i + 1);
            }
        }
        dprintf(ERROR, "The test cases above failed, for more information see "
                "the log file above!\n");
    } else {
        dprintf(ALWAYS, "All tee check_payload_hash tests passed!\n");
    }

    return failing_test_cases;
}
